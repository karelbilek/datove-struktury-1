\documentclass[a4paper,12pt]{article}
 \usepackage{amsmath}
 \usepackage{amsthm}
 \usepackage{amsfonts}
 \usepackage[unicode]{hyperref} 
 
 
 \usepackage[utf8]{inputenc}
 \usepackage[czech]{babel}
 \usepackage{graphicx} 
 \usepackage{caption} 
 
 
 \setlength{\hoffset}{-3cm} 
 \setlength{\voffset}{-3cm}
 \setlength{\textheight}{26.0cm} 
 \setlength{\textwidth}{19cm}
 \setlength{\parindent}{0in}
 \setlength{\parskip}{0.1in}
 
 %\def \emph#1{\underbar{#1}}
 
 

 
 \DeclareMathOperator*{\Prob}{Prob}
 \DeclareMathOperator*{\countop}{count}
 \DeclareMathOperator*{\NIL}{NIL}
 \DeclareMathOperator*{\otec}{otec}
 \DeclareMathOperator*{\listop}{list}
 \DeclareMathOperator*{\Prv}{Prv}
 \DeclareMathOperator*{\Nasl}{Nasl}
 \DeclareMathOperator*{\levy}{levy}
 \DeclareMathOperator*{\pravy}{pravy}
 \DeclareMathOperator*{\key}{key}
 \DeclareMathOperator*{\Prst}{Prst}
 \DeclareMathOperator*{\hloubka}{hloubka}
 \DeclareMathOperator*{\bratr}{bratr}
 \DeclareMathOperator*{\npl}{npl}
 \DeclareMathOperator*{\Cont}{Cont}
 
 \input lhead
 \usepackage{boxedminipage}
 \usepackage{graphicx}
 \usepackage{wasysym}
 \newcommand{\zapamatovat}[1]{
 {
 
 
 \hbox{\scalebox{2}{\Huge\RIGHTarrow}}
 
 \setlength\fboxrule{5pt}
 
 \begin{boxedminipage}{0.7\textwidth}
#1
 \end{boxedminipage}
 \hbox{\scalebox{2}{\Huge\LEFTarrow}}
 }
 }
 
 \newcommand{\algoritmus}[1]{
  {
  \setlength\fboxrule{0.5pt}

  \begin{boxedminipage}{0.6\textwidth}

  \setlength{\parskip}{0.1in}
 #1
  \end{boxedminipage}

  }
  }

 
 \begin{document}
     

\newtheorem*{dusledek}{Důsledek}
\newtheorem*{lemma}{Lemma}

%tohle je mozna nesmyslne komplikovane
\newtheorem{counter}{Counter}
\newtheorem{lemma_counting}[counter]{Lemma}
\newtheorem{dusledek_counting}[counter]{Důsledek}

\newtheorem*{pozorovani}{Pozorování}

\newtheorem*{veta}{Věta}
\newtheorem*{tvrzeni}{Tvrzení}
\newtheorem*{definice}{Definice}


\def \Prob{\operatorname{Prob}}
\def \var{\operatorname{var}}

\title{Datové struktury}
\date{}
\maketitle

\tableofcontents

\section{Úvod}
\emph{Základní} problém: Reprezentace množin a 
operace s~nimi. V řadě úloh a algoritmů je tento 
podproblém rozhodující pro složitost řešení, protože 
tyto operace se mnohokrát opakují. Proto je třeba 
navrhnout pro tyto úlohy co nejefektivnější algoritmy 
(každý ušetřený čas mnohonásobným opakováním začne 
hrát důležitou roli). To vede k detailní 
analýze složitosti v závislosti na vnějších okolnostech. 
Nelze říct, 
že některý algoritmus je nejlepší, protože za určitých 
okolností může být `méně efektivní' algoritmus 
výhodnější.

Cílem této přednášky není pouze seznámit vás s~algoritmy 
pro řešení těchto problémů, protože s~těmi jste se 
seznámili už v přednášce `Algoritmy a datové struktury'. Hlavním cílem 
je ukázat vám prostředky a metody, jak měřit a zjišťovat 
jejich efektivitu, a tím vám ukázat prostřed\-ky, které vám 
umožní rozhodnout se v dané situaci pro určitý algoritmus. 
Proto hlavní náplní této přednášky bude počítání efektivity 
algoritmů. Budeme počítat za 
zjednoduše\-ných 
předpokladů, protože neumím říct (a ani to nelze, protože vždy záleží 
na konkrétních okolnostech), které sofistikovanější metody 
budou v praxi vhodné pro řešení vašeho problému. Cílem přednášky je 
seznámit vás s~možnostmi, jak řešit tyto problémy, a se základními 
metodami pro jejich řešení.
\section{Hašování}


\subsection{Slovníkový problém}

Nejprve si zadefinujeme asi 
nejzákladnější problém, který řešíme v datových strukturách. 

Řešíme tzv. slovníkový problém: Dáno 
univerzum $U$, máme reprezentovat $S\subseteq U$ a navrhnout algoritmy pro 
násle\-dující operace\newline 
{\bf MEMBER$(x)$} -- zjistí, zda $x\in S$, a nalezne jeho 
uložení\newline 
{\bf INSERT$(x)$} -- když $x\notin S$, pak vloží $x$ do struktury 
repre\-zentující $S$\newline 
{\bf DELETE$(x)$} -- když $x\in S$, pak odstraní $x$ ze struktury 
reprezentující $S$.\newline 
Efektivita algoritmu: časová složitost, prostorová 
složitost;\newline 
vy\-šetřené buď v nejhorším případě nebo v 
průměrném případě nebo amortizovaně.

Literatura:\newline 
K.~Mehlhorn: Data Structures and Algorithms 1: Sorting 
and Searching, Springer 1984\newline 
\url{http://www.mpi-sb.mpg.de/~mehlhorn/DatAlgbooks.html}

J.~S.~Vitter, W.-Ch.~Chen: Design and Analysis of 
Coalesced Hashing, Oxford Univ. Press, 1987

\subsection{Hašování obecně}

Pomocí bitového pole můžeme rychle 
implementovat operace {\bf MEMBER}, {\bf INSERT} a {\bf DELETE}. 

Nevýhoda: když je velké univerzum, pak je prostorová 
složitost v nejlepším případě ohrom\-ná, ve špatném 
případě nelze pole zadat do počítače.\newline 
Hašování chce zachovat rychlost operací, ale odstranit 
paměťo\-vou náročnost. První publikovaný článek o 
hašování je od Dumney z roku 1956, první analýza hašování 
pochází od Petersona z roku 1957, ale existuje technická  
zpráva od IBM o hašování z roku 1953.

Základní idea: Dáno univerzum $U$ a množina 
$S\subseteq U$ tak, že $|S|<<|U|$. Máme funkci 
$h:U\to \{0,1,\dots,m-1\}$ (taky \emph{hešovací funkce}) a množinu $S$ reprezentujeme 
tabulkou (polem) s~$m$ řádky tak, že $s\in S$ je uložen na 
řádku $h(s)$. 

$m$ (jako \emph{memory}) si tedy budeme značit velikost tabulky; $n$ je velikost $|S|$.

Nevýhoda: mohou existovat různá $s,t\in S$ taková, 
že $h(s)=h(t)$ - tento jev se nazývá \emph{kolize}.

Hlavní problém, kterému se věnuje zbytek kapitoly: řešení kolizí.

\subsection{Hašování se separovanými řetězci}
\label{sepretezce}

Základní řešení: použijeme pole o velikosti $[
0..m-1]$ a 
$i$-tá položka pole bude spojový seznam obsahující 
všechny prvky $s\in S$ takové, že $h(s)=i$. Toto řešení se 
nazývá \emph{hašování} \emph{se} \emph{separovanými} 
\emph{řetězci}.

Příklad: $U=\{1,2,\dots,1000\}$, $S=\{1,7,11,53,
73,141,161\}$ a 
funkce je $h(x)=x\bmod10$. Pak 
\begin{gather*} P(0)=P(2)=P(4)=P(5)=P(6)=P(8)=P(9)=\emptyset ,\\
P(7)=<7>,\quad P(3)=<53,73>,\quad P(1)=<1,141,11,161>.\end{gather*}
Seznamy nemusí být uspořádané.  

\subsubsection{Algoritmy operací}


\algoritmus{

\setlength{\parskip}{0.1in}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf \textsf{if}} $i$-tý seznam je neprázdný {\bf \textsf{then}\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{while}} $t\ne x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf \textsf{do}\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{enddo}\newline 
\textsf{endif}\newline 
\textsf{if}} $t=x$ {\bf \textsf{then} Výstup}: $x\in S$ {\bf \textsf{else} Výstup}: $x\notin 
S$ {\bf \textsf{endif}


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf \textsf{if}} $i$-tý seznam je neprázdný {\bf \textsf{then}\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{while}} $t\ne x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf \textsf{do}\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{enddo}\newline 
\textsf{endif}\newline 
\textsf{if}} $t\ne x$ {\bf \textsf{then}} vložíme $x$ do $i$-tého seznamu {\bf \textsf{endif}}



{\bf DELETE}$(x)$\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf \textsf{if}} $i$-tý seznam je neprázdný {\bf \textsf{then}\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{while}} $t\ne x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf \textsf{do}\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{enddo}\newline 
\textsf{endif}\newline 
\textsf{if}} $t=x$ {\bf \textsf{then}} odstraníme $x$ z $i$-tého seznamu {\bf \textsf{endif}}

}

\subsubsection{Nejhorší případy}

V následující analýze předpokládáme, že hodnota funkce $
h(x)$ 
je spočitatelná v čase $O(1)$.

V nejhorším případě operace vyžadují čas $
O(|S|)$ 
(všechny prv\-ky jsou v jednom seznamu). \newline 
Požadovaná paměťová náročnost $O(m+|S|)$ 
(předpokládáme, že reprezentace prvku $s\in S$ vyžaduje paměť $
O(1)$)\newline 
Paměť není efektivně využitá.

Další kapitoly \ref{sepretezce} jsou věnovány \textbf{očekávaným případům} 

\subsubsection{Očekávané případy - předpoklady}

Pro výpočet očekávaných případů si zavedeme předpoklady:
\begin{enumerate}
\item
$h$ je rychle spočitatelná (tj. $O(1)$) a neměnná během 
výpočtu;
\item všechny $h^{-1}(i)$ jsou stejně velké, tj.
$h$ rozděluje univerzum $U$ rovnoměrně (tj. 
$-1\le |h^{-1}(i)|-|h^{-1}(j)|\le 1$ pro $i,j\in \{0,1,\dots,m-1\}$ -- rozdíl 1 kvůli tomu, že jde o celá čísla);
\item
$S$ je náhodně vybraná z univerza $U$ (tj. pro dané $n=|S|$ 
jsou všechny podmnoži\-ny $U$ o velikosti $n$ reprezentovanou 
množinou $S$ se stejnou pravděpodobností);
\item
každý prvek z $U$ má stejnou pravděpodobnost být 
argumentem operace {\bf INSERT}, {\bf DELETE}, {\bf MEMBER}
\item
velikost reprezentované množiny je výrazně menší než 
velikost univerza.
\end{enumerate}

Použité značení: $|S|=n$ (\emph{number}), $m=$počet 
řetězců (\emph{memory}), $|U|=N$,\newline 
$\ell (i)=$délka $i$-tého řetězce, $\alpha =\frac nm$ faktor naplnění (load factor)

\subsubsection{Jednoduché důsledky předpokladů}
\begin{enumerate}
\item 
$\Prob(h(x)=i)=\frac 1m$ pro všechna $x\in U$ a všechna 
$i=0,1,\dots,m-1$ -- tj. prvky jsou rovnoměrně rozloženy do \uv{slotů} 
\item 
$\Prob(\ell (i)=l)=p_{n,l}=\binom nl(\frac 1m)^l(1-\frac 1m)^{n-l}$ 
pro všechna $i=0,1,\dots,m-1$ -- tj. délky řetězců mají binomiální rozdělení.
\end{enumerate}

Vysvětlení: $i$-tý řetězec má délku $
l$, právě když je $l$ prvků z $S$ zahešováno do $i$ a zbytek ne -- tj. existuje 
pod\-mno\-žina $A\subseteq S$ taková, že $|A|=l$ (těchto možností je 
$\binom nl$), pro každé $x\in A$ platí $h(x)=i$ (pravděpodobnost 
tohoto jevu je $(\frac 1m)^l$) a pro každé $x\in S\setminus 
A$ platí $h(x)\ne i$ 
(pravděpodobnost tohoto jevu je $(1-\frac 1m)^{n-l}$). To znamená, že jev má 
binomiální rozdělení.

Zde jsme nepřesní kvůli možnému rozdílu 1 ve velikostech množin. Obecně pro náhodně zvolené $
x\in U$ 
a dané $i$ je $\Prob(h(x)=i)=\frac {|h^{-1}(i)|}{|U|}$ a když existují dvě různá 
$i,j\in \{0,1,\dots,m-1\}$ taková, že $|h^{-1}(i)|\ne |h^{-1}
(j)|$, pak obecně 
$\frac {|h^{-1}(i)|}{|U|}\ne\frac 1m$. Toto nastane i v případě, když jsme již zvolili nějaký 
prvek v $h^{-1}(i)$. Protože však předpokládáme, že $
n,m<<|U|$ tak 
ve všech uvažovaných případech je $Prob(h(x)=i)$ přibližně 
$\frac 1m$, a můžeme tuto pravděpodobnost aproximovat 
hodnotou $\frac 1m$.

\subsubsection{Očekávaná délka řetězců}

\begin{veta}
    Očekávaná délka řetězců je $\frac{n}{m}$.
\end{veta}

\begin{proof}

\begin{align*} E(l)=&\sum_{l=0}^nlp_{n,l}=\sum_{l=0}^nl\binom nl(\frac 
1m)^l(1-\frac 1m)^{n-l}=\\
&\sum_{l=0}^nl\frac {n!}{l!(n-l)!}(\frac 1m)^l(1-\frac 1m)^{n-l}=\\
&\frac nm\sum_{l=1}^n\frac {(n-1)!}{(l-1)!(n-l)!}(\frac 1m)^{l-1}
(1-\frac 1m)^{n-l}=\\
&\frac nm\sum_{l=1}^n\binom {n-1}{l-1}(\frac 1m)^{l-1}(1-\frac 1m
)^{(n-1)-(l-1)}=\\
&\frac nm\sum_{l=0}^{n-1}\binom {n-1}l(\frac 1m)^l(1-\frac 1m)^{n
-1-l}=\\
&\frac nm(\frac 1m+1-\frac 1m)^{n-1}=\frac nm.\end{align*}
Toto je standardní elementární výpočet 
očekávané hodnoty binomiálního rozdělení.  
\end{proof}


\begin{lemma}[Druhý moment]
    $E(l^2)=\frac nm(1+\frac {n-1}m)$
\end{lemma}
\begin{proof}
\begin{align*} E(l^2)=&E(l(l-1))+E(l),\\
E(l(l-1&))=\sum_{l=0}^nl(l-1)\binom nl(\frac 1m)^l(1-\frac 1m)^{n
-l}=\\
&\frac {n(n-1)}{m^2}\sum_{l=2}^n\binom {n-2}{l-2}(\frac 1m)^{l-2}
(1-\frac 1m)^{(n-2)-(l-2)}=\\
&\frac {n(n-1)}{m^2}\sum_{l=0}^{n-2}\binom {n-2}l(\frac 1m)^l(1-\frac 
1m)^{n-2-l}=\\
&\frac {n(n-1)}{m^2},\\
E(l^2)=&\frac {n(n-1)}{m^2}+\frac nm=\frac nm(1+\frac {n-1}m).\end{align*}
\end{proof}


\begin{veta}
    Rozptyl řetězců je $nm(1-\frac 1m)$.
\end{veta}

\begin{proof}
\begin{align*}\var(l)=&E(l-E(l))^2=E(l^2)-(E(l))^2=\\
&\frac nm(1+\frac {n-1}m)-(\frac nm)^2=\frac nm(1-\frac 1m).\end{align*}

\end{proof}

Shrneme výsledky:\newline 

\zapamatovat{
Očekávaná délka řetězců je $\frac nm$ a rozptyl délky 
řetězců je $\frac nm(1-\frac 1m)$.
}
    
Toto jsou standardní elementární odvození druhého momentu
a rozptylu binomiálního rozdělení.

\subsubsection{Očekávaný nejdelší řetězec}

Spočítáme $E(NP)$ očekávanou délku maximálního 
řetězce ($NP$ jako nejhorší případ :))

\begin{lemma}
    $E(NP) = \sum_j\Prob(\max_i\ell (i)\ge j)$, kde $\ell(i)$ je délka $i$-tého řetězce.
\end{lemma}

\begin{proof}
Platí, že
$$\Prob(\max_i\ell (i)=j)=\Prob(\max_i\ell (i)\ge j)-\Prob(\max_i
\ell (i)\ge j+1).$$

Pak můžeme počítat:
\begin{align*} E(NP)=&\sum_jj\Prob(\max_i\ell (i)=j)=\\
&\sum_jj(\Prob(\max_i\ell (i)\ge j)-\Prob(\max_i\ell (i)\ge j+1))
=\\
&\sum_jj\Prob(\max_i\ell (i)\ge j)-\sum_jj\Prob(\max_i\ell (i)\ge 
j+1)=\\
&\sum_jj\Prob(\max_i\ell (i)\ge j)-\sum_j(j-1)\Prob(\max_i\ell (i
)\ge j)=\\
&\sum_j(j-j+1)\Prob(\max_i\ell (i)\ge j)=\\
&\sum_j\Prob(\max_i\ell (i)\ge j).\end{align*}
Vysvětlení: Při čtvrté rovnosti se v druhé sumě zvětšil 
index, přes který sčítáme, o $1$, v páté rovnosti se k sobě 
daly koeficienty při stejných pravděpodobnostech ve dvou 
sumách. 

\end{proof}

\begin{lemma}
$\Prob(\max_i(\ell (i))\ge j)\le\min\{1,n(\frac nm)^{j-1}\frac 1{
j!}\}.$
\end{lemma}

\begin{proof}
\begin{align*}\Prob(\max_i&(\ell (i))\ge j)=\\
&\Prob(\ell (1)\ge j\vee\ell (2)\ge j\vee\dots\vee\ell (m-1)\ge j
)\le\\
&\sum_i\Prob(\ell (i)\ge j)\le m\binom nj(\frac 1m)^j=\\
&\frac {\prod_{k=0}^{j-1}(n-k)}{j!}(\frac 1m)^{j-1}\le n(\frac nm
)^{j-1}\frac 1{j!}.\end{align*}
Vysvětlení:  První nerovnost plyne z toho, že 
pravděpodobnost disjunkce jevů je menší než 
součet pravděpodobností jevů, dru\-há nerovnost 
plyne z toho, že $i$-tý řetězec má délku alespoň $
j$, jakmile existuje 
podmnožina $A\subseteq S$ taková, že $|A|=j$ (těchto možností je $\binom 
nj$) a pro každé $x\in A$ platí $h(x)=i$ (pravděpo\-dob\-nost 
tohoto jevu je $(\frac 1m)^j$). Protože pravděpodobnost je pro všechna $i$ stejná a $i$ nabývá $m$ hodnot, dostáváme druhou nerovnost. Následující rovnost plyne z rozepsání binomických koeficientů. Poslední nerovnost dostane\-me nahrazením $n-k$ hodnotou $n$.

Že pravděpodobnost je menší než 1 je triviální.

\end{proof}

\begin{lemma}[Stirlingův vzorec pro faktoriály (bez důkazu)]
    $j!=\sqrt{2j\pi}\left(\frac je\right)^j\left(1+\frac 1{12j}+\frac 1{288j^2}+O(j^{-3})\right)$
\end{lemma}

\begin{lemma}[Pomocné lemma]
    Když $(\frac qe)^q\le n$, pak $q\le(1+o(1))\frac{\ln n}{\ln\ln n}$.
\end{lemma}

\begin{proof}Všimněme si nejdřív, že platí
\begin{align*}\left((\ln(\frac{\ln n}{\ln\ln n})-1\right)\frac{\ln n}{\ln\ln n}=&(\ln\ln n-\ln\ln\ln n-1)\frac{\ln n}{\ln\ln n}=\\&
\ln n-\frac{\ln n(\ln\ln\ln n)}{\ln\ln n}-\frac{\ln n}{\ln\ln n}=\\&\ln n(1-\frac{\ln\ln\ln n}{\ln\ln n}-
\frac 1{\ln\ln n})=(1+o(1))\ln n,\end{align*}
protože $\lim_{n\mapsto\infty}\frac{\ln\ln\ln n}{\ln\ln n}=0=\lim_{n\mapsto\infty}\frac 1{\ln\ln n}$. 
Odtud plyne $$\lim_{n\mapsto\infty}\left(\frac{\frac{\ln n}{\ln\ln n}}e\right)=e^{(1+o(1))\ln n}=n.$$ Protože $(\frac qe)^q$ je rostoucí funkce, tak dostáváme, že $q\le(1+o(1))(\frac{\ln n}{\ln\ln n})$.
\end{proof}

Označme si $j_0 = \min\{j\mid n(\frac nm)^{j-1}\frac 1{j!}\le 1\}$

\begin{lemma}[Omezení $j_0$]
    Pokud  $\alpha =\frac nm\le 1$, pak $j_0\le\frac {(1+o(1))\log n}{\log\log n}$
\end{lemma}

\begin{proof}
    $$j_0=\min\{j\mid n(\frac nm)^{j-1}\frac 1{j!}\le 1\}\le\min\{j\mid n\le j!\}\le\min\{j\mid n\le
    (\frac je)^j\}\le(1+o(1))\frac{\ln n}{\ln\ln n}.$$
    
    První nerovnost je jen převedení na druhou stranu a ignorování zlomku menšího než 1, druhá nerovnost plyne ze Stirlingova vzorce, třetí plyne z pomocného lemmatu.
\end{proof}

\begin{veta}
    Pokud  $\alpha =\frac nm\le 1$, horní odhad odhad očekávané délky 
    maximálního ře\-těz\-ce je $O(\frac {\log n}{\log\log n})$
\end{veta}
 
\begin{proof}
\begin{align*} E(NP)=&\sum_j\Prob(\max_i(\ell (i))\ge j)\le\\
&\sum_j\min\{1,n(\frac nm)^{j-1}\frac 1{j!}\}=\\
&\sum_{j=1}^{j_0}1+\sum_{j=j_0+1}^{\infty}\big(n(\frac nm)^{j-1}\frac 
1{j!}\big)\le j_0+\sum_{j=j_0+1}^{\infty}\frac n{j!}=\\
&j_0+\frac n{j_0!}\sum_{j=j_0+1}^{\infty}\frac {j_0!}{j!}\le j_0+
\sum_{j=j_0+1}(\frac 1{j_0+1})^{j-j_0}=\\
&j_0+\frac {\frac 1{j_0+1}}{-\frac 1{j_0+1}+1}=j_0+\frac 1{j_0}=O
(j_0).\end{align*}
Vysvětlení: Při druhé rovnosti jsme použili, že $n(\frac nm)^{j-1}\frac 1{j!}\le 1$, právě když $j\le j_0$. Při druhé nerovnosti jsme použili, že $\frac 
nm\le 1$, 
při třetí nerovnosti jsme použili, že $\frac n{j_
0!}\le 1$ a 
$$\frac {j_0!}{j!}=\frac 1{\prod_{k=j_0+1}^jk}\le (\frac 1{j_0+
1})^{j-j_0}.$$
\end{proof}

\begin{veta}[bez důkazu]
    Když $0.5\le\alpha\le 1$, je $O(\frac {\log n}{\log\log n})$ zároveň i dolní odhad $E(NP)$.
    
\end{veta}

Shrneme získaný výsledek

\zapamatovat{
Za předpokladu $\alpha =\frac nm\le 1$ je při hašování 
se se\-parovanými řetězci horní odhad očekávané délky 
maximálního ře\-těz\-ce $O(\frac {\log n}{\log\log n}
)$.  

Když $0.5\le\alpha\le 1$, je to zároveň i dolní odhad.
}

\subsubsection{Očekávaný počet testů}

Test je porovnání argumentu operace s~prvkem na daném místě řetězce nebo zjiště\-ní, 
že vyšetřovaný řetězec je prázdný.

Budeme rozlišovat dva případy:\newline 
\phantom{---}\emph{úspěšné} \emph{vyhledávání} -- argument 
operace je mezi prvky reprezentované množiny,\newline 
\phantom{---}\emph{neúspěšné} \emph{vyhledávání} -- argument 
operace není mezi prv\-ky reprezentované mno\-žiny.

\begin{veta}[Neúspěšné vyhledávání]
    Při hašování se separovanými řetězci je 
    očekávaný po\-čet testů při neúspeš\-ném 
    vy\-hledávaní přibližně $e^{-\alpha}+\alpha$
\end{veta}

\begin{proof}
Očekávaný počet testů:
\begin{align*} E(T)=&\Prob(\ell (i)=0)+\sum_ll\Prob(\ell (i)=l)=\\
&p_{n,0}+\sum_llp_{n,l}=\\
&(1-\frac 1m)^n+\frac nm\approx e^{-\alpha}+\alpha .\end{align*}
Vysvětlení: Zjištění, zda řetězec je prázdný, vyžaduje 
jeden test, tj. $\Prob(\ell (i)=0)$ není s~koeficientem $0$, ale $
1$.
Protože pravděpodobnosti jsou stejné pro všechny 
řetězce, nemusíme specifikovat řetězec, který 
vyšetřujeme, stačí psát obecně $i$. $\sum_llp_{
n,l}$ jsme spočítali 
při výpočtu očekávané délky řetězce.
\end{proof}


\begin{veta}[Úspěšné vyhledávání]
    Při hašování se separovanými řetězci je 
    očekávaný po\-čet testů při úspeš\-ném 
    vy\-hledávaní přibližně $1+\frac{\alpha}{2}$
\end{veta}

\begin{proof}
Zvolme jeden řetězec prvků o délce $l$. 
Počet testů při vyhledání všech prvků 
v tomto řetězci je
$$1+2+\dots+l=\binom {l+1}2.$$

Očekávaný počet testů při vyhledání všech 
prvků v nějakém řetězci je 
$$\sum_l\binom {l+1}2\Prob(\ell (i)=l)=\sum_l\binom {l+1}2p_{n,l}
.$$

Očekáný počet testů při vyhledání všech 
prvků v tabulce je $m\sum_l\binom {l+1}2p_{n,l}$.

Očekávaný počet testů pro 
vyhledání jednoho prvku je 
\begin{align*}\frac mn\sum_{l=0}^n\binom {l+1}2p_{n,l}=&\frac m{2n}\big
(\sum_{l=0}^nl^2p_{n,l}+\sum_{l=0}^nlp_{n,l}\big)=\\
&\frac m{2n}\big(\sum_{l=1}^nl(l-1)p_{n,l}+2\sum_{l=1}^nlp_{n,l}\big
)=\\
&\frac m{2n}(\frac {n(n-1)}{m^2}+\frac {2n}m)=\frac {n-1}{2m}+1\approx\\
&1+\frac {\alpha}2.\end{align*}
\end{proof}

Jiný postup.
\begin{proof}
    Předpokládejme, že počet testů při úspěšném 
vyhledávání prvku $x\in S$ je $1+$počet porovnání 
klíčů při neúspěšném vyhledávání $
x$ v operaci 
{\bf INSERT$(x)$}. Pak počet porovnání klíčů je délka 
řetězce, a proto očekáva\-ný počet porovnání klíčů 
je očekáva\-ná délka řetězce. Tedy očekávaný počet 
testů při úspěšném vyhledávání $x$ je  
$1+$očekávaná délka řetězce v okamžiku vkládání $
x$, neboli 
$$\frac 1n\sum_{i=0}^{n-1}(1+\frac im)=1+\frac {n-1}{2m}.$$

\end{proof}

\zapamatovat{

Při hašování se separovanými řetězci je 
očekávaný po\-čet testů při neúspeš\-ném 
vy\-hledávaní přibližně $e^{-\alpha}+\alpha$ a při ús\-pěš\-ném 
vyhledávání přibližně $1+\frac {\alpha}2$.
}

Následující tabulka dává přehled očekávaného 
počtu testů pro různé hodnoty $\alpha$
$$\vtop{\hbox{\vbox {\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\hfill # \hfill \vrule\cr\noalign{\hrule} $
\alpha$ & 0 & 0.1 & 0.2 & 0.3 & 0.4 & 0.5 & 0.6 \cr\noalign{\hrule}neúsp. vyh. & 1 & 1.005 & 1.019 & 1.041 & 1.07 & 1.107 & 1.149 \cr\noalign{\hrule} úspěš. vyh. & 1 & 1.05 & 1.1 & 1.15 & 1.2 & 1.25 & 1.3 \cr\noalign{\hrule}}}}\hbox{\vbox {\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\hfill # \hfill \vrule\cr\noalign{\hrule} $
\alpha$ & 0.7 & 0.8 & 0.9 & 1 & 2 & 3 \cr\noalign{\hrule}neúsp. vyh. & 1.196 & 1.249 & 1.307 & 1.368 & 2.135 & 3.05 \cr\noalign{\hrule}úspěš. vyh. & 1.35 & 1.4 & 1.45 & 1.5 & 2 & 2.5 \cr\noalign{\hrule}}}}}$$

Všimněte si, že očekávaný počet testů 
při neúspěšném vy\-hledávání je menší než očekávaný 
počet testů při úspěšném vy\-hledávání, když 
$\alpha\le 1$. Na první pohled vypadá tento výsledek nesmyslně, 
ale důvod je, že počet testů při 
úspěšném vy\-hledávání průměrujeme proti $
n$, 
kdežto při neúspěšném vy\-hledávání proti $
m$. 

Ilustrujeme 
to na následujícím příkladu:


Nechť $n=\frac m2$ a nechť polovina neprázdných 
řetězců má délku $1$ a polovina má délku $
2$. \newline 
Očekávaný počet testů při neúspěšném 
vyhledávaní:
\begin{itemize}
\item 
$1$ test pro prázdné řetězce a řetězce 
délky $1$ -- těchto případů je $\frac {5m}6$
\item 
$2$ testy pro řetězce délky $2$ -- těchto případů je 
$\frac m6$.
\end{itemize}
Očekávaný počet testů je 
$\frac 1m(1\frac {5m}6+2\frac m6)=\frac 76$.\newline 
Očekávaný počet testů při úspěšném 
vyhledávání: 
\begin{itemize}
\item 
$1$ test pro prvky na prvním místě řetězce -- těchto 
případů je $\frac {2n}3$
\item 
$2$ testy pro prvky, které jsou na druhém místě řetězce -- těchto 
případů je $\frac n3$.
\end{itemize}
Očekávaný počet testů je $\frac 1n(1\frac {2n}
3+2\frac n3)=\frac 43$.

Velikost $\alpha$ je doporučována menší než $
1$, ale nemá být 
hodně malá, protože by paměť nebyla efektivně využita. 

\subsection{Hašování s~uspořádanými separovanými řetězci}

Vylepšení metody: hašování s~uspořádanými řetězci.
Rozdíl proti původní metodě -- řetězce jsou 
uspořádané ve vzrůsta\-jícím pořadí. Protože 
řetězce obsahují tytéž prvky, je počet očeká\-va\-ných testů 
při úspěšném vyhledávání stejný jako u ne\-uspořádaných 
řetězců. Při neúspěšném vyhledávání končíme, 
když argument operace je menší než vyšetřovaný prvek 
v řetěz\-ci, tedy končíme dřív. 

\subsubsection{Očekávaný počet testů}

\zapamatovat{

Očekávaný počet testů při 
neúspěšném vyhledávání pro hašování s~uspořá\-danými 
řetězci je přibližně $e^{-\alpha}+1+\frac {\alpha}
2-\frac 1{\alpha}(1-e^{-\alpha})$. 

Očekávaný 
počet testů při úspěšném vyhledávání pro 
hašování s~uspořádanými řetězci je 
přibližně $1+\frac {\alpha}2.$
}



\subsubsection{Algoritmy}

\algoritmus{
    

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf \textsf{if}} $i$-tý seznam je neprázdný {\bf \textsf{then}\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{while}} $t<x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf \textsf{do}\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{enddo}\newline 
\textsf{endif} \newline 
\textsf{if}} $t=x$ {\bf \textsf{then}} $x\in S$ {\bf \textsf{else}} $x\notin S$ {\bf \textsf{endif}

INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf \textsf{if}} $i$-tý seznam je neprázdný {\bf \textsf{then}\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{while}} $t<x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf \textsf{do}\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{enddo}\newline 
\textsf{endif} \newline 
\textsf{if}} $t\ne x$ {\bf \textsf{then}\newline 
\phantom{{\rm ---}}\textsf{if}} $x<t$ {\bf \textsf{then}\newline 
\phantom{{\rm ------}}}vložíme $x$ do $i$-tého seznamu před prvek $
t$\newline 
\phantom{---}{\bf \textsf{else}}\newline  
\phantom{------}vložíme $x$ do $i$-tého seznamu za prvek $
t$\newline 
\phantom{---}{\bf \textsf{endif}\newline 
\textsf{endif}

DELETE$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline
{\bf \textsf{if}} $i$-tý seznam je neprázdný {\bf \textsf{then}\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{while}} $t<x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf \textsf{do}}\newline 
\phantom{------}$t:=$následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf \textsf{enddo}\newline 
\textsf{endif}\newline 
\textsf{if}} $t=x$ {\bf \textsf{then}} odstraníme $x$ z $i$-tého seznamu {\bf \textsf{endif}

}

}
    
Nevýhody hašovaní se separovanými řetězci --\newline 
\phantom{---}nevyužití alokované paměti (nehospodárné)\newline 
\phantom{---}používání ukazatelů (cache).\newline 

Řešení: využít pro řetězce původní tabulku. Pak řádky tabulky musí mít strukturu, která umožňuje prohledávat řetězce, a velikost reprezentované množiny 
může být nejvýše rovna velikosti tabulky.  

Položky tabulky:\newline 
\phantom{---}key,\newline 
\phantom{---}odkaz na uložená data,\newline 
\phantom{---}položky pro práci s~tabulkou.

Předpokládáme, že data jsou velká, v tom případě se 
ukládají mimo tabulku. V tabulce je jen odkaz na uložená data. 
Při popisu práce s~tabulkou tuto část budeme vynechávat (tj. 
data budou pouze klíč).

Podle řešení kolize dělíme dál hašování:
\begin{enumerate}
\item 
hašování s~přemísťováním, hašování s~dvěma 
ukazateli, 
\item 
srůstající hašování,
\item 
dvojité hašování a hašování s~lineárním 
přidáváním.
\end{enumerate}

\subsection{Hašování s~přemísťováním}

Položky pro práci s~tabulkou: next, previous\newline 
\phantom{---}položka next -- číslo řádku tabulky 
obsahující následující polož\-ku seznamu\newline 
\phantom{---}položka previous -- číslo řádku tabulky obsahující 
předcházející položku seznamu.

Pro\-to\-že ve\-li\-kost ta\-bul\-ky o\-me\-zu\-je ve\-li\-kost re\-pre\-zen\-to\-va\-né mno\-ži\-ny, mů\-že na\-stat pře\-pl\-ně\-ní. O řešení 
případného přeplnění pojednáme později na str. 29. Stejný způsob řešení přeplnění se používá i v dalších metodách, kde velikost tabulky omezuje velikost reprezentované množiny.

Příklad: $U=\{1,2,\dots,1000\}$, $h(x)=x\bmod10$,\newline 
uložená množina $S=\{1,7,11,53,73,141,161\}$,\newline 
řetězce: $P(1)=(1,141,11,161)$, 
$P(3)=(73,53)$, $P(7)=(7)$.\newline 
Hašovací tabulka:
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & previous\hfil \cr\noalign{\hrule}P(0) & & & \hfill \cr\noalign{\hrule}P(1) & 1 & 9 & \hfill \cr\noalign{\hrule}P(2) & & & \hfill \cr\noalign{\hrule}P(3) & 73 & 6 & \hfill \cr\noalign{\hrule}P(4) & & &\hfill \cr\noalign{\hrule}P(5) & 161 & & 8 \cr\noalign{\hrule}P(6) & 53 & & 3 \cr\noalign{\hrule}P(7) & 7 & &\hfill \cr\noalign{\hrule}P(8) & 11 & 5 & 9 \cr\noalign{\hrule}P(9) & 141 & 8 & 1 \cr\noalign{\hrule}}}$$

Tabulka vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(141)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$},\newline 
{\bf INSERT$(7)$}, {\bf INSERT$(161)$}. 

\subsubsection{Algoritmy}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.previous\ne$prázdné nebo $i.key=$prázdné {\bf then Výstup}: $
x\notin S$, stop {\bf endif \newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif

DELETE$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.previous\ne$prázdné nebo $i.key=$prázdné {\bf then} stop {\bf endif\newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then}\newline  
\phantom{---}{\bf if} $i.previous\ne$prázdné {\bf then}\newline 
\phantom{------}$(i.previous).next:=i.next$\newline 
\phantom{------}{\bf if} $i.next\ne$prázdné {\bf then} $(i.n
ext).previous:=i.previous$ {\bf endif}\newline 
\phantom{------}$i.key:=i.next:=i.previous:=$ prázdné \newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $i.next\ne$prázdné {\bf then}\newline 
\phantom{---------}$i.key:=(i.next).key$, $i.next:=(i.next).next$\newline 
\phantom{---------}{\bf if} $((i.next).next)\ne$prázdné {\bf then} $
((i.next).next).previous:=i$ {\bf endif}\newline 
\phantom{---------}$(i.next).key:=(i.next).next:=(i.next).previous:=$ prázdné \newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$i.key:=$ prázdné \newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline
{\bf if} $i.key=NIL$ {\bf then} $i.key:=x$, stop {\bf endif}\newline 
{\bf if} $i.previous\ne NIL${\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nechť $j$ je volný řádek tabulky\newline 
\phantom{------}$j.key:=i.key$, $j.previous:=i.previous$, $j.next:=i.next$, $(j.previous).next:=j$\newline 
\phantom{------}{\bf if} $j.next\ne NIL$ {\bf then} $(j.next).previous:=j$ {\bf endif}\newline 
\phantom{---------}$i,key:=x$, $i.next:=i.previous:=$prázdné\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo}\newline 
\phantom{---}{\bf if} $i.key\ne x$ {\bf then}\newline 
\phantom{------}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{---------}{\bf Výstup}: přeplnění\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}nechť $j$ je volný řádek tabulky\newline 
\phantom{---------}$i.next:=j$, $j.key:=x$, $j.previous:=i$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline
endif}


V příkladu provedeme {\bf INSERT$(28)$}, nový řádek je 4. řádek\newline 
-- výsledná hašovací tabulka
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & previous\hfil \cr\noalign{\hrule}P(0) & & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 &\hfill \cr\noalign{\hrule}P(2) & & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 &\hfill \cr\noalign{\hrule}P(4) & 11 & 5 & 9 \cr\noalign{\hrule}P(5) & 161 & & 4 \cr\noalign{\hrule}P(6) & 53 & & 3 \cr\noalign{\hrule}P(7) & 7 & &\hfill \cr\noalign{\hrule}P(8) & 28 &  &\hfill  \cr\noalign{\hrule}P(9) & 141 & 4 & 1 \cr\noalign{\hrule}}}$$

Očekávaný počet testů je stejný jako pro 
hašování se se\-pa\-ro\-va\-ný\-mi řetězci:\newline 
\phantom{---}úspěšné vyhledávání: $\frac {n-1}{
2m}+1\approx 1+\frac {\alpha}2$\newline 
\phantom{---}neúspěšné vyhledávání: $(1-\frac 1
m)^n+\frac nm\approx e^{-\alpha}+\alpha$,\newline 
kde $m=$ velikost tabulky, $n=$ velikost $S$, tj. počet uložených 
prvků, $\alpha =\frac nm=$ faktor zaplnění.

\subsection{Hašování s~dvěma ukazateli}

Nevýhodou hašování s~přemísťováním je v operaci 
{\bf INSERT} případ, že $previous$ $h(i)$-tého řádku je neprázdný. Pak přemísťujeme položku na $h(i)$-tém řádku na volný řádek a to vyžaduje více času -- operace s~přemístěním 
položky. Toto odstraňuje další implementace hašování se 
separujícími řetězci.

Položky pro práci s~tabulkou -- next, 
begin\newline 
\phantom{---}Položka next -- číslo řádku tabulky obsahující 
následující polož\-ku seznamu\newline 
\phantom{---}Položka begin -- číslo řádku tabulky obsahující první položku seznamu 
s touto adresou\newline 

Stejná data jako v minulém případě\newline 

Hašovací tabulka:
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & begin \hfil \cr\noalign{\hrule}P(0) & & & \hfill \cr\noalign{\hrule}P(1) & 1 & 9 & 1 \cr\noalign{\hrule}P(2) & & & \hfill \cr\noalign{\hrule}P(3) & 73 & 7 & 3 \cr\noalign{\hrule}P(4) & & &\hfill \cr\noalign{\hrule}P(5) & 161 & & \hfill \cr\noalign{\hrule}P(6) & 7 & & \hfill \cr\noalign{\hrule}P(7) & 53 & & 6 \cr\noalign{\hrule}P(8) & 11 & 5 & \hfill \cr\noalign{\hrule}P(9) & 141 & 8 & \hfill \cr\noalign{\hrule}}}$$

Tabulka vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(141)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(7)$}, {\bf INSERT$(161)$}. 

\subsubsection{Algoritmy}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.begin=$prázdné {\bf then Výstup}: $x\notin S$, stop {\bf else} $i:=i.begin$ {\bf endif\newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif


DELETE$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.begin=$prázdné {\bf then} stop {\bf else} $j:=i$, $
i:=i.begin$ {\bf endif\newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $j:=i$, $i:
=i.next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then\newline 
\phantom{{\rm ---}}if} $i=j.begin$ {\bf then\newline 
\phantom{{\rm ------}}if} $i.next\ne$prázdné {\bf then\newline 
\phantom{{\rm ---------}}$j.begin:=i.next$\newline 
\phantom{{\rm ------}}else\newline 
\phantom{{\rm ---------}}$j.begin:=$}prázdné\newline 
\phantom{------}{\bf endif\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}$j.next:=i.next$\newline 
\phantom{{\rm ---}}endif\newline 
\phantom{{\rm ---}}$i.key:=i.next:=$}prázdné\newline 
{\bf endif


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.begin=$prázdné {\bf then}\newline 
\phantom{---}{\bf if} $i.key=$prázdné {\bf then}\newline 
\phantom{------}$i.key:=x$, $i.begin:=i$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{---------}{\bf Výstup}: přeplnění\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}nechť $j$ je volný řádek tabulky\newline 
\phantom{---------}$j.key=x$, $i.begin:=j$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}$i:=i.begin$\newline
\phantom{---}{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo}\newline 
\phantom{---}{\bf if} $i.key\ne x$ {\bf then}\newline 
\phantom{------}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{---------}{\bf Výstup}: přeplnění\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}nechť $j$ je volný řádek tabulky\newline 
\phantom{---------}$i.next:=j$, $j.key:=x$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}


V příkladu provedeme {\bf INSERT$(28)$}, nový řádek je 4. 
řádek\newline 
-- výsledná hašovací tabulka
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & begin\hfil \cr\noalign{\hrule}P(0) & & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 & 1 \cr\noalign{\hrule}P(2) & & &\hfill \cr\noalign{\hrule}P(3) & 73 & 7 & 3 \cr\noalign{\hrule}P(4) & 28 &  &\hfill \cr\noalign{\hrule}P(5) & 161 & & \hfill \cr\noalign{\hrule}P(6) & 7 & &\hfill \cr\noalign{\hrule}P(7) & 53 & & 6 \cr\noalign{\hrule}P(8) & 11 & 5 & 4  \cr\noalign{\hrule}P(9) & 141 & 8 & \hfill \cr\noalign{\hrule}}}$$

Algoritmus při práci s~položkami je rychlejší než při 
hašování s~přemísťováním, ale začátek řetězce v 
jiném místě tabulky přidává jeden test. Výsledek bez 
odvozování:\newline 
Očekávaný počet testů:\newline 
\phantom{---}úspěšný případ: $1+\frac {(n-1)(n-2
)}{6m^2}+\frac {n-1}{2m}\approx 1+\frac {\alpha^2}6+\frac {\alpha}
2$\newline 
\phantom{---}neúspěšný případ: $\approx 1+\frac {
\alpha^2}2+\alpha +e^{-\alpha}(2+\alpha )-2$.

\subsection{Srůstající hašování}

Srůstající hašování se dělí podle práce s~pamětí na standardní a na srůstající hašování 
s pomocnou pamětí (které se nazývá jen 
srůstající hašování) a podle způsobu 
přidávání dalšího prvku.

Popíšeme metody:\newline 
\phantom{---}Standardní srůstající hašování: LISCH, EISCH,\newline 
\phantom{---}Srůstající hašování: LICH, VICH, EICH.

Všechny metody pro práci s~tabulkou používají jen 
položku next -- číslo řádku tabulky obsahující 
následující položku seznamu. 

Základní idea: řetězec začíná na svém místě, ale 
pokud už tam byl uložen 
nějaký údaj, pak řetězec tohoto údaje sroste s~řetězcem 
začínajícím na tomto řádku. To znamená, že prvky řetězce, který začíná na tomto místě, budou uloženy v řetězci, který už je uložen na tomto místě, ale jen od tohoto místa dál.

\subsubsection{Metody EISCH a LISCH}

\phantom{---}EISCH -- early-insertion standard coalesced hashing\newline 
\phantom{---}LISCH -- late-insertion standard coalesced hashing.
 

Organizace tabulky je stejná jako v předchozích 
případech.\newline 
Základní ideje: LISCH přidává nový prvek na konec 
řetězce, \newline 
EISCH přidává nový prvek $x$ do řetězce na 
řádek $h(x)$ (pokud je prázdný) nebo hned za prvek na řádku $h(x)$\newline 

Příklad: $U=\{1,2,\dots,1000\}$, $h(x)=x\bmod10$\newline 
množina $S=\{1,7,11,53,73,141,171\}$ je uložena 
v hašovací tabulce
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 \cr\noalign{\hrule}P(4) &  &\hfill \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & 53 &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7  \cr\noalign{\hrule}P(9) & 141 & 8 \cr\noalign{\hrule}}}$$

Tabulka pro metodu LISCH vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(141)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$},\newline 
{\bf INSERT$(161)$}, {\bf INSERT$(7)$}.\newline 
Pro metodu EISCH tabulka vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(161)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(7)$}, {\bf INSERT$(141)$}. 

Provedeme {\bf INSERT$(28)$}, přidáváme do čvrtého rádku, vý\-sled\-ná tabulka vlevo je pro meto\-du 
LISCH, vpravo pro metodu EISCH.
$$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key & next \hfil\cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 \cr\noalign{\hrule}P(4) & 28 &\hfill \cr\noalign{\hrule}P(5) & 7 & 4 \cr\noalign{\hrule}P(6) & 53 &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7 \cr\noalign{\hrule}P(9) & 141 & 8 \cr\noalign{\hrule}}}\qquad\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 \cr\noalign{\hrule}P(4) & 28 & 7 \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & 53 & \hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 4  \cr\noalign{\hrule}P(9) & 141 & 8 \cr\noalign{\hrule}}}}}$$

\subsubsection{Algoritmy}

Algoritmus operace {\bf MEMBER} je pro obě metody stejný.


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif}


Metoda LISCH -- {\bf INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo \newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nechť $j$ je prázdný řádek $j.
key:=x$, 
$i.next:=j$\newline 
\phantom{---}{\bf endif\newline 
endif}


Metoda EISCH -- {\bf INSERT$(x)$}\newline 
Spočítáme $k:=i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo \newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nechť $j$ je volný řádek tabulky\newline 
\phantom{------}$j.next:=k.next$, $k.next:=j$, $j.key:=x$\newline 
\phantom{---}{\bf endif\newline 
endif}


Efektivní operace {\bf DELETE}  není známá, ale i primitivní 
algoritmy pro operaci {\bf DELETE} mají rozumnou očekávanou 
časovou složitost.

\subsubsection{Analýza složitosti těchto algoritmů}

Popis situace: Uložena množina 
$S=\{s_1,s_2,\dots,s_n\}$ do ta\-bulky velikosti $m$, je dán 
prvek $s_{n+1}$ a máme zjistit, zda $s_{n+1}\in S$. Označme 
$a_i=h(s_i)$ pro $i=1,2,\dots,n+1$, kde $h$ je použitá hašovací 
funkce.\newline 
Předpoklad: všechny posloupnosti $a_1,a_2,\dots,a_{n+1}$ jsou 
{\bf stejně pravděpodobné}. Výběr prázdného řádku je 
pevně daný, to znamená, že při stejně obsazených 
řadcích dostaneme vždy stejný prázdný řádek.  

\subsubsection{Neúspěšné vyhledávání ($s_{n+1}\notin S$) }

Označení: $C(a_1,a_2,\dots,a_n;a_{n+1})$ označuje počet 
testů pro zjiš\-tění, že $s_{n+1}\notin S$. Platí: 
očekávaný počet testů při 
neúspěšném vy\-hledávání v množině $S$ je 
$$\frac {\sum C(a_1,a_2,\dots,a_n;a_{n+1})}{m^{n+1}},$$
kde se sčítá přes všechny posloupnosti $a_1,a_2,\dots
,a_{n+1}$ -- 
a těch je $m^{n+1}$. \newline 
Řetězec délky $l$ v množině $S$ je maximální posloupnost 
adres $(b_1,b_2,\dots,b_l)$ taková, že $b_i.next=b_{i+1}$ pro 
$i=1,2,\dots,l-1$.
Když adresa $a_{n+1}$ je $i$-tý prvek v řetězci, pak počet 
testů je $l-i+1$. Řetězec délky $l$ přispěl k součtu 
$\sum C(a_1,a_2,\dots,a_n;a_{n+1})$ počtem testů $1+2+\dots+l=l+\binom l2$. 

$c_n(l)=$ počet všech řetězců délky $
l$ ve všech 
reprezentacích $n$-prvkových množin (ztotožňuje\-me dvě 
množiny, které měly stej\-nou posloupnost adres při 
ukládaní prvků), pak 
\begin{align*}\sum C(a_1,a_2,&\dots,a_n;a_{n+1})=c_n(0)+\sum_{l=1}^n(l+\binom 
l2)c_n(l)\\
&=c_n(0)+\sum_{l=1}^nlc_n(l)+\sum_{l=1}^n\binom l2c_n(l),\end{align*}
kde $c_n(0)$ je počet prázdných řádků ve všech 
reprezentacích. \newline 
Reprezentace $S$ má $m-n$ prázdných řádků,\newline 
všech posloupností $n$-adres je $m^n$, proto 
$$c_n(0)=(m-n)m^n.$$
$\sum_{l=1}^nlc_n(l)$ je celková délka všech řetězců ve 
všech tabulkách reprezentujících všechny $n$-prvkové 
množiny, a proto 
$$\sum_{l=1}^nlc_n(l)=nm^n.$$
Spočítáme $S_n=\sum_{l=1}^n\binom l2c_n(l)$.  Nejprve rekurentní vztah 
pro $c_n(l)$.  Přidáváme prvek s~adresou $a_{n+1}$.  Pak řetězec 
délky $l$ v reprezentaci $S$ zůstal stejný, když 
adresa $a_{n+1}$ neležela v tomto řetězci, v opačném případě 
se délka řetězce zvětšila na $l+1$.  Proto přidání jednoho 
prvku vytvořilo z řetězce délky $l$ celkem $m-l$ 
řetězců délky $l$ a $l$ řetězců délky $
l+1$.  
Vysčítáním přes všechny $n$-prvkové posloupnosti adres 
dostáváme 
$$c_{n+1}(l)=(m-l)c_n(l)+(l-1)c_n(l-1).$$

Odtud
\begin{align*} S_n=&\sum_{l=1}^n\binom l2c_n(l)=\\
&\sum_{l=1}^n\big(\binom l2(m-l)c_{n-1}(l)+\binom l2(l-1)c_{n-1}(
l-1)\big)=\\
&\big(\sum_{l=1}^n\binom l2(m-l)c_{n-1}(l)\big)+\big(\sum_{l=0}^{
n-1}\binom {l+1}2lc_{n-1}(l)\big)=\\
&\binom n2(m-n)c_{n-1}(n)+\\
&\big(\sum_{l=1}^{n-1}(\binom l2(m-l)+\binom {l+1}2l)c_{n-1}(l)\big
)+\binom 120c_{n-1}(0)=\\
&\sum_{l=1}^{n-1}\binom l2(m+2)c_{n-1}(l)+\sum_{l=1}^{n-1}lc_{n-1}
(l)=\\
&(m+2)S_{n-1}+(n-1)m^{n-1},\end{align*}
kde jsme použili, že $c_{n-1}(n)=0$, a identitu
\begin{align*}(m-l)\binom l2+l\binom {l+1}2=&\frac 12(l^2m-lm-l^3+l^2+l^
3+l^2)=\\
&\frac 12(l^2m-lm+2l^2)=\\
&\frac 12(l^2m-lm+2(l^2-l))+l=\\
&(m+2)\binom l2+l.\end{align*}

Rekurence pro $S_n$ dává 
\begin{align*} S_n=&(m+2)S_{n-1}+(n-1)m^{n-1}=\\
&(m+2)^2S_{n-2}+(m+2)(n-2)m^{n-2}+(n-1)m^{n-1}=\\
&(m+2)^3S_{n-3}+(m+2)^2(n-3)m^{n-3}+\\
&(m+2)(n-2)m^{n-2}+(n-1)m^{n-1}=\\
&(m+2)^{n-1}S_0+\sum_{i=0}^{n-1}(m+2)^i(n-1-i)m^{n-1-i}=\\
&(m+2)^{n-1}\sum_{i=0}^{n-1}(n-1-i)\big(\frac m{m+2}\big)^{n-1-i}
=\\
&(m+2)^{n-1}\sum_{i=1}^{n-1}i\big(\frac m{m+2}\big)^i,\end{align*}
kde jsme využili, že $S_0=0$. Spočítáme součet 
$T_c^n=\sum_{i=1}^nic^i$ pro $n=1,2,\dots$ a $c\ne 1$. Z
$cT_c^n=\sum_{i=1}^nic^{i+1}$ plyne 
\begin{align*}(c-1)T_c^n=&cT_c^n-T_c^n=\sum_{i=2}^{n+1}(i-1)c^i-\sum_{i
=1}^nic^i=\\
&nc^{n+1}+\big(\sum_{i=2}^n((i-1)c^i-ic^i)\big)-c=\\
&nc^{n+1}+\big(\sum_{i=2}^n-c^i\big)-c=\\
&nc^{n+1}-\sum_{i=1}^nc^i=nc^{n+1}-\frac {c^{n+1}-c}{c-1}=\\
&\frac {nc^{n+2}-(n+1)c^{n+1}+c}{c-1}.\end{align*}

Tedy platí 
$$T_c^n=\frac {nc^{n+2}-(n+1)c^{n+1}+c}{(c-1)^2}.$$
Protože $\frac m{m+2}\ne 1$, dostáváme, že 
\begin{align*} S_n=&(m+2)^{n-1}\frac {(n-1)\big(\frac m{m+2}\big)^{n+1}
-n\big(\frac m{m+2}\big)^n+\frac m{m+2}}{\big(\frac m{m+2}-1\big)^
2}=\\
&\frac 14(m+2)^{n+1}\big[(n-1)\big(\frac m{m+2}\big)^{n+1}-n\big(\frac 
m{m+2}\big)^n+\frac m{m+2}\big]=\\
&\frac 14\big[(n-1)m^{n+1}-n(m+2)m^n+m(m+2)^n\big]=\\
&\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big).\end{align*}
Očekávaný počet testů při neúspěšném 
vyhledávání je  
\begin{align*}&\frac {(m-n)m^n+nm^n+\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big
)}{m^{n+1}}=\\
&\frac {m^{n+1}+\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big)}{m^{n+1}}
=\\
&1+\frac 14\big((1+\frac 2m)^n-1-\frac {2n}m\big)\sim 1+\frac 14(
e^{2\alpha}-1-2\alpha ).\end{align*}
Tento odhad je stejný pro obě metody -- LISCH i EISCH, 
protože mají stejné posloupnosti adres (liší se jen pořadím 
prvků v jednotlivých řetězcích).

\subsubsection{Úspěšný případ ($s_{n+1}\in S$)}

Očekávaný počet testů při úspěšném 
vyhledávání v modelu LISCH spočítáme stejnou meto\-dou jako 
pro hašování se separujícími řetězci.  Pro vyhledání prvku 
$s_{n+1}\in S$ je počet testů roven $1+$počet porovnání 
klíčů při operaci {\bf INSERT$(s_{n+1})$.}  Když $
s_{n+1}$ je vložen 
na místo $h(s_{n+1})$, nebyl porovnáván žádný klíč a test bude $
1$, 
když $h(s_{n+1})$ byl na na $i$-tém místě v řetězci délky $
l$, pak bylo 
při operaci {\bf INSERT$(s_{n+1})$} použito $l-i+1$ porovnání klíčů 
a teď se použije $l-i+2$ testů. Podle předchozí části analýzy dostaneme, že očekávaný počet 
porovnání klíčů při neúspěšném vyhledávání je 
\begin{align*}&\frac 1{m^{n+1}}(\sum_{l=1}^n(l+\binom l2)c_n(l))=\\
&\frac 1{m^{n+1}}(nm^n+\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big))=\\
&\frac 14\big((1+\frac 2m)^n-1+\frac {2n}m\big).\end{align*}
Tedy očekávaný počet testů při úspěšném 
vy\-hledávání v $n$-prvkové množině je podle 
před\-cho\-zí analýzy 
roven $1+n$-tina součtu očekávaného počtu porovnání 
klíčů při neúspěšném vy\-hledávání v $
i$-prvkové 
množině, kde $i$ probíhá čísla $0,1,\dots,n-1$.  Podle předchozích 
výsledků je hledaný součet 
\begin{align*}\sum_{i=0}^{n-1}\frac 14\big[(1+\frac 2m)^i-&1+\frac {2i}
m\big]=\frac 14\frac {(1+\frac 2m)^n-1}{1+\frac 2m-1}-\frac n4+\frac {\binom 
n2}{2m}=\\
&\frac m8\big((1+\frac 2m)^n-1-\frac {2n}m\big)+\frac {n^2-n}{4m}
.\end{align*}
Tedy očekávaný počet testů v úspěšném 
případě pro $n$-prvko\-vou množinu je 
$$1+\frac m{8n}\big((1+\frac 2m)^n-1-\frac {2n}m\big)+\frac {n-1}{
4m}\sim 1+\frac 1{8\alpha}(e^{2\alpha}-1-2\alpha )+\frac {\alpha}
4.$$
Pro metodu EISCH je očekáváný počet testů v 
úspěšném přípa\-dě 
$$\frac mn\big((1+\frac 1m)^n-1\big)\sim\frac 1{\alpha}(e^{\alpha}
-1).$$
Výpočet je ale komplikovanější, musí se použít složitější metoda (metoda EISCH dává nový prvek hned za místo, kde má být uložen). Chyba aproximace 
pro tyto odhady je $O(\frac 1m)$. 

\subsubsection{Metody LICH, EICH, VICH}

\phantom{---}LICH -- late-insertion coalesced hashing\newline 
\phantom{---}EICH -- early-insertion coalesced hashing\newline 
\phantom{---}VICH -- varied-insertion coalesced hashing.

Základní idea: Metody používají pomocnou paměť. 
Tabulka je rozdělená na adresovací část a na pomocnou 
paměť, která není dostupná pomocí hašovací funkce, 
ale pomáhá při řešení kolizí. Metody se liší operací 
{\bf INSERT}. Všechny metody při kolizi nejprve použijí řádek 
tabulky z pomocné části a teprve, když je pomocná část 
zaplněna, používají adresovací část.\newline 
Metoda LICH: při {\bf INSERT}u vkládá prvek vždy na konec 
ře\-těz\-ce.\newline 
Metoda EICH: při {\bf INSERT}u vkládá prvek $x$ do řetězce vždy 
na místo hned za řádkem $h(x)$.\newline 
Metoda VICH: Při {\bf INSERT}u, když nový řádek je z 
pomocné části, tak je vložen s~novým prvkem na konec 
řetězce, když je pomocná část paměti vyčer\-pá\-na, tak se 
řádek s~novým prvkem vkládá do řetězce za posled\-ní 
řádek z pomocné části tabulky. Když řetězec neobsahuje 
žádný řádek z pomocné paměti, tak se řádek s~novým  prvkem $
x$ vkládá hned za řádek $h(x)$. 

Idea: pomocná část má zabránit rychlému 
srůstání řetězců.

Tyto metody nepodporují přirozené efektivní algoritmy 
pro ope\-raci {\bf DELETE}.

Příklad: $U=\{1,2,\dots,1000\}$, $h(x)=x\bmod10$,\newline 
$S=\{1,7,11,53,73,141,161\}$. Tabulka má 12 řádků a 
má tvar
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 10 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) &  &\hfill \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7 \cr\noalign{\hrule}P(9) & &\hfill \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 8 \cr\noalign{\hrule}P(11) & 53 & \cr\noalign{\hrule}}}$$

Hašovací tabulka vznikla posloupnostmi operací:\newline 
Pro metodu LICH:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(141)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(11)$},\newline 
{\bf INSERT$(161)$}, {\bf INSERT$(7)$}.\newline 
Pro metodu EICH:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(161)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(11)$},\newline 
{\bf INSERT$(141)$}, {\bf INSERT$(7)$},

ale nedodržovalo se, že se nejdřív zaplňují řádky z 
pomocné části.  Při dodržování tohoto pravidla takováto tabulka 
nemůže vznik\-nout.\newline 
Pro metodu VICH:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(141)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(161)$},\newline 
{\bf INSERT$(11)$}, {\bf INSERT$(7)$}. 

Aplikujeme operace {\bf INSERT$(28)$} a {\bf INSERT$(31
)$}, nové řád\-ky 
budou řádky číslo 4 a 9. Tabulka vytvořená pomocí 
metody LICH je na levé straně, metodou VICH je v 
prostředku a metodou EICH je na pravé straně.

$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\hfil # \hfil\vrule\cr\noalign{\hrule}řádek & key & next \hfil\cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 10 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) & 28 & 9 \cr\noalign{\hrule}P(5) & 7 & 4 \cr\noalign{\hrule}P(6) &  &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7 \cr\noalign{\hrule}P(9) & 31 &\hfill \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 8 \cr\noalign{\hrule}P(11) & 53 & \hfill \cr\noalign{\hrule}}}\,\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key & next \hfil\cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 10 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) & 28 & 7 \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) &  &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 4 \cr\noalign{\hrule}P(9) & 31 & 8 \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 9 \cr\noalign{\hrule}P(11) & 53 & \hfill \cr\noalign{\hrule}}}\,\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) & 28 & 7 \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & & \hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 4  \cr\noalign{\hrule}P(9) & 31 & 10 \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 8 \cr\noalign{\hrule}P(11) & 53 & \hfill \cr\noalign{\hrule}}}}}$

\subsubsection{Algoritmy}

Algoritmus operace {\bf MEMBER} je pro tyto metody 
stejný jako pro LISCH a EISCH


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif
}
Algoritmus operace {\bf INSERT} je pro metodu LICH stejný 
jako pro metodu LISCH a pro metodu EICH je stejný jako 
pro metodu EISCH s~jediným doplňkem, pokud existuje 
prázdný řádek v pomocné části, tak $j$-tý řádek je z 
pomocné části. Tento předpoklad je i pro algoritmus 
{\bf INSERT} pro metodu VICH.


Metoda LICH -- {\bf INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.next=NIL$ {\bf then} $i.next=x$, stop {\bf endif\newline 
while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo\newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nechť $j$ je prázdný řádek, $j
.key:=x$, $i.next:=j$\newline 
\phantom{---}{\bf endif\newline 
endif}


Metoda EICH -- {\bf Insert$(x)$}\newline 
Spočítáme $k:=i:=h(x)$\newline 
{\bf if} $i.next=NIL$ {\bf then} $i.next=x$, stop {\bf endif\newline 
while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo\newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nechť $j$ je volný řádek tabulky\newline 
\phantom{------}$j.next:=k.next$, $k.next:=j$, $j.key:=x$\newline 
\phantom{---}{\bf endif\newline 
endif}


Metoda VICH -- {\bf INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.next=NIL$ {\bf then} $i.next=x$, stop {\bf endif\newline 
while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do}\newline 
\phantom{---}{\bf if} $k$ není definováno a $i.next<m$ {\bf then} $k:=i$ {\bf endif\newline 
Poznámka}: Podmínka pro $k$ je splněna, když jsme byli na 
začátku nebo v pomocné části, podmínka na $i.next$ je 
splněna, když $i.next$ není v pomocné části.\newline 
\phantom{---}$i:=i.next$\newline 
{\bf enddo\newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nechť $j$ je volný řádek, $j.key:=x$\newline 
\phantom{------}{\bf if} $k$ není definováno {\bf then}\newline 
\phantom{---------}$i.next:=j$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$j.next:=k.next$, $k.next:=j$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}


Složitost algoritmů pro srůstající hašování.\newline 
Značení: $n$ -- velikost uložené množiny,\newline 
$m$ -- velikost adresovací části tabulky,\newline 
$m'$ -- velikost tabulky,\newline 
$\alpha =\frac n{m'}$ -- faktor zaplnění,\newline 
$\beta =\frac m{m'}$ -- adresovací faktor,\newline 
$\lambda$ -- jediné nezáporné řešení rovnice $e^{
-\lambda}+\lambda =\frac 1{\beta}$.

Očekávaný počet testů pro metodu LICH\newline 
neúspěšný případ:\newline 
\phantom{---}$e^{-\frac {\alpha}{\beta}}+\frac {\alpha}{\beta}$, když  $
\alpha\le\lambda\beta$, \newline 
\phantom{---}$\frac 1{\beta}+\frac 14(e^{2(\frac {\alpha}{\beta}-
\lambda )}-1)(3-\frac 2{\beta}+2\lambda )-\frac 12(\frac {\alpha}{
\beta}-\lambda )$, když $\alpha\ge\lambda\beta$\newline 
úspěšný případ:\newline 
\phantom{---}$1+\frac {\alpha}{2\beta}$, když $\alpha\le\lambda
\beta$, \newline 
\phantom{---}$1+\frac {\beta}{8\alpha}(e^{2(\frac {\alpha}{\beta}
-\lambda )}-1-2(\frac {\alpha}{\beta}-\lambda ))(3-\frac 2{\beta}
+2\lambda )+\frac 14(\frac {\alpha}{\beta}+\lambda )+\frac {\lambda}
4(1-\frac {\lambda\beta}{\alpha})$, 
když $\alpha\ge\lambda\beta$.

Očekávaný počet testů pro metodu EICH\newline 
neúspěšný případ:\newline 
\phantom{---}$e^{-\frac {\alpha}{\beta}}+\frac {\alpha}{\beta}$, když  $
\alpha\le\lambda\beta$, \newline 
\phantom{---}$e^{2(\frac {\alpha}{\beta}-\lambda )}(\frac 34+\frac {
\lambda}2-\frac 1{2\beta})+e^{\frac {\alpha}{\beta}-\lambda}(\frac 
1{\beta}-1)+(\frac 14-\frac {\alpha}{2\beta}+\frac 1{2\beta})$, když $
\alpha\ge\lambda\beta$\newline 
úspěšný případ:\newline 
\phantom{---}$1+\frac {\alpha}{2\beta}$, když $\alpha\le\lambda
\beta$, \newline 
\phantom{---}$1+\frac {\alpha}{2\beta}+\frac {\beta}{\alpha}((e^{\frac {
\alpha}{\beta}-\lambda}-1)(1+\lambda )-(\frac {\alpha}{\beta}-\lambda 
))(1+\frac {\lambda}2+\frac {\alpha}{2\beta}))$, když $\alpha\ge
\lambda\beta$.

Očekávaný počet testů pro metodu VICH\newline 
neúspěšný případ:\newline 
\phantom{---}$e^{-\frac {\alpha}{\beta}}+\frac {\alpha}{\beta}$, když  $
\alpha\le\lambda\beta$, \newline 
\phantom{---}$\frac 1{\beta}+\frac 14(e^{2(\frac {\alpha}{\beta}-
\lambda )}-1)(3-\frac 2{\beta}+2\lambda )-\frac 12(\frac {\alpha}{
\beta}-\lambda )$, když $\alpha\ge\lambda\beta$\newline 
úspěšný případ:\newline 
\phantom{---}$1+\frac {\alpha}{2\beta}$, když $\alpha\le\lambda
\beta$, \newline 
\phantom{---}$1+\frac {\alpha}{2\beta}+\frac {\beta}{\alpha}((e^{\frac {
\alpha}{\beta}-\lambda}-1)(1+\lambda )-(\frac {\alpha}{\beta}-\lambda 
))(1+\frac {\lambda}2+\frac {\alpha}{2\beta}))+\frac {1-\beta}{\alpha}
(\frac {\alpha}{\beta}-\lambda -e^{\frac {\alpha}{\beta}-\lambda}
+1)$, 
když $\alpha\ge\lambda\beta$.

Chyba aproximace pro tyto odhady je $O(\log\frac {m'}{\sqrt {
m'}})$.

\subsection{Hašování s~lineárním přidáváním}

Tabulka má jedinou položku -- key

Základní idea:  Při operaci {\bf INSERT$(x)$} vložíme $
x$ 
na řádek $h(x)$, když je prázdný, v opačném případě 
nalezneme nejmenší $i$ takové, že řádek $h(x)+i\bmod 
m$ je 
prázdný, a tam vložíme $x$. Tato metoda byla motivována snahou o co největší využití paměti. 

Komentář:  Metoda vyžaduje minimální velikost paměti.  
V tabulce se vytvářejí shluky použitých řádků, a proto 
při velkém zaplnění metoda vyžaduje velký počet testů.  
Metoda nepodporuje efektivní implementaci operace {\bf DELETE}.  
Při vy\-hle\-dá\-vá\-ní je třeba testovat, zda nevyšetřujeme 
podruhé první vyšetřovaný řádek, a pro zjištění přeplnění je 
vhodné mít uložen počet vyplněných řádků v tabulce. Pro standarní paměti není výhodná. Při použití cache-paměti se výrazně mění její hodnocení. Důvodem je, že v tomto případě hraje klíčovou roli nikoliv počet testů, ale počet přechodů mezi různými úrovněmi paměti. Protože tabulka je reprezentovaná polem, tak je tento počet menší než u jiných metod. Proto se tato metoda doporučuje pro počítače s~cache-pamětí.


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$, $h:=i$\newline 
{\bf if} $i.key=x$ {\bf then Výstup} $x\in S$, stop {\bf endif\newline 
if} $i.key=$prázdný {\bf then {{\rm Výstup}}}: $x\notin S$, stop {\bf endif\newline 
$i:=i+1$\newline 
while} $i.key\ne$prázdný a $i.key\ne x$ a $i\ne h$ {\bf do} $
i:=i+1\bmod m$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$, $j:=0$\newline 
{\bf while} $i.key\ne$prázdný a $i.key\ne x$ a $j<m$ {\bf do} $
i:=i+1\bmod m${\bf ,} $j:=j+1$ {\bf enddo\newline 
if} $j=m$ {\bf then Výstup}: přeplnění, stop {\bf endif\newline 
if} $i.key=$prázdný {\bf then} $i.key:=x$ {\bf endif}


Příklad: Máme universum $U=\{1,2,\dots,1000\}$, 
hašovací funk\-ci $h(x)=x\bmod10$ a množinu  
$S=\{1,7,11,53,73,141,161\}$. Tato množina je uložena v levé tabulce. 
Provedeme operaci {\bf INSERT$(35)$}. Výsledek je uložen v 
pravé tabulce.
$$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key \hfil\cr\noalign{\hrule}P(0) & \hfill \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & 11 \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 161 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 7 \cr\noalign{\hrule}P(8) & \hfill\cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}\qquad\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key \hfil \cr\noalign{\hrule}P(0) & \hfill \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & 11 \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 161 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 7 \cr\noalign{\hrule}P(8) & 35  \cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}}}$$

Tabulka vznikla posloupností operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(11)$}, {\bf INSERT$(73)$}, 
{\bf INSERT$(141)$}, {\bf INSERT$(161)$},\newline 
{\bf INSERT$(53)$}, {\bf INSERT$(7)$}. 

Na závěr uvedeme složitost této metody. Očekávaný 
počet testů:\newline 
\phantom{---}neúspěšný případ: $\approx\frac 12(
1+\big(\frac 1{1-\alpha}\big)^2)$, \newline 
\phantom{---}úspěšný případ: $\approx\frac 12(1+\frac 
1{1-\alpha})$.

\subsection{Dvojité hašování}

Základní nevýhoda předchozí metody je způsob 
výběru dal\-ší\-ho řádku. Je velmi determinován a 
důsledkem je vznik shluku řádků, který 
vede k výraznému zpomalení metody. \newline 
Idea jak odstranit tuto nevýhodu: Použijeme dvě 
hašovací funkce $h_1$ a $h_2$ a při operaci {\bf INSERT$
(x)$ }
nalezneme nejmenší $i=0,1,\dots$ takové, že 
$(h_1(x)+ih_2(x))\bmod m$ je prázdný řádek, a tam uložíme 
prvek $x$.\newline 
Tabulka má jedinou položku -- key.\newline 
Požadavky na korektnost: Pro každé $x$ musí být $h_
2(x)$ a 
$m$ nesoudělné (jinak prvek $x$ nemůže být uložen 
na libovolném řádku tabulky). \newline 
Předpoklad pro výpočet očekávaného počtu testů: posloupnost 
$\{h_1(x)+ih_2(x)\}_{i=0}^{m-1}$ je náhodná permutace množiny 
řádků tabulky.\newline 
Nevýhoda: Uvedená metoda nepodporuje operaci {\bf DELETE}. \newline 
Poznámka: Metoda hašování s~lineárním přidáváním je 
speciál\-ní případ dvojitého hašování, kde $
h_2(x)=1$ pro 
každé $x\in U$.

\subsubsection{Algoritmy}


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h_1(x)$, $h:=h_2(x)$, $j:=0$\newline 
{\bf while} $i.key\ne$prázdný a $i.key\ne x$ a $j<m$ {\bf do} $
i:=i+h\bmod m$, $j:=j+1$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif


INSERT$(x)$}\newline 
Spočítáme $i:=h_1(x)$, $h:=h_2(x)$, $j:=0$\newline 
{\bf while} $i.key\ne$prázdný a $i.key\ne x$ a $j<m$ {\bf do} $
i:=i+h\bmod m$, $j:=j+1$ {\bf enddo\newline 
if} $j=m$ {\bf then Výstup}: přeplnění, stop {\bf endif\newline 
if} $i.key=$prázdný {\bf then} $i.key:=x$ {\bf endif}


Příklad: Mějme universum $U=\{1,2,\dots,1000
\}$. 
Hašovací funkce jsou 
$h_1(x)=x\bmod10$ a $h_2(x)=1+2(x\bmod4)$, když 
$x\bmod4\in \{0,1\}$, $h_2(x)=3+2(x\bmod4)$, když $x\bmod4\in 
\{2,3\}$. 
Množina je  $S=\{1,7,11,53,73,141,161\}$. Tato množina je uložena v 
levé tabulce. Aplikujme {\bf INSERT$(35)$}. Pak $h_2(35)=9$, tedy 
posloupnost pro $x=35$ je 
$$(5,4,3,2,1,0,9,8,7,6).$$
Výsledek je uložen v pravé tabulce. 
$$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key \hfil\cr\noalign{\hrule}P(0) & 11 \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & \hfill \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 7 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 161 \cr\noalign{\hrule}P(8) & \hfill\cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}\qquad\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key \hfil \cr\noalign{\hrule}P(0) & 11 \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & 35 \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 7 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 161 \cr\noalign{\hrule}P(8) & \hfill \cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}}}$$

Tabulka vznikla posloupností operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(53)$}, 
{\bf INSERT$(141)$}, {\bf INSERT$(161)$},\newline 
{\bf INSERT$(11)$}, {\bf INSERT$(7)$}. 

Analýza vyhledávání v dvojitém hašování.

\subsubsection{Neúspěšný případ}

 

Značení:  $q_i(n,m)$ -- když tabulka má $m$ řádků a 
je v ní obsazeno $n$ řádků, tak je to 
pravděpodobnost, že pro každé $j=0,1,\dots,i-1$ je 
řádek $h_1(x)+jh_2(x)$ obsazen. Pak $q_0(n,m)=1$, $q_1(n,m)=\frac 
nm$, 
$q_2(n,m)=\frac {n(n-1)}{m(m-1)}$ a obecně 
$$q_i(n,m)=\frac {\prod_{j=0}^{i-1}(n-j)}{\prod_{j=0}^{i-1}(m-j)}
.$$
$C(n,m)$ -- očekávaný počet testů v neúspěšném 
vyhledávání, když tabulka má $m$ řádků a $
n$ jich 
je obsazeno. Podle definice platí:
$$C(n,m)=\sum_{j=0}^n(j+1)(q_j(n,m)-q_{j+1}(n,m))=\sum_{j=0}^nq_j
(n,m).$$
Dále platí $C(0,m)=1$ pro každé $m$ a 
$q_j(n,m)=\frac nmq_{j-1}(n-1,m-1)$ pro všechna $j,n>0$ a $m>1$. 
Odtud
$$C(n,m)=\sum_{j=0}^nq_j(n,m)=1+\frac nm(\sum_{j=0}^{n-1}q_j(n-1,
m-1))=1+\frac nmC(n-1,m-1).$$

Indukcí ukážeme, že $C(n,m)=\frac {m+1}{m-n
+1}$. Když $n=0$, pak 
$C(0,m)=\frac {m+1}{m-0+1}=1$ a tvrzení platí. Předpokládáme, že tvrzení 
platí pro $n-1\ge 0$ a pro každé $m\ge n-1$ a dokážeme tvrzení 
pro $n$ a $m\ge n$. Platí
\begin{align*} C(n,m)=&1+\frac nmC(n-1,m-1)=\\
&1+\frac {n((m-1)+1)}{m((m-1)-(n-1)+1)}=\\
&1+\frac n{m-n+1}=\frac {m+1}{m-n+1}.\end{align*}
Očekávaný počet dotazů při neúspěšném 
vyhledávání v tabulce s~$m$ řádky, z nichž $n$ je obsazeno, 
je $\frac {m+1}{m-n+1}$.

\subsubsection{Úspěšný případ}

 

Použijeme metodu ze separujících řetězců. 
Počet dotazů při vyhledávání $x$ pro $x\in 
S$ je 
stejný jako byl počet dotazů při vkládání $
x$ do 
tabulky. Tedy očekávaný počet dotazů při 
úspěšném vyhledávání v tabulce s~$m$ řádky, z nichž $
n$ je 
obsazeno, je
\begin{align*}\frac 1n\sum_{i=0}^{n-1}C(i,m)=&\frac 1n\sum_{i=0}^{n-1}\frac {
m+1}{m-i+1}=\\
&\frac {m+1}n\big(\sum_{j=1}^{m+1}\frac 1j-\sum_{j=1}^{m-n+1}\frac 
1j\big)\approx\\
&\frac 1{\alpha}\ln(\frac {m+1}{m-n+1})\approx\frac 1{\alpha}\ln(\frac 
1{1-\alpha}).\end{align*}
Následující tabulka ukazuje tyto hodnoty v závislosti na 
velikosti $\alpha$. 
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}hodnota $\alpha$ & 0.5 & 0.7 & 0.9 & 0.95 & 0.99 & 0.999 \hfill \cr\noalign{\hrule}$\frac 1{1-\alpha}$ & 2 & 3.3 & 10 & 20 & 100 & 1000 \cr\noalign{\hrule} $\frac 1{\alpha}\ln(\frac 1{1-\alpha})$ & 1.38 & 1.70 & 2.55 & 3.15 & 4.65 & 6.9 \cr\noalign{\hrule}}}$$

\subsection{Porovnání efektivity}

Pořadí metod hašování podle očekávaného počtu 
testů:
\subsubsection{Neúspěšné vyhledávání}

\phantom{---}Hašování s~uspořádanými řetězci,\newline 
\phantom{---}Hašování s~řetězci=Hašování s~přemísťováním,\newline 
\phantom{---}Hašování s~dvěma ukazateli,\newline 
\phantom{---}VICH=LICH,\newline 
\phantom{---}EICH,\newline 
\phantom{---}LISCH=EISCH,\newline 
\phantom{---}Dvojité hašování,\newline 
\phantom{---}Hašování s~lineárním přidáváním.

\subsubsection{Úspěšné vyhledávání}

\phantom{---}Hašování s~uspořádanými řetězci=Hašování s~řetězci=Hašo\-vá\-ní s~přemísťováním,\newline 
\phantom{---}Hašování s~dvěma ukazateli,\newline 
\phantom{---}VICH,\newline 
\phantom{---}LICH,\newline 
\phantom{---}EICH,\newline 
\phantom{---}EISCH,\newline 
\phantom{---}LISCH,\newline 
\phantom{---}Dvojité hašování,\newline 
\phantom{---}Hašování s~lineárním přidáváním.

Poznámka: Metoda VICH při neúspěšném vyhledávání pro 
$\alpha <0.72$ a při úspěšném vy\-hledávání pro $
\alpha <0.92$ 
vyžaduje menší očekávaný počet testů než 
metoda s~dvěma ukazateli.

Při neúspěšném vyhledávání jsou metody VICH a LICH stejné a jsou o 8\% lepší než 
EICH a o 15\% než metody LISCH a EISCH. Při úspěšném vyhledávání 
je VICH nepatrně lepší než LICH a EICH o 3\% lepší než 
EISCH a o 7\% lepší než LISCH.

\subsubsection{Očekávaný počet testů při úplně zaplněné 
tabulce}

\phantom{---}Metoda s~přemísťováním: neúspěšné vyhledávání 1.5, úspěšné 
vyhledávání 1.4.\newline 
\phantom{---}Metoda s~dvěma ukazateli: úspěšné i neúspěšné vyhledávání  1.6.\newline 
\phantom{---}VICH: neúspěšné vyhledávání 1.79, úspěšné vyhledávání 
1.67.\newline 
\phantom{---}LICH: neúspěšné vyhledávání 1.79, úspěšné vyhledávání 
1.69.\newline 
\phantom{---}EICH: neúspěšné vyhledávání 1.93, úspěšné vyhledávání 
1.69.\newline 
\phantom{---}EISCH: neúspěšné vyhledávání 2.1, úspěšné vyhledávání 
1.72.\newline 
\phantom{---}LISCH: neúspěšné vyhledávání 2.1, úspěšné vyhledávání 
1.8.

Metodu s~lineárním přidáváním je dobré použít jen pro 
$\alpha <0.7$, metodu s~dvojitým hašováním pro $\alpha 
<0.9$, pak 
čas pro neúspěšné vyhledávání rychle narůstá.

Vliv $\beta =\frac m{m'}$ při srůstajícím hašování.\newline 
Při 
úspěšném vy\-hledávání je optimální hodnota $
\beta =0.85$, při 
neúspěšném vy\-hledávání je optimální hodnota $
\beta =0.78$. 
V praxi se doporučuje použít hodnotu $\beta =0.86$ (uvedené 
výsledky byly pro tuto hodnotu $\beta ).$

Komentář: Metody se separujícími řetězci a 
srůstající hašování používají více paměti (při 
srůstajícím hašování součet adresovací a 
pomocné části). Metoda s~přemísťováním a metoda 
dvojitého hašování vyžadují více času -- na přemístění 
prvku a na výpočet druhé hašovací funkce.

\subsection{Další otázky}

Jak nalézt volný řádek.\newline 
Za nejlepší metodu se považuje mít seznam (zásobník) 
volných řádků a z jeho vrcholu brát volný řádek 
a po úspěšné operaci {\bf DELETE} tam zase řádek vložit 
(pozor při operaci {\bf DELETE} ve strukturách, které 
nepodporují {\bf DELETE}).

Jak řešit přeplnění.\newline 
Standardní model: Dána základní velikost tabulky $m$ a 
pracuje se s~tabulkami s~$2^im$ řádky pro vhodné 
$i=0,1,\dots$. Vhodné $i$ znamená, že faktor zaplnění $
\alpha$ je v 
intervalu $<\frac 14,1>$ (s výjimkou $i=0$, kde se uvažuje 
pouze horní mez). Při překro\-če\-ní meze se zvětší nebo 
zmenší $i$ a všechna data se přehašují do nové 
tabulky.\newline 
Výhoda: Po přehašování do nové tabulky je počet operací, 
které vedou k novému přehašová\-vá\-ní, roven alespoň polovině 
velikosti uložené množiny.\newline 
Praktické použití: Nedržet se striktně mezí, používat 
malé pomocné ta\-bul\-ky při přeplnění a posunout velké 
přehašování na dobu klidu (aby systém nenechal uživatele v 
normální době čekat).

Jak řešit {\bf DELETE} v metodách, které ho 
nepodporují.\newline 
Použít ideu tzv. `falešného {\bf DELETE}'. 
Odstranit prvek, ale řádek neuvolnit (i v klíči nechat 
nějakou hodnotu, která bude znamenat, že řádek je 
prázdný, položky podporující práci s~tabulkami neměnit). 
Řádek nebude v seznamu volných řádků, ale 
operace {\bf INSERT}, když testuje tento řádek, tam 
může vložit nový prvek. Když je alespoň 
polovina použitých řádků takto blokována, je 
vhodné celou strukturu přehašovat. Prav\-děpodobnostní 
analýzu tohoto modelu neznám.

\subsubsection{Otevřené problémy}

Jak využít ideje z hašování s~uspořádanými 
řetězci pro ostatní metody řešení kolizí 
(jmeno\-vitě pro srůstající hašování).

Jakou metodu použít pro operaci {\bf DELETE} ve 
srůstajícím hašování (problém je zachovat náhodnost 
uložené množiny a tím platnost odhadu na složitost operací). 

Jak nalézt druhou hašovací funkci pro metodu 
dvojitého hašo\-vá\-ní, aby vzniklé posloupnosti adres při operaci 
{\bf INSERT} se chovaly jako náhodné.

\subsubsection{Závěr}

Připomeňme si předpoklady pro předchozí uvedené 
výsledky o hašování:
\begin{enumerate}
\item
Hašovací funkce se rychle spočítá (v čase 
$O(1)$);
\item Hašovací funkce rovnoměrně rozděluje univerzum (to 
znamená, že pro dvě různé hodnoty $i$ a $j$ 
hašovací funkce platí $-1\le |h^{-1}(i)|-|h^{-1}(j)|\le 
1$); 
\item
Vstupní data jsou rovnoměrně rozdělená.
\end{enumerate}

Diskutujme splnitelnost těchto předpokladů.\newline 
Předpoklad 1) je jasný.\newline 
Předpoklad 2) -- je výhodné, 
když rozdělení univerza hašovací funkcí kopíruje známé 
rozděle\-ní vstupních dat. Toto se použilo při návrhu 
překladače pro FORTRAN (Lum 1971). V překladači byla použita metoda separovaných řetězců a hašovací funkce, 
která preferovala obvyklé názvy identifikátorů. Výsledky byly měřeny, když se překladač FORTRANu použil pro standardní výpočet. Získané výsledky se porovnávaly s~teoretickými výpočty za našich předpokladů. V 
následující tabulce můžete porovnat výsledky 
získané teoretickými výpočty a naměřené hodnoty.
Porovnání výsledků:

$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}hodnota $\alpha$ & 0.5 & 0.6 & 0.7 & 0.8 & 0.9 \hfill \cr\noalign{\hrule}experiment & 1.19 & 1.25 & 1.28 & 1.34 & 1.38 \cr\noalign{\hrule}teorie & 1.25 & 1.30 & 1.35 & 1.40 & 1.45 \cr\noalign{\hrule}}}$$

Závěr: Podmínky 1) a 2) můžeme splnit, 
když známe rozložení vstupních dat, můžeme 
dosáhnout ještě lepších výsledků.

Nevýhoda: Rozložení vstupních dat 
nemůžeme ovlivnit a obvykle ho ani neznáme. Je 
reálné, že rozdělení vstupních dat bude nevhodné pro 
použitou hašovací funkci. Důsledek -- na počátku 
70. let se začalo ustupovat od hašování. Hledal se postup, 
který by se vyhnul uvedenému problému s~bodem 3). Nalezenému 
řešení je věnován následující text.

\subsection{Univerzální hašování}

Řešení navrhli Carter a Wegman (1977), když přišli s~metodou univerzálního hašování, která obchází poža\-davek 3).  
To vedlo k novému rozsáhlému používání hašování.  

Základní idea: Místo jedné funkce máme 
množinu $H$ funkcí z univerza do tabulky velikosti $m$ 
takových, že pro každou množinu $S\subseteq U$, $|S|\le 
m$ se 
většina funkcí chová dobře vůči $S$ (tj. hašovací funkce má jen málo kolizí v množině $S$). 
Hašovací funkci 
zvolíme náhodně z $H$ (s rovnoměrným rozdělením) a hašujeme  
pomocí takto zvo\-lené funkce. 

Modifikace ideje. Ověřování vlastností vyžaduje 
znalost velikosti množiny $H$. Rychlá vyčíslitelnost $
h(x)$ 
vyžaduje ana\-lytické zadání funkcí v $H$, ale zjištění rovnosti 
dvou analy\-ticky zadaných funkcí na univerzu $U$ je 
problematické. Řešením problému je použití indexové množiny. 
To znamená, že $H=\{h_i\mid i\in I\}$ a dvě funkce jsou různé, 
když mají různé indexy. Pak velikost systému bude 
velikost indexové množiny. Místo zvolení hašovací funkce 
budeme volit náhodně index s~rovnoměrným rozložením a když 
zvolíme index $i$, pak budeme pracovat s~hašovací funkcí $
h_i$. 
Očekávaná hodnota náhodné proměnné $f$ z množiny $
I$ do 
reálných čísel bude průměr přes $I$, tj. $\frac {
\sum_{i\in I}f(i)}{|I|}$.

Formálně: Nechť  $U$ je univerzum. Soubor  
funkcí $H=\{h_i\mid i\in I\}$ z univerza $U$ do množiny $\{
0,1,\dots,m-1\}$ se 
nazývá $c$-\emph{univerzální} ($c$ je kladné reálné číslo), 
když 
$$\forall x,y\in U,\,x\ne y\text{\rm\ platí }|\{i\in I\mid h_
i(x)=h_i(y)\}|\le\frac {c|I|}m.$$

Jako ekvivalentní definici lze použít toto tvrzení: systém funkcí $
H$ z univerza $U$ do množiny $\{0,1,\dots,m-1\}$ je $c$-univerzální,
když vybereme-li $h\in H$ s~rovnoměrným rozděle\-ním, pak pro 
každá dvě různá $x,y\in U$ platí 
$$\Prob(h(x)=h(y))\le\frac cm.$$

Problémy: existence $c$-univerzálních 
systémů, \newline 
vlastnosti $c$-univerzálních systémů (zda splňují 
požadované ide\-je).

\subsubsection{Existence univerzálních systémů}

Univerzum $U=\{0,1,\dots,N-1\}$ pro prvočíslo $N$,\newline 
$H=\{h_{a,b}\mid (a,b)\in U\times U\}$,\newline 
kde $h_{a,b}(x)=((ax+b)\bmod N)\bmod m$\newline 
(tj. indexová množina je $U\times U$ a její velikost je $
N^2$).

Výhoda: funkce z množiny $H$ umíme rychle 
vyčíslit.

Zvolme $x,y\in U$ taková, že $x\ne y$. Chceme nalézt 
$(a,b)\in U\times U$ takové, že $h_{a,b}(x)=h_{a,b}(y)$. 

Musí existovat $i\in \{0,1,\dots,m-1\}$ a 
$r,s\in \{0,1,\dots,\lceil\frac Nm\rceil -1\}$ tak, že platí
\begin{align*}(ax+b&\equiv i+rm)\bmod N\\
(ay+b&\equiv i+sm)\bmod N\end{align*}
Když $x$, $y$, $i$, $r$ a $s$ jsou konstanty a $a$ a $b$ jsou 
proměnné, je to systém lineárních rovnic v tělese 
$\mathbb Z/\bmod N$, kde $\mathbb Z$ jsou celá čísla. Matice soustavy  
$$\begin{pmatrix} x\quad 1\\
y\quad 1\end{pmatrix} $$
je regulární, protože $x\ne y$. Jelikož $\mathbb Z/\bmod N$ je těleso, tak 
 pro fixovaná $x$, $y$, $i$, $r$ a $s$ existuje právě jedno řešení této soustavy.
Pro daná $x$ a $y$, $i$ nabývá $m$ hodnot, $r$ a $s$ nabývají 
$\lceil\frac Nm\rceil$ hodnot. 

Závěr: pro každá $x,y\in U$ taková, že 
$x\ne y$, existuje $m\big(\lceil\frac Nm\rceil\big)^2$ dvojic $(a
,b)\in U\times U$ takových, že 
$h_{a,b}(x)=h_{a,b}(y)$.

\begin{veta}Množina $H$ je $c$-univerzální pro 
$$c=\frac {\big(\lceil\frac Nm\rceil\big)^2}{\big(\frac Nm\big)^2}
.$$
\end{veta}

Skutečně, pro každé $x,y\in U$, $x\ne y$, je počet 
$(a,b)\in U\times U$ takových, že $h_{a,b}(x)=h_{a,b}(y)$, nejvýše roven
$$m\big(\lceil\frac Nm\rceil\big)^2=\frac {\big(\lceil\frac Nm\rceil\big
)^2}{\big(\frac Nm\big)^2}\frac {N^2}m=\frac {\big(\lceil\frac Nm
\rceil\big)^2}{\big(\frac Nm\big)^2}\frac {|I|}m.$$

Závěr: Dokázali jsme existenci $c$-univerzálních 
systémů pro $c$ blízké $1$. Stačí si uvědomit, že  každé univerzum můžeme 
považovat za univerzum tvaru $\{0,1,\dots,N-1\}$ pro nějaké 
$N$ a že mezi čísly $N$ a $2N$ vždy existuje nějaké 
prvočíslo.

\subsubsection{Vlastnosti univerzálního hašování}

Předpoklad: $H=\{h_i\mid i\in I\}$ je $c$-univerzální systém funkcí\newline 
Označení: Pro $i\in I$ a prvky $x,y\in U$ 
označme 
$$\delta_i(x,y)=\begin{cases} 1&\quad\text{\rm\ když }x\ne y\text{\rm\ a }
h_i(x)=h_i(y),\\
0&\text{\rm\ když }x=y\text{\rm\ nebo }h_i(x)\ne h_i(y).\end{cases} $$
Pro množinu $S\subseteq U$, $x\in U$ a $i\in I$ definujme
$$\delta_i(x,S)=\sum_{y\in S}\delta_i(x,y).$$

Pro fixovanou množinu $S\subseteq U$ a pro fixované $
x\in U$ sečteme
$\delta_i(x,S)$ přes všechna $i\in I$:
\begin{align*}\sum_{i\in I}\delta_i(x,S)=&\sum_{i\in I}\sum_{y\in S}\delta_
i(x,y)=\sum_{y\in S}\sum_{i\in I}\delta_i(x,y)=\\
&\sum_{y\in S,y\ne x}|\{i\in I\mid h_i(x)=h_i(y)\}|\le\\
&\sum_{y\in S,y\ne x}c\frac {|I|}m=\begin{cases} (|S|-1)c\frac {|I|}m&\text{\rm\ když }
x\in S,\\
|S|c\frac {|I|}m&\text{\rm\ když }x\notin S.\end{cases} \end{align*}

Protože $\delta_i(x,S)$ dává odhad na velikost řetězce $
h_i(x)$ při 
repre\-zentaci množiny $S$ pomocí funkce $h_i$, dostáváme, že 
očekávaná délka řetězce pro fixovanou množinu  
$S\subseteq U$ a fixované $x\in U$ přes $i\in I$ s~rovnoměrným 
rozdělením je nejvýše
$$\frac 1{|I|}\sum_{i\in I}\delta_i(x,S)\le\begin{cases} c\frac {|S|-1}m&\text{\rm\ když }
\quad x\in S,\\
c\frac {|S|}m&\text{\rm\ když }\quad x\notin S.\end{cases} $$

\begin{veta}Očekávaný čas operací {\bf MEMBER}, {\bf INSERT }
a {\bf DE\-LETE} při $c$-univerzálním hašování je $
O(1+c\alpha )$, kde 
$\alpha$ je faktor napl\-nění (tj. $\alpha =\frac {|S|}m$).

Očekávaný čas pro pevnou posloupnost $n$ operací 
{\bf MEMBER}, {\bf INSERT} a {\bf DELETE} aplikovaných na prázdnou ta\-bulku 
pro $c$-univerzální hašování je $O((1+\frac c2\alpha 
)n)$, kde $\alpha =\frac nm$.  
\end{veta}

Význam výsledku:  Vzorec se jen o multiplikativní 
konstantu $c$ liší od vzorce pro hašování se separovanými 
řetězci.  Přitom $c$ může být jen o málo menší než $
1$ a 
ve všech známých příkla\-dech je $c\ge 1$.  Takže, co jsme 
dosáhli?  Rozdíl je v předpokla\-dech.  Zde je předpoklad 3) 
nahrazen předpokladem, že index $i\in I$ je vybrán s~rovnoměrným rozdělením, a není žádný předpoklad na vstupní 
data.  {\bf Výběr indexu} $i$ {\bf můžeme ov\-liv\-nit, ale výběr 
vstupních dat nikoliv.}  Můžeme zajistit rovno\-měr\-né 
rozdělení výběru $i$ z $I$ nebo se k tomuto rozdělení hodně 
přiblížit.  

\subsubsection{Markovova nerovnost}

Předpoklady: Je dána množina $S\subseteq U$, prvek $
x\in U$. 
Očeká\-va\-ná velikost $\delta_i(x,S)$ je $\mu$ a $t\ge 
1$.

Ukážeme pro $t>1$, že pravděpodobnost, že $
\delta_i(x,S)\ge t\mu$ 
pro $i\in I$, je menší než $\frac 1t$ (předpokladáme, že $
i$ je z $I$ vybráno s~rovnoměrným rozdělením).  

Označme $I'=\{i\in I\mid\delta_i(x,S)\ge t\mu \}$. Pak platí
$$\mu =\frac {\sum_{i\in I}\delta_i(x,S)}{|I|}>\frac {\sum_{i\in 
I'}\delta_i(x,S)}{|I|}\ge\frac {\sum_{i\in I'}t\mu}{|I|}=\frac {|
I'|}{|I|}t\mu$$

Odtud
$$|I'|<\frac {|I|}t.$$

Závěr: Pravděpodobnost, že $\delta_i(x,S)\ge 
t\mu$, je menší 
než $\frac 1t$, a odtud plyne požadované tvrzení. 

Poznámka: Toto tvrzení platí obecně a nazývá 
se Markovova nerovnost. Uvedený důkaz 
ilustruje jednoduché tvrzení pro ko\-neč\-ný případ.

\subsubsection{Problémy}

Hlavní problém: Zajištění rovnoměrného rozdělení 
výběru $i$ z $I$.

Provedení výběru: Zakódovat indexy z množiny $
I$ do 
čísel $0,1,\dots,|I|-1$. Zvolit náhodně číslo $
i$ z tohoto 
intervalu s~rovnoměrným rozdělením a pak použít 
funkci s~indexem, jehož kód je $i$. Abychom vybrali $i$, nalezneme 
nejmenší $j$ takové, že $2^j-1\ge |I|-1$. Pak čísla v 
intervalu $\{0,1,\dots,2^j-1\}$ jednoznačně korespondují s~posloupnostmi $0$ a $1$ délky $j$. Budeme vybírat náhodně 
posloupnost $0$ a $1$ délky $j$. Když takto vybraná posloupnost neodpovídá prvku z $I$, tak vygenerujeme jinou posloupnost (a tuto vynecháme). Pokud použijeme náhodný generátor $0$ a $1$, pak takto získáme náhodný prvek z $I$. Tedy k výběru náhodné funkce potřebujeme  
náhodný generátor $0$ a $1$ s~rovnoměrným rozděle\-ním.

Závada: Skutečný náhodný generátor pro 
rovnoměrné rozděle\-ní je prakticky nedosažitelný 
(některé fyzikální procesy). K dispozici je pouze 
pseudogenerátor. 

Jeho nevýhoda: Čím je $j$ větší, tím je 
posloupnost pravidelnější (tj. méně náhodná). 

Důsledky: Nalézt co nejmenší $c$-univerzální 
systémy. Nalézt dolní odhady na jejich velikost.

\subsubsection{Dolní odhady na velikost}

Předpoklady: Nechť $U$ je univerzum velikosti $N$ a nechť 
$H=\{h_i\mid i\in I\}$ je $c$-univerzální systém funkcí hašujících do tabulky velikosti 
$m$. Můžeme předpoklá\-dat, že 
$$I=\{0,1,\dots,|I|-1\}.$$

Indukcí definujme množiny $U_0,U_1,\dots$ tak, že: 
$U_0=U$.\newline 
Nechť $U_1$ je největší podmnožina $U_0$ vzhledem k počtu 
prvků taková, že $h_0(U_1)$ je jednoprvková 
množina. \newline 
Nechť $U_2$ je největší podmnožina $U_1$ vzhledem k počtu 
prvků taková, že $h_1(U_2)$ je jednoprvková 
množina. \newline 
Nechť $U_3$ je největší podmnožina $U_2$ vzhledem k počtu 
prvků taková, že $h_2(U_3)$ je jednoprvková 
množina. \newline 
Obecně, nechť $U_i$ je největší podmnožina $U_{
i-1}$ vzhledem k počtu 
prvků taková, že $h_{i-1}(U_i)$ je jednoprvková 
množina. 

Protože hašujeme do tabulky velikosti $m$, platí 
$|U_i|\ge\lceil\frac {|U_{i-1}|}m\rceil$. Protože $|U_0|=N$, dostáváme indukcí, že 
$|U_i|\ge\lceil\frac N{m^i}\rceil$ pro každé $i$. Zvolme $i=
\lceil\log_mN\rceil -1$. Pak $i$ je 
největší přirozené číslo takové, že $\frac 
N{m^i}>1$. Tedy $U_i$ má 
aspoň dva prvky, zvolme $x,y\in U_i$ taková, že $x\ne y$. Pak 
$h_j(x)=h_j(y)$ pro $j=0,1,\dots,i-1$. Tedy 
$$i\le |\{j\in I\mid h_j(x)=h_j(y)\}|\le\frac {c|I|}m.$$

\begin{veta}Když $H=\{h_i\mid i\in I\}$ je $c$-univerzální systém pro 
univerzum $U$ o velikosti $N$ hašující do tabulky s~$m$ řádky, pak 
$$|I|\ge\frac mc(\lceil\log_mN\rceil -1).$$
Posloupnosti $0$ a $1$ při náhodné volbě $i$ z $I$ musí mít 
délku alespoň $\lceil (\log m-\log c+\log\log N-\log\log m)\rceil$ (zde všechny logaritmy 
jsou o základu $2$).
\end{veta}

\subsubsection{Malý univerzální systém}

Zkonstruujeme $c$-univerzální systém takový, 
že logaritmus z velikosti jeho indexové množiny pro velká 
univerza je až na aditivní konstantu menší než 
$4(\log m+\log\log N)$, kde $N$ je velikost univerza a $m$ je počet 
řádků v tabulce.  

Nechť $p_1,p_2,\dots$ je rostoucí posloupnost všech 
prvočísel. Měj\-me velikost tabulky $m$ a univerzum $U=
\{0,1,\dots,N-1\}$ pro 
nějaké přirozené číslo $N$ (nemusí být prvočíslo). Nechť $
t$ je 
nejmenší číslo takové, že $t\ln p_t\ge m\ln N$. Definujme 
$$H_1=\{g_{c,d}(h_{\ell})\mid t<\ell\le 2t,\,c,d\in \{0,1,\dots,p_{
2t}-1\}\},$$
kde $h_{\ell}(x)=x\bmod p_{\ell}$ a 
$g_{c,d}(x)=((cx+d)\bmod p_{2t})\bmod m$.\newline 
Ukážeme, že když $m(\ln m+\ln\ln m)<N$, pak $H_1$ je $
3.25$-univerzální systém. 

Nejprve si připomeneme známou větu o velikosti prvočísel 
(zde $\ln$ je přirozený logaritmus, tj. o základu $e$).

\begin{veta}Pro každé $i=1,2,\dots$ platí $p_i>i\ln 
i$ a pro $i\ge 6$ 
platí $p_i<i(\ln i+\ln\ln i)$. \qed
\end{veta}

Tedy pro $i\ge 6$ platí $p_i<2i\ln i$.

Velikost indexové množiny $H_1$.  Indexová množina $
H_1$ je 
$$I=\{(c,d,\ell )\mid c,d\in \{0,1,\dots,p_{2t}-1,\,t<\ell\le 2t\}
.$$
  
Tedy $|I|=tp_{2t}^2$.   
Odtud plyne $|I|\le 16t^3\ln^22t$ a tedy 
$$\log(|I|)\le 4+3\log t+2\log\log t.$$
Pro dostatečně velké $t$ (takové, že $\log t\ge 2\log\log 
t$, tj. $t\ge 16$) platí, 
že $\log(|I|)\le 4+4\log t$.  Z definice $t$ plyne, 
že $t\le m\ln N$, když $\ln p_t\ge 1$ (tj.  $p_t\ge 3$).\newline 
Závěr: $\log(|I|)\le 4+4(\log m+\log\log N)$. 

\subsubsection{Univerzalita malého systému}

Zvolme různá $x$ a $y$ z univerza $U$. 
Označme
\begin{align*} G_1&=\{(c,d,\ell )\mid g_{c,d}(h_{\ell}(x))=g_{c,d}(h_{\ell}
(y)),\,h_{\ell}(x)\ne h_{\ell}(y)\},\\
G_2&=\{(c,d,\ell )\mid g_{c,d}(h_{\ell}(x))=g_{c,d}(h_{\ell}(y)),\,
h_{\ell}(x)=h_{\ell}(y)\}\end{align*}
a odhadneme velikost $G_1$ a $G_2$. 

Odhad velikosti $G_1$. Když $(c,d,\ell )\in G_1$, pak 
existují $r,s\in \{0,1,\dots,\lceil\frac {p_{2t}}m\rceil -1\}$ a $
i\in \{0,1,\dots,m-1\}$ 
taková, že 
\begin{align*}(c(x\bmod p_{\ell})+d&\equiv i+rm)\bmod p_{2t}\\
(c(y\bmod p_{\ell})+d&\equiv i+sm)\bmod p_{2t}.\end{align*}
Když $c$ a $d$ považujeme za neznámé, pak je to  
soustava lineár\-ních rovnic s~regulární maticí (protože 
$x\bmod p_{\ell}\ne y\bmod p_{\ell}$), a tedy pro každé $\ell$, $
i$, $r$ a $s$ 
existuje právě jedna taková dvojice $(c,d)$ (připomínáme, že $\mathbb Z/\bmod p_{2t}$ je těleso). Proto 
$$|G_1|\le tm(\lceil\frac {p_{2t}}m\rceil )^2\le\frac {tp_{2t}^2}
m(1+\frac m{p_{2t}})^2=\frac {|I|}m(1+\frac m{p_{2t}})^2.$$

Odhad velikosti $G_2$. Označme 
$L=\{\ell\mid t<\ell\le 2t,\,x\bmod p_{\ell}=y\bmod p_{\ell}\}$ a $
P=\prod_{\ell\in L}p_{\ell}$. 
Protože $P$ dělí $|x-y|$, dostáváme, že $P\le N$. Protože 
$p_t<p_{\ell}$ pro každé $\ell\in L$, dostáváme, že $
P>p_t^{|L|}$. Tedy 
$|L|\le\frac {\ln N}{\ln p_t}\le\frac tm$ z definice $t$. Protože $
(c,d,\ell )\in G_2$, právě 
když $\ell\in L$ a $c,d\in \{0,1,\dots,p_{2t}-1\}$, shrneme, že 
$$|G_2|\le |L|p_{2t}^2\le\frac {tp_{2t}^2}m=\frac {|I|}m.$$

Abychom odhadli $(1+\frac m{p_{2t}})^2$, ukážeme si nejdřív 
pomocné lem\-ma.

\begin{lemma}Když $t\ge 6$ a $m(\ln m+\ln\ln m)<N$, pak $m<\frac {
p_t}{\ln t}$.
\end{lemma}

\begin{proof}Předpokládejme, že tvrzení neplatí. Pak $
m\ge\frac {p_t}{\ln t}$. Z Věty o velikosti 
prvo\-čí\-sel plyne $m\ge\frac {p_t}{\ln t}>\frac {t\ln 
t}{\ln t}=t$. Když použijeme, že 
$m(\ln m+\ln\ln m)<N$, tak dostaneme, že 
$$\ln m+\ln(\ln m+\ln\ln m)<\ln N,$$
a odtud plyne, že 
$$t\ln p_t<t\ln(t(\ln t+\ln\ln t))\le m(\ln m+\ln(\ln m+\ln\ln m)
)<m\ln N$$
a to je spor s~definicí $t$. Tedy $m<\frac {p_t}{\ln t}$.
\end{proof}

Nyní zkombinujeme Větu o odhadu velikosti prvočísel, 
před\-cho\-zí Lemma a fakt, že 
$$\ln2t\ge\ln t\ge\ln\ln t\qquad\text{pro všechna }t\ge 1$$
a dostaneme, že
$$\frac m{p_{2t}}\le\frac {\frac {p_t}{\ln t}}{2t\ln2t}<\frac {t(\ln 
t+\ln\ln t)}{2t\ln t\ln2t}<\frac 1{\ln2t}(1+\frac {\ln\ln t}{\ln 
t}).$$
Je zřejmé, že tento výraz je menší než $\frac 
12$, 
a když $t$ konverguje k $+\infty$, pak tento výraz konverguje k $
0$.

Z toho plyne, že $(1+\frac m{p_{2t}})^2\le 1.5^2=2.2
5$, a tedy 
\begin{align*}|\{i\in I&\mid h_i(x)=h_i(y)\}|=|G_1|+|G_2|\le\\
&\frac {|I|}m(1+\frac m{p_{2t}})^2+\frac {|I|}m\le\frac {|I|}m(1+
2.25)=3.25\frac {|I|}m.\end{align*}

Shrnutí: Když $t\ge 6$ a $m\ln m\ln\ln m<N$, pak $
H_1$ je 
$3.25$-univerzální. Bez jakýchkoliv předpokladů lze 
ukázat, že $H_1$ je $5$-univerzální.

\subsubsection{Odhad na velikost $c$}

\begin{veta}Když $H$ je $c$-univerzální 
systém univerza $U$ o velikosti $N$ hašující do tabulky s~$
m$ řádky, 
pak $c\ge 1-\frac mN$.
\end{veta}

Nejprve dokážeme technické lemma.

\begin{lemma}Mějme reálná čísla $b_i$ pro $i=0,1
,\dots,m-1$ a 
nechť $b=\sum_{i=0}^{m-1}b_i$. Pak 
$$\sum_{i=0}^{m-1}b_i(b_i-1)\ge b(\frac bm-1).$$
\end{lemma}

\begin{proof}[Důkaz lemmatu]Z Cauchyho-Schwarzovy nerovnosti 
$$(\sum_{i=0}^{m-1}x_iy_i)^2\le (\sum_{i=0}^{m-1}x^2_i)(\sum_{i=0}^{
m-1}y_i^2)$$
plyne $(\sum_{i=0}^{m-1}b_i)^2=b^2\le m(\sum_{i=0}^{m-1}b_i^2)$, stačí položit 
$x_i=b_i$ a $y_i=1$, a tedy $\frac {b^2}m\le\sum_{i=0}^{m-1}b_i^2$. Odtud
$$\sum_{i=0}^{m-1}b_i(b_i-1)=\sum_{i=0}^{m-1}b_i^2-\sum_{i=0}^{m-
1}b_i=\sum_{i=0}^{m-1}b_i^2-b\ge\frac {b^2}m-b=b(\frac bm-1)$$
a lemma je dokázáno.
\end{proof}

\begin{proof}[Důkaz Věty]Mějme funkci $f:U\to T$, kde $U$ má 
velikost $N$ a $T$ má velikost $m$. Označme $A$ množinu 
uspořádaných dvojic $u,v\in U$ takových, že $u\ne v$ a $
f(u)=f(v)$.
Když pro $t\in T$ označíme $k_t=|f^{-1}(t)|$, pak $|A|=
\sum_{t\in T}k_t(k_t-1)$.
Z lemmatu plyne, že 
$$|A|=\sum_{t\in T}k_t(k_t-1)\ge N(\frac Nm-1)=N(\frac {N-m}m),$$
protože $\sum_{t\in T}k_t=N$.\newline 
Když $H=\{h_i\mid i\in I\}$ je $c$-univerzální systém funkcí z univerza $
U$ o 
velikosti $N$ do tabulky o velikosti $m$, pak pomocí 
lemmatu dostáváme 
\begin{align*}&|I|N(\frac {N-m}m)\le\\
&\sum_{i\in I}|\{(x,y)\in U\times U\mid h_i(x)=h_i(y),\,x\ne y\}|
=\\
&\sum_{(x,y)\in U\times U,\,x\ne y}|\{i\in I\mid h_i(x)=h_i(y)\}|
\le\\
&\sum_{(x,y)\in U\times U,x\ne y}c\frac {|I|}m=N(N-1)c\frac {|I|}
m.\end{align*}
Odtud plyne, že $N-m\le c(N-1)$, a tedy 
$$c\ge\frac {N-m}{N-1}>\frac {N-m}N=1-\frac mN.$$
\end{proof}

\subsubsection{Problémy univerzálního hašování}

Použít jiné metody na řešení kolizí než 
separované řetězce. Jak to ovlivní použitelnost 
univerzálního hašování? Platí podobné vztahy jako pro 
pevně danou hašovací funkci? Jaký vliv na efektivnost 
má nepřítomnost operace {\bf DELETE}?

Existuje $c$-univerzální hašovací systém pro 
$c<1$? Jaký je vztah mezi velikostí $c$-univerzální\-ho 
hašovacího systému a velikostí $c$? Lze zkonstruovat 
malý $c$-univerzální systém pro $c<3.25$? Zde hraje roli 
fakt, že při $c=3.25$ se očekávaná délka řetězce 
může pohybovat až kolem hodnoty $7$.

Použití Čebyševovy nerovnosti místo 
Markovovy nerovnosti dává kvadratický odhad 
prav\-dě\-podobnosti, že délka řetězce je o $t$ větší než 
očekávaná hodnota. Za jakých okolností dává lepší 
odhad? Lze použít i vyšších momentů?

Jak použít Markovou nerovnost a očekávanou 
délku maximál\-ní\-ho řetězce pro odhad očeká\-va\-ného 
počtu voleb hašovací funk\-ce? 
Pro jaké parametry lze použít následující model?

Je dána základní velikost tabulky $m$ a dále pro $
j=0,1,\dots$ 
čísla (parametry) $l_j$ a $c$-univer\-zál\-ní hašovací systémy 
$H_j=\{h_i\mid i\in I_j\}$ z univerza do tabulky s~$m2^j$ řádky.\newline 
Množina $S\subseteq U$ je reprezentována následovně:  je dáno $
j$ 
tako\-vé, že když $j>0$, pak $m2^{j-2}\le |S|\le m2^j$, když $
j=0$, pak 
$|S|\le m$, a je zvolen index $i\in I_j$.  Dále máme prosté řetězce 
$r_0,r_1,\dots,r_{m2^j-1}$, jejichž délky jsou nejvýše $
l_j$, a řetězec $r_k$ 
obsahuje prvky $\{s\in S\mid h_i(s)=k\}$.\newline 
Operace {\bf INSERT$(x)$} prohledá řetězec $r_{h_i(x)}$ a když tento 
ře\-tě\-zec neobsahuje prvek $x$, pak ho přidá.  Když 
$m2^{j-2}\le |S|\le m2^j$ a délka řetězce $r_{h_i}(x)$ je nejvýše $
l_j$, pak 
operace končí.  Když $|S|>m2^j$, tak se nejdříve zvětší $
j$ o $1$.  
Pak se náhodně zvolí $i\in I_j$ a zkonstruují se řetězce 
reprezentující $S$.  Když některý z nich má délku větší než $
l_j$, 
tak se volba a konstrukce řetězců opakuje tak dlouho, 
dokud se nepovede zvolit $i\in I_j$ takové, že všechny 
zkonstruované řetězce mají délku nejvýše $l_j$.  Operace {\bf DELETE }
se řeší analogicky.\newline 
Problém:  Jak volit parametry $l_i$?  

V případě řešení 
kolizí dvojitým hašováním nebo hašováním s~lineárním přidáváním je třeba dát silnější podmínky na velikost $
|S|$. V poslední době se této tématice 
věnuje pozornost a byla dosažena řada zajímavých výsledků.

\subsection{Perfektní hašování}

Jiné řešení kolizí je perfektní hašování. Idea 
je nalézt pro danou množinu hašovací funkci, která 
nevytváří kolize.

Nevýhoda: Metoda nepřipouští operaci {\bf INSERT }
(pro nový vstup nemůžeme zaručit, že nevznikne  
kolize). Metodu lze prakticky použít pro úlohy, kde lze 
očekávat hodně operací {\bf MEMBER} a operace {\bf INSERT} se 
téměř nevyskytuje (kolize se řeší pomocí malé pomocné 
tabulky, kam se ukládají kolidují\-cí data). Tato metoda se 
používá při navrhování kompilátorů.

Zadání úlohy: Pro danou množinu $S\subseteq 
U$ chceme 
nalézt hašo\-va\-cí funkci $h$ takovou, že
\begin{enumerate}
\item
pro $s,t\in S$ takové, že $s\ne t$, platí $h(s)\ne h(t)$ (tj. $
h$ je \emph{perfektní} \emph{hašovací} \emph{funkce} pro 
$S$); 
\item
$h$ hašuje do tabulky s~$m$ řádky, kde $m$ je přibližně 
stejně velké jako $|S|$ (není praktické hašovat do příliš 
velkých tabulek -- ztrácí se jeden ze základních 
důvodů pro hašování); 
\item
$h$ musí být rychle spočitatelná -- jinak hašování 
není rychlé;
\item
uložení $h$ nesmí vyžadovat moc paměti, 
nejvýhodnější je ana\-lytické zadání (když zadání $
h$ bude 
vyžadovat moc paměti, např. když by byla dána tabulkou, 
pak se ztrácí důvod k použití stejně jako v 
bodě 2).
\end{enumerate}

Kompenzace: Nalezení hašovací funkce 
může spotřebovat více času. Provádí se jen na 
začátku úlohy. 

Uvedené požadavky motivují zavedení 
následujícího pojmu.\newline 
Mějme univerzum $U=\{0,1,\dots,N-1\}$. Soubor funkcí $H$ z 
$U$ do množiny $\{0,1,\dots,m-1\}$ se nazývá 
$(N,m,n)$-\emph{perfektní}, když pro každou $S\subseteq 
U$ 
takovou, že $|S|=n$, existuje $h\in H$ perfektní pro $S$ (tj. 
$h(s)\ne h(t)$ pro každá dvě různá $s,t\in S$).

Protože nevíme, zda taková $h$ existují, nejprve 
vyšetříme mno\-ži\-ny perfektních hašovacích 
funkcí. Vyšetříme vlastnosti $(N,m,n)$-perfektních 
souborů funkcí.

\subsubsection{Dolní odhady na velikost $(N,m,n)$-perfektního souboru}

Předpokládejme, že $H$  je $(N,m,n)$-perfektní 
systém pro $U=\{0,1,\dots,N-1\}$ a nejprve nalezneme dolní 
odhady na velikost $|H|$.

Mějme funkci $h$ z $U$ do množiny $\{0,1,\dots,m-
1\}$. 
Nalezneme počet množin $S\subseteq U$ takových, že  
$h$ je perfektní funkce pro $S$ a $|S|=n$. Funkce $h$ je perfektní pro 
$S\subseteq U$, právě když pro každé $i=0,1,\dots,m-
1$ je 
$|h^{-1}(i)\cap S|\le 1$. Odtud počet těchto množin je
$$\sum \{\prod_{j=0}^{n-1}|h^{-1}(i_j)|\mid 0\le i_0<i_1<\dots<i_{
n-1}<m\}.$$

Vysvětlení: $h(S)=\{i_j\mid j=0,1,\dots,n-1\}$.

Toto číslo je maximální, když $|h^{-1}(
i)|=\frac Nm$ pro každé $i$. 
Tedy $h$ může být perfektní nejvýše pro $\binom 
mn(\frac Nm)^n$ 
množin (číslo $\binom mn$ určuje počet posloupností 
$0\le i_0<i_1<\dots<i_{n-1}<m$). Protože $n$-prvkových 
podmnožin universa je $\binom Nn$, dostáváme, že 
$$|H|\ge\frac {\binom Nn}{\binom mn(\frac Nm)^n}.$$

Jiný odhad velikosti $(N,m,n)$-perfektního souboru.

Předpokládejme, že $H=\{h_1,\dots,h_t\}$ je 
$(N,m,n)$-perfektní soubor funkcí.  Definujme indukcí 
soubor množin $U_i$:\newline 
$U_0=U$ a pro 
$i>0$ je $U_i$ největší podmnožina $U_{i-1}$, co do počtu 
prvků, 
taková, že $h_i$ je konstantní na $U_i$.  Pak $|U_i|\ge\frac {
|U_{i-1}|}m$ 
pro všechna $i>0$.  Z $|U_0|=N$ plyne $|U_i|\ge\frac N{m^i}$.  Pro každé 
$i=1,2,\dots,t$ je $h_j(U_i)$ jednobodová množina pro každé 
$j\le i$.  Proto žádná $h_j$ pro $j\le i$ není perfektní pro 
množinu $S\subseteq U$ takovou, že $|S\cap U_i|\ge 2$.  Protože $
H$ je 
$(N,m,n)$-perfektní, musí být $|U_t|\le 1$, a tedy $\frac 
N{m^t}\le 1$.  Proto 
$t\ge\frac {\log N}{\log m}$.    

\begin{veta}Když $H$ je $(N,m,n)$-perfektní soubor 
funkcí, pak 
$$|H|\ge\max\{\frac {\binom Nn}{\binom mn(\frac Nm)^n},\frac {\log 
N}{\log m}\}.$$
\end{veta}

\subsubsection{Existence $(N,m,n)$-perfektního souboru}

Mějme univerzum $U=\{0,1,\dots,N-1\}$ a soubor 
funkcí $H=\{h_1,h_2,\dots,h_t\}$ z univerza $U$ do množiny 
$\{0,1,\dots,m-1\}$.  Reprezentujeme tento soubor pomocí 
matice $M(H)$ typu $N\times t$ s~hodnotami $\{0,1,\dots,m-1\}$ tak, 
že pro $x\in U$ a $i=1,2,\dots,t$ je 
v $x$-tém řádku a $i$-tém sloupci matice $M(H)$ 
hodnota $h_i(x)$. Pak žádná funkce z $H$ 
není perfektní pro množinu $S=\{s_1,s_2,\dots,s_n\}\subseteq 
U$, 
právě když podmatice $M(H)$ tvoře\-ná 
řádky $s_1$, $s_2$, až $s_n$ a všemi sloupci nemá prostý sloupec. 
Ta\-ko\-vých matic je nejvýše 
$$(m^n-\prod_{i=0}^{n-1}(m-i))^tm^{(N-n)t}.$$

Vysvětlení:  $m^n$ je počet všech funkcí z $
S$ do 
$\{0,1,\dots,m-1\}$, $\prod_{i=0}^{n-1}(m-i)$ je počet prostých funkcí z $
S$ 
do $\{0,1,\dots,m-1\}$, a tedy počet všech podmatic s~$n$ 
řádky takových, že žádný jejich sloupec není prostý, je 
$(m^n-\prod_{i=0}^{n-1}(m-i))^t$.  Tyto podmatice můžeme 
libovolně doplnit na matici typu $N\times n$ a pro každou 
matici je těchto doplnění $m^{(N-n)t}$.  

Podmnožin $U$ velikosti $n$ je $\binom Nn$, tedy počet všech 
matic, které nereprezentují $(N,m,n)$-perfektní systém, je 
menší nebo roven  
$$\binom Nn(m^n-\prod_{i=0}^{n-1}(m-i))^tm^{(N-n)t}.$$

Všech matic je $m^{Nt}$ a když 
\begin{equation*}\tag{\*}\binom Nn(m^n-\prod_{i=0}^{n-1}(m-i))^tm^{(N-n)t}<m^{Nt},\end{equation*}

pak nutně existuje $(N,m,n)$-perfektní systém. 
Následující vý\-ra\-zy jsou ekvivalentní s~ne\-rov\-ností 
\thetag{$*$}
$$\binom Nn\big(1-\frac {\prod_{i=0}^{n-1}(m-i)}{m^n}\big)^t<1\,\Leftrightarrow\,
t\ge\frac {\ln\binom Nn}{-\ln(1-\frac {\prod_{i=0}^{n-1}(m-i)}{m^
n})}.$$
Protože $\ln\binom Nn\le n\ln N$ a protože $-\ln(1-x)\ge x$ pro $
x\in (0,1)$, dostáváme
\begin{align*}-\ln(1-\frac {\prod_{i=0}^{n-1}(m-i)}{m^n})\ge&\prod_{i=0}^{
n-1}(1-\frac im)=e^{\sum_{i=0}^{n-1}\ln(1-\frac im)}\ge\\
&e^{\int_0^n\ln(1-\frac xm)dx},\end{align*}
kde integrál můžeme odhadnout 
$$m[(1-\frac nm)(1-\ln(1-\frac nm))-1]\ge m[(1-\frac nm)(1+\frac 
nm)-1]=-\frac {n^2}m.$$
Odtud dostáváme, že když $t\ge n(\ln N)e^{\frac {n^2}m}$, pak \thetag{*} platí, a tedy 
existuje $(N,m,n)$-perfektní soubor funkcí. 

Existence $(N,m,n)$-perfektního souboru funkcí ale 
nezaručuje splnění požadavků 2), 3) a 4).  
Abychom uspěli, použijeme ideu z metody univerzálního 
hašování.  

\subsubsection{Konstrukce perfektní hašovací funkce}

Předpoklady:  $U=\{0,1,\dots,N-1\}$, kde $N$ je 
prvočíslo.  Mějme $S\subseteq U$ o velikosti $n$.  Budeme 
uvažovat funkce 
$$h_k(x)=(kx\bmod N)\bmod m\qquad\text{\rm\ pro }k=1,2,\dots,N-1.$$
Pro $i=0,1,\dots,m-1$ a $k=1,2,\dots,N-1$ označme 
$$b_i^k=|\{x\in S\mid (kx\bmod N)\bmod m=i\}|.$$

Význam $b_i^k$: Hodnoty $b_i^k$ lze považovat za 
veličiny, které ukazují odchylku od perfektnosti. 
Všimněme si, že 
$$\text{\rm když }b_i^k\ge 2,\text{\rm\ pak }(b_i^k)^2-b_i^k\ge 
2,$$

protože $a^2-a\ge 2$, když $a\ge 2$. Na druhou stranu 
$$b_i^k\le 1\text{\rm\ implikuje }(b_i^k)^2-b_i^k=0.$$

Tedy z $\sum_{i=0}^{m-1}b_i^k=n$ plyne 

\begin{veta}Funkce $h_k$ je perfektní, právě když 
$\sum_{i=0}^{m-1}(b_i^k)^2-n<2$.
\end{veta}

Nyní odhadneme výraz $\sum_{k=1}^{N-1}\big((\sum_{
i=0}^{m-1}(b_i^k)^2)-n\big)$.
\begin{align*}\sum_{k=1}^{N-1}\big(&(\sum_{i=0}^{m-1}(b_i^k)^2)-n\big)=\\
&\sum_{k=1}^{N-1}\big((\sum_{i=0}^{m-1}|\{x\in S\mid h_k(x)=i\}|^
2)-n\big)=\\
&\sum_{k=1}^{N-1}|\{(x,y)\mid x,y\in S,\,x\ne y,\,h_k(x)=h_k(y)\}
|=\\
&\sum_{x,y\in S,x\ne y}|\{k\mid 1\le k<N,\,h_k(x)=h_k(y)\}|.\end{align*}
Zvolme $x,y\in S$ taková, že $x\ne y$. Pak $h_k(x)=h_k(y)$, 
právě když existuje $i=0,1,\dots,m-1$ a $r,s=0,1,\dots,\lfloor\frac 
Nm\rfloor$ 
taková, že $kx\equiv i+rm\bmod N$ a $ky\equiv i+sm\bmod N$ a $
i+rm,i+sm<N$. Odtud dostáváme, že $h_k(x)=h_k(y)$ implikuje $
kx-ky\equiv (r-s)m\bmod N$.
Protože $0<k<n$ a $x\ne y$, dostáváme, že $kx-ky\ne 0$, a tedy 
$h_k(x)=h_k(y)$ implikuje existenci 
$q=-\lfloor\frac Nm\rfloor ,-\lfloor\frac Nm\rfloor +1,\dots,-1,1
,2,\dots,\lfloor\frac Nm\rfloor$ takového, že 
$kx-ky\equiv qm\bmod N$,
a to je 
ekvivalentní s~tím, že $k(x-y)\equiv qm\bmod N$ pro nějaké 
$q=-\lfloor\frac Nm\rfloor ,-\lfloor\frac Nm\rfloor +1,\dots,-1,1
,2,\dots,\lfloor\frac Nm\rfloor$.

Pro $x>y$ a pro jedno $q=0,1,\dots,\lfloor\frac Nm\rfloor$ e\-xis\-tuje 
právě jedno $k$ takové, že $k(x-y)\equiv qm\bmod N$, protože 
$\mathbb Z_N$ je těleso (tato rovnice má jediné řešení). 
Protože pro $q=-\lfloor\frac Nm\rfloor ,\dots,-1,0$ je rovnice $
k(x-y)\equiv qm\bmod N$ 
ekvivalentní s~rovnicí $k(x-y)\equiv N+qm\bmod N$, tak 
dostáváme, že pro $x,y\in S$, $x>y$, existuje nejvýše 
$2\lfloor\frac Nm\rfloor =2\lfloor\frac {N-1}m\rfloor$ různých $
k=1,2,\dots,N-1$, že $h_k(x)=h_k(y)$ (obecně není pravda, že když 
$k$ splňuje rovnici $k(x-y)\equiv qm\bmod N$ pro nějaké 
$q=-\lfloor\frac Nm\rfloor ,\dots,-1,1,\dots,\lfloor\frac Nm\rfloor$, 
pak $h_k(x)=h_k(y)$). Stejný odhad analogicky dostaneme, když $
x<y$ 
(ale dostáváme jiná řešení). Odtud 
$$\sum_{k=1}^{N-1}\big((\sum_{i=0}^{m-1}(b_i^k)^2)-n\big)\le\sum_{
x,y\in S,x\ne y}2(\frac {N-1}m)=2(N-1)\frac {n(n-1)}m.$$

Tedy existuje $k$ takové, že $\sum_{i=0}^{m-1}(b_i^
k)^2\le 2\frac {n(n-1)}m+n$. 

Ukážeme, že existuje více než $\frac {N-
1}4$ takových 
$k$, že platí
$$\sum_{i=0}^{m-1}(b_i^k)^2<3\frac {n(n-1)}m+n.$$
V opačném případě dostáváme, že 
\begin{align*}\sum_{k=1}^{N-1}\big((\sum_{i=0}^{m-1}(b_i^k)^2)-n\big)\ge&\frac {
3(N-1)}4\frac {3n(n-1)}m=\\
&\frac {9(N-1)n(n-1)}{4m}>\\
&\frac {2(N-1)n(n-1)}m,\end{align*}
a to je spor s~předchozím výsledkem. Tedy při náhodném rovnoměrném 
výběru $k$ je 
$$\Prob\{\sum_{i=0}^{m-1}(b_i^k)^2<\frac {3n(n-1)}m+n\mid k\in \{
1,2,\dots,N-1\}\}\ge\frac 14.$$

\begin{tvrzeni}Když $n=m$, pak 
\begin{enumerate}
\item[(a)]
existuje deterministický algoritmus, jenž v čase $O(nN)$ 
nalezne $k$ takové, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2<3n;$$
\item[(b)]
existuje pravděpodobnostní algoritmus, který 
nalezne v čase $O(n)$ takové $k$, že $\sum_{i=0}^{m-1}(b_
i^k)^2<4n$ -- očekávaný počet iterací výpočtu je nejvýše $
4$.
\end{enumerate}
Dále 
\begin{enumerate}
\item[(c)]
existuje deterministický algoritmus, jenž v čase $O(nN)$ pro 
$m=n(n-1)+1$ nalezne takové $k$, že $h_k$ je 
perfektní;
\item[(d)]
existuje pravděpodobnostní algoritmus, který pro 
$m=2n(n-1)$ v čase $O(n)$ nalezne $k$ takové, že $h_k$ je 
perfektní -- očekávaný počet iterací výpočtu 
je nejvýše $4$.
\end{enumerate}
\end{tvrzeni}

\begin{proof}Mějme $n=m$. Protože spočítání 
$\sum_{i=0}^{m-1}(b_i^k)^2$ pro pevné $k$ vyžaduje čas $O
(n)$, prohledáním 
všech možností nalez\-ne\-me $k$ takové, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2\le\frac {2n(n-1)}n+n=3n-2<3n,$$
v čase $O(nN)$. Tím je 
dokázáno a). Pravděpodobnostní algoritmus dokazující b) volí 
náhodně $k$ a v čase $O(n)$ ověří, zda 
$\sum_{i=0}^{m-1}(b_i^k)^2\le 3\frac {n(n-1)}n+n=4n-3<4n$. Tuto akci opakuje, dokud 
požadavek není splněn. Protože pravděpodobnost, že $
k$ splňuje 
požadavek, je alespoň $\frac 14$, tak očekávaný počet ite\-rací 
akce je nejvýše 
$$\sum_{i=0}^{\infty}i(\frac 34)^{i-1}\frac 14=\frac 14\frac 1{(1
-\frac 34)^2}=4$$
a odtud plyne b). 

Když $m=n(n-1)+1$, pak prohledáním všech možností 
nalezne\-me $k$ takové, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2\le\frac {2n(n-1)}{n(n-1)+1}+n<n+2,$$
 v 
čase $O(nN)$ a c) plyne z předchozí věty. Když 
$m=2n(n-1)$, pak pro náhodně zvolené $k$ platí s~pravděpodobností $\le\frac 14$, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2\le\frac {3n(n-1)}{2n(n-1)}+n<n+2.$$
Algoritmus splňující tvrzení d) je stejný jako 
v případě b) (jen $m=2n(n-1)$).
\end{proof}

Takto zkonstruované perfektní hašovací funkce 
nesplňují poža\-davek 2) (platí $m=\Theta (n^2)$).  Použijeme následující 
postup. 

1) Nalezneme $k$ takové, že pro $m=n$ platí 
$\sum_{i=0}^{m-1}(b_i^k)^2<3n$ (respektive $\sum_{i=0}^{m-1}(b_i^
k)^2<4n$).  Pro 
$i=0,1,\dots,m-1$ nalezneme množiny 
$S_i=\{s\in S\mid h_k(s)=i\}$;\newline 
2) Pro každé $i=0,1\dots,m-1$ takové, že $S_i\ne\emptyset$, 
nalezneme pro $m=1+|S_i|(|S_i|-1)$ (respektive $m=1+2|S_i|(|S_i|-
1)$) 
takové $k_i$, že $h_{k_i}$ je perfektní na $S_i$. Definujme 
$c_i=1+|S_i|(|S_i|-1)$ (respektive $c_i=2|S_i|(|S_i|-1)$), když 
$S_i\ne\emptyset$, a $c_i=0$, když 
$S_i=\emptyset$.\newline 
3) Pro $i=0,1,\dots,m$ definujme $d_i=\sum_{j=0}^{i-1}c_j$ a pro $
x\in U$ 
označme $h_k(x)=l$. Pak položíme $g(x)=d_l+h_{k_l}(x)$.

\begin{veta}Zkonstruovaná funkce $g$ je perfektní, 
hodnota $g(x)$ se pro každé $x\in U$ spočítá v čase $
O(1)$, 
v deterministickém přípa\-dě hašuje do tabulky velikosti 
$<3n$ a je nalezena v čase $O(nN)$, v pravděpodobnostním 
přípa\-dě hašuje do tabulky velikosti $<6n$ a je nalezena 
v čase $O(n)$. Pro její zakódování jsou třeba hodnoty $
k$ a 
$k_i$ pro $i=0,1,\dots,m-1$. Tyto hodnoty jsou v rozmezí 
$1,2,\dots,N-1$, a tedy vyžadují $O(n\log N)$ paměti.
\end{veta}

\begin{proof}Protože $g(S_i)$ pro $i=0,1,\dots,m-1$ 
jsou navzájem disjunktní a $h_{k_i}$ je perfektní na $S_
i$, 
dostáváme, že $g$ je perfektní. Pro výpočet hodnoty $
g(x)$ 
jsou třeba dvě násobení, dvojí výpočet zbytku při 
dělení a jedno sčítání (hodnoty $d_i$ jsou uloženy v 
paměti). Proto výpočet $g(x)$ vyžaduje čas $O(1)$. Dále 
$d_m$ je horní odhad na počet řádků v tabulce. 
Protože pro $S_i\ne\emptyset$ máme $|S_i|(|S_i|-1)+1\le |S_
i|^2=(b_i^k)^2$, 
dostáváme v deterministickém případě 
$d_m=\sum_{i=0}^{m-1}c_i\le\sum_{i=0}^{m-1}(b_i^k)^2<3n$ a $k$ nalezneme v čase 
$O(nN)$. Protože $k_i$ nalezneme v čase $O(|S_i|N)$, lze $g$ 
zkonstruovat v čase 
$O(nN+\sum_{i=0}^{m-1}|S_i|N)=O(nN+N\sum_{i=0}^{m-1}|S_i|)=O(2nN)
=O(nN)$. 
V pravděpodob\-nostním případě je 
$$d_m=\sum_{i=0}^{m-1}c_i\le\sum_{i=0}^{m-1}(2|S_i|^2-2|S_i|)=2\sum_{
i=0}^{m-1}(b_i^k)^2-2\sum_{i=0}^{m-1}b_i^k<8n-2n=6n$$
(protože $|S_i|=b_i^k$ a $\sum_{i=0}^{m-1}b_i^k=n$). Protože $
k$ nalezneme v čase $O(n)$ a $k_i$ v čase $O(|S_i|)$, dostaneme, že 
že $g$ nalezneme v čase $O(n)$. Zbytek je jasný.
\end{proof}

Tedy zkonstruovaná hašovací funkce splňuje požadavky 
1), 2) a 3), ale požadavek 4) není splněn. 

Mějme přirozené číslo $m$ a nechť $q$ je počet všech prvočísel 
dělících $m$ ($p_1,p_2,\dots$ je rostoucí posloupnost všech 
prvočísel). Pak
$$m\ge\prod_{i=1}^qp_i>q!=e^{\sum_{i=1}^q\ln i}\ge e^{\int_1^q\ln 
xdx}=e^{q\ln(\frac qe)+1}\ge (\frac qe)^q.$$
Proto existuje konstanta $c$, že $q\le c\frac {\ln m}{\ln\ln m}$ (viz Lemma v odstavci Očekávaný 
nejhorší případ na stránce 6). Platí tedy  
\begin{veta}Nechť $\delta (m)=$počet prvočísel, která dělí 
$m$. Pak $\delta (m)=O(\frac {\log m}{\log\log m})$.
\end{veta}

Mějme $S=\{s_1<s_2<\dots<s_n\}\subseteq U$. Označme 
$d_{i,j}=s_j-s_i$ pro $1\le i<j\le n$. Pak $s_i\bmod p\ne s_j\bmod 
p$, 
právě když $d_{i,j}\ne 0\bmod p$. Označme 
$D=\prod_{1\le i<j\le n}d_{i,j}\le N^{(n^2)}$. Pak počet prvočíselných 
dělitelů čísla $D$ je nejvýše $c\frac {\ln 
D}{\ln\ln D}$, a tedy mezi 
prvními $1+c\frac {\ln D}{\ln\ln D}$ prvočísly existuje prvočíslo $
p$ 
takové, že $s_i\bmod p\ne s_j\bmod p$ pro každé $1\le i
<j\le n$. 
To znamená, že funkce $\phi_p(x)=x\bmod p$ je perfektní pro 
$S$. Podle věty o velikosti prvočísel $p_t\le 2t\ln t$ pro každé $
t\ge 6$, tedy
\begin{align*} p\le&2(1+c\frac {\ln D}{\ln\ln D})\ln(1+c\frac {\ln D}{\ln\ln 
D})\le\\
&4c\frac {\ln D}{\ln\ln D}\ln(2c\frac {\ln D}{\ln\ln D})\le\\
&4c(\ln2c)\frac {\ln D}{\ln\ln D}+4c\frac {\ln D}{\ln\ln D}\ln(\frac {\ln 
D}{\ln\ln D})=\\
&4c\ln D+o(\ln D)=O(\ln D)=O(n^2\ln N).\end{align*}

\begin{veta}Pro každou $n$-prvkovou množinu $S\subseteq 
U$ 
existuje prvo\-čís\-lo $p$ o velikosti $O(n^2\ln N)$ takové, že 
funkce $\phi_p(x)=x\bmod p$ je perfektní pro $S$.  
\end{veta}

Test, zda funkce $\phi_p(x)=x\bmod p$ je perfektní 
pro $S$, 
vyžaduje čas $O(n\log n)$. Tedy systematické hledání 
nejmenšího $p$, že $\phi_p$ je perfektní pro $S$, vyžaduje čas 
$O(n^3\log n\log N)$. Nejmenší $p$ takové, že $\phi_p$ je perfektní 
pro $S$, 
je prvočíslo. Navrhneme pravděpodob\-nostní algoritmus 
pro nalezení $p$. Pro dostatečně velké $n$ mezi 
prvními $9c\ln D$ čísly je alespoň polovina tako\-vých 
prvočísel $p$, že $\phi_p$ je perfektní pro $S$. Algoritmus pak 
opakuje následující krok, dokud nenalezne perfektní funkci
\begin{enumerate}
\item 
vyberme náhodně číslo $p$ mezi prvními $9cn^2\ln 
N$ 
čísly a otestujme, zda $p$ je prvočíslo a $\phi_p$ je perfektní
\end{enumerate}

Odhad očekávaného počtu neúspěšných kroků.\newline 
Náhodně zvolené číslo $p\le 9cn^2\ln N$ je prvočíslo s~pravděpo\-dob\-ností $\Theta (\frac 1{\ln(9cn^2\ln N)})$ 
(použi\-je\-me Rabin-Millerův pravděpdobnostní algoritmus na testovéní prvočísel) a pro prvočíslo $
p$ je $\phi_p$ 
perfektní s~prav\-dě\-po\-dob\-ností $\ge\frac 12$. Tedy náhodně zvolené 
číslo $p\le 9cn^2\ln N$ splňuje test s~pravdě\-po\-dob\-ností 
$\Theta (\frac 1{\ln(9cn^2\ln N)})$, a proto očeká\-va\-ný počet neúspěšných 
testů je $O(\ln(9cn^2\ln N))$. Tedy očeká\-vaný čas 
algoritmu je $O(n\log n(\log n+\log\log N))$.

\begin{veta}Pro danou množinu $S\subseteq U$ takovou, že 
$|S|=n$, deterministický algoritmus nalezne prvočíslo 
$p=O(n^2\log N)$ takové, že $\phi_p(x)=x\bmod p$ je perfektní 
pro $S$, a pracuje v čase $O(n^3\log n\log N)$. Pravděpodobnostní 
algoritmus nalezne pr\-vočíslo $p=O(n^2\log N)$ takové, že 
$\phi_p$ je perfektní, v očekáva\-ném čase 
$O(n\log n(\log n+\log\log N))$.
\end{veta}

Deterministický algoritmus nalezne nejmenší prvočíslo s~po\-ža\-dovanou vlastností.  Prav\-dě\-podobnostní algoritmus 
nalezne prvočíslo, které může být podstatně 
větší, ale jeho velikost je omezena $9cn^2\log N$. 

Nyní navrhneme postup na konstrukci perfektní 
hašovací funk\-ce pro množinu $S\subseteq U$.

\begin{enumerate}
\item
Nalezneme prvočíslo $q_0\in O(n^2\log N)$ takové, že 
$\phi_{q_0}(x)=x\bmod q_0$ je perfektní funkce pro $S$. Položme 
$S_1=\{\phi_{q_0}(s)\mid s\in S\}$.
\item
Nalezneme prvočíslo $q_1$ takové, že 
$n(n-1)<q_1\le 2n(n-1)$. Pak existuje 
$l\in \{1,2,\dots,q_0-1\}$ takové, že $h_l(x)=((lx)\bmod q_0
)\bmod q_1$ 
je perfektní pro $S_1\subseteq \{0,1,\dots,q_0-1\}$. Položme 
$S_2=\{h_l(s)\mid s\in S_1\}$.
\item
Dále zkonstruujme perfektní hašovací funkci 
$g$ pro množinu 
$S_2\subseteq \{0,1,\dots,q_1-1\}$ do tabulky s~méně než $
3n$ řádky. 
Položme $f(x)=g(h_l(\phi_{q_0}(x)))$. Konstruovaná hašovací 
funkce je $f$.
\end{enumerate}

Výsledek: $f$ je perfektní hašovací funkce pro $
S$, protože 
složení perfektních hašovacích funkcí je zase perfektní 
funkce, a tedy požadavek 1) je splněn. \newline 
$f$ hašuje $S$ do tabulky s~méně než $3n$ řádky, a tedy 
splňuje požadavek 2). \newline 
Protože každá z funkcí $g$, $h_l$, $\phi_{q_0}$ se vyčíslí v čase $
O(1)$, 
i vyčíslení funkce $f$ vyžaduje čas $O(1)$ a požadavek 3) je 
splněn.\newline 
Funkce $\phi_{q_0}$ je jednoznačně určena číslem $
q_0\in O(n^2\log N)$. 
Funkce $h_l$ je určena čísly $q_1\in O(n^2)$ a $l\in O(
q_0)$. Funkce $g$ 
je určena $n+1$ čísly velikosti $O(q_1)$. Tedy zadání $
f$ 
vyžaduje paměť o velikosti 
$$O(\log n+\log\log N+n\log n)=O(n\log n+\log\log N).$$
Lze říct, že požadavek 4) je splněn. 

Výpočet $\phi_{q_0}$ vyžaduje čas $O(n^3\log 
n\log N)$. Výpočet $h_l$ 
vyža\-du\-je čas $O(n(n^2\log N))=O(n^3\log N)$ (použité univerzum je 
$\{0,1,\dots,q_0\}$). Výpočet $g$ vyžaduje čas $O(nn^2
)=O(n^3)$ 
(zde univerzum je $\{0,1,\dots,q_1\}$). Celkově 
výpočet $f$ vyžaduje čas $O(n^3\log n\log N)$.

Lze použít i pravděpodobnostní algoritmy pro nalezení 
$g$, $h_l$ a $\phi_{q_0}$. Pak hašujeme do tabulky s~méně než $
6n$ 
řádky, ale očekávaný čas pro nalezení $f$ je 
$O(n\log n(\log n+\log\log N))$.


Tuto metodu navrhli Fredman, Komlós a Szemerédi.

\subsubsection{Univerzální a perfektní hašování}

Předchozí hlavní konstrukce perfektní hašovací funkce 
vycházela z idejí použitých v univerzálním hašování.  Ukážeme, 
že to není náhodná shoda. Dokážeme, že každý $
c$-univerzální 
systém funkcí umožňuje základní konstrukci perfektní hašovací 
funkce.  Pro každé $m$ nechť $\mathcal H_m=\{h_i\mid i\in I\}$ je $
c$-univerzální 
systém funkcí hašujících do ta\-bulky velikosti $
m$. Pro 
libovolnou, ale pevnou podmnožinu $S\subseteq U$ o velikosti $
n$ definujme 
$b_j^i=\{s\in S\mid h_i(s)=j\}$ pro každé $j=0,1,\dots,m-1$ a $
i\in I$. Když 
$b^i_j\ge 2$, pak $(b^i_j)^2-b^i_j\ge 2$, a když $b^i_j\le 1$, pak $
(b^i_j)^2-b^i_j=0$. Odtud 
dostáváme přirozené zobecnění důsledku z předchozí 
sekce, které využijeme stejným způsobem jako v 
předchozí sekci:

\begin{dusledek}Když $\sum_{j=0}^{m-1}(b^i_j)^2\ge n+2$, pak $h_i$ není 
perfektní pro $S$, když $\sum_{j=0}^{m-1}(b^i_j)^2<n+2$, pak $h_i$ je perfektní 
hašovací funkce pro $S$.
\end{dusledek}

Stejně jako v předchozí sekci spočítáme  
\begin{align*}\sum_{i\in I}&\big(\sum_{j=0}^{m-1}(b^i_j)^2-n\big)=\sum_{
i\in I}|\{(s,t)\mid s,t\in S,\,s\ne t,\,h_i(s)=h_i(t)\}|=\\
&\sum_{s,t\in S,s\ne t}|\{i\in I\mid h_i(s)=h_i(t)\}|\le\sum_{s,t
\in S,s\ne t}\frac {c|I|}m=\frac {cn(n-1)|I|}m.\end{align*}

Proto existuje $i\in I$ takové, že $\sum_{j=0}^{m-
1}(b^i_j)^2\le\frac {cn(n-1)}m+n$. Nyní 
spočítáme analogické odhady, které tvoří základ pro 
pravděpodobnostní algoritmus. Mějme kladné číslo $
a>0$ a 
označme $I'$ množinu těch $i\in I,$ že  
$$\sum_{j=0}^{m-1}(b^i_j)^2>\frac {(c+a)n(n-1)}m+n.$$
Dále předpokládejme, že $|I'|\ge b|I|$ pro 
nějaké kladné číslo $b$. Pak platí 
\begin{align*}\frac {cn(n-1)|I|}m&\ge\sum_{i\in I}\big(\sum_{j=0}^{m-1}
(b^i_j)^2-n\big)\ge\sum_{i\in I'}\big(\sum_{j=0}^{m-1}(b^i_j)^2-n\big
)>\\
&\sum_{i\in I'}\frac {(c+a)n(n-1)}m\ge\frac {(c+a)n(n-1)b|I|}m.\end{align*}
Odtud plyne, že $c>(c+a)b$, a proto $b<\frac c{c+a}$. Když tedy vybíráme  
$h_i\in \mathcal H_m$ náhodně s~rovnoměrným rozdělením (vzhledem k $
i\in I$), pak 
pravděpo\-dobnost, že bude platit $\sum_{j=0}^{m-1}(b^i_j)^
2>\frac {(c+a)n(n-1)}m+n$, je 
menší než $\frac c{c+a}$. Stejně jako v předchozí sekci shrneme tato fakta do tvrzení 

\begin{tvrzeni}Pro přirozené číslo $m$ mějme $
c$-univerzální systém funkcí $\mathcal H_m=\{h_i\mid i\in 
I\}$ hašujících do tabulky o velikosti 
$m$. Pro $m=n$ existuje deterministický algoritmus, 
který v čase $O(|I|n)$ nalezne $h_i\in \mathcal H_m$ takovou, že $
\sum_{j=0}^{m-1}(b^i_j)^2\le c(n-1)+n$, 
a existuje pravděpodobnostní algoritmus, který pro kladné číslo 
$a$ v čase $O(n)$ nalezne $h_i\in \mathcal H_m$ takové, že 
$$\sum_{j=0}^{m-1}(b^i_j)^2<(c+a)(n-1)+n,$$
a očekávaný počet iterací při hledání $h_i$ je menší než $\frac {
c+a}a$.   

Pro $m=\frac {cn(n-1)}2+1$ existuje deterministický algoritmus, 
který nalezne perfektní hašovací funkci  $h\in \mathcal H_
m$ pro množinu $S$ 
velikosti $n$ v čase $O(n|I|)$.

Pro $a>0$ a pro $m=\frac {(c+a)n(n-1)}2+1$ existuje 
pravděpodobnostní algoritmus, který nalezne perfektní hašovací 
funkci $h\in \mathcal H_m$ pro množinu $S$ v čase $O(n)$ a očekávaný počet 
iterací je menší než $\frac {c+a}a$.  
\end{tvrzeni}

\begin{proof}Když $n=m$, pak v čase $O(n)$ pro  
hašovací funkci ověříme, zda $\sum_{j=0}^{m-1}(b^
i_j)^2\le c(n-1)+n$, respektive 
$\sum_{j=0}^{m-1}(b^i_j)^2\le (c+a)(n-1)+n$.  V prvním případě víme, že taková 
funkce v souboru $\mathcal H_m$ existuje, a systematickým prohledáváním 
všech funkcí v daném $c$-univerzálním systému $\mathcal H_
m$ ji nalezneme 
v čase $O(n|I|)$.  Pro pravděpodobnostní algoritmus budeme 
vybírat funkci ze souboru $\mathcal H_m$ náhodně s~rovnoměrným 
rozdělením.  Pak očekávaný počet iterací než uspějeme je 
\begin{align*}\sum_{i=1}^{\infty}&i(\frac c{c+a})^{i-1}(1-\frac c{c+a})
\le\sum_{i=1}^{\infty}i(\frac c{c+a})^{i-1}-\sum_{i=1}^{\infty}i(\frac 
c{c+a})^i=\\
&\sum_{i=0}^{\infty}(\frac c{c+a})^i=\frac 1{1-\frac c{c+a}}=\frac {c
+a}a.\end{align*}

Pro hledání perfektní hašovací funkce opět použijeme 
syste\-ma\-tické prohledávání $c$-univer\-zál\-ního systému, protože 
víme, že existuje funkce $h_i\in \mathcal H_m$ taková, že 
$\sum_{j=1}^{m-1}(b^i_j)^2\le\frac {cn(n-1)}{\frac {cn(n-1)}2+1}+
n<n+2$, a tedy je tato funkce perfektní. 
To vyžaduje čas $O(n|I|)$. 

Když máme $a>1$ a $m=\frac {(c+a)n(n-1)}2+1$ 
a když budeme volit funkce z $\mathcal H_m$ 
náhodně s~rovnoměrným rozdělením, pak s~pravděpodobností 
$\frac a{c+a}$ do\-sta\-ne\-me funkci $h_i$ takovou, že 
$$\sum_{j=0}^{m-1}(b^i_j)^2\le\frac {(c+a)n(n-1)}{\frac {(c+a)n(n
-1)}2+1}+n<2+n.$$
Z důsledku plyne, že $h_i$ je perfektní.  Analýza 
očekávaného počtu iterací je stejná jako u předchozího tvrzení 
pro pravděpodobnostní algoritmus. 
\end{proof}

Další postup konstrukce perfektní hašovací funkce už 
nesouvisí s~$c$-univerzálními systémy. 

\subsubsection{Dynamické perfektní hašování}

Jedna z velkých nevýhod perfektního hašovaní je 
neznalost efektivních aktualizačních ope\-rací. Existují sice 
obecné meto\-dy na dynamizaci deterministických operací -- viz 
letní přednáš\-ka, ale tato metoda v tomto případě neposkytuje 
efektivní dynamizační operace, protože deterministický 
algoritmus pro ře\-še\-ní perfektního hašování je pro 
aktualizační ope\-race příliš pomalý. To vedlo k návrhu, 
který kombinuje pravděpodobnostní algoritmus pro perfektní 
hašování s~obecnou metodou dynami\-za\-ce a tyto metody jsou 
upraveny pro konkrétní situaci. 

Nejprve uvedeme modifikaci výsledků z 
předchozí části, na kterých je tato metoda založena.
Předpokládáme, že $U=\{0,1,\dots,N-1\}$ je univerzum, kde $
N$ je 
prvočíslo, a že je dáno číslo $s<N$. Označme 
$\mathcal H_s=\{h_k\mid k=1,2,\dots,N-1\}$ množinu funkcí z $U$ do 
$\{0,1,\dots,s-1\}$, kde $h_k(x)=(kx\bmod N)\bmod s$ pro každé $
x\in U$. 
Když zvolíme náhodně $k=1,2,\dots,N-1$, pak s~pravděpodobností 
ales\-poň $\frac 12$ platí 
$$\sum_{i=0}^{s-1}(b_i^k)^2<\frac {4n^2}s+n.$$
Skutečně, když pro méně než $\frac{N-1}2$ hodnot $k$ platí $\sum_{i=0}^m-1(b^k_i)^2\le\frac{4n}m$, pak 
$$\sum_{k=1}^{N-1}\left((\sum_{i=0}^{m-1}(b^k_i)^2)-n\right)\ge2(N-1)\frac{n^2}m$$ 
a to je spor. Budeme předpokládat, 
že takové $k$ máme, a pak pro každé $i=0,1,\dots,s-1$ 
předpokládáme, že náhodně zvolíme $j_i\in \mathcal H_{
2(b_i^k)^2}$ takové, že 
$h_{j_i}$ je prostá na množině $S_i=\{s\in S\mid h_k(s)=i
\}$ (z předchozího textu víme, že když zvolíme náhodně 
$j_i=0,1,\dots,N-1$, pak s~pravděpodobností ales\-poň $\frac 
14$ je $h_{j_i}$ prostá na $S_i$). Pro jednoduchost předpokládáme, že množiny $
S_i$ 
pro $i=0,1,\dots,s-1$ uložíme do tabulek $T_i$ a tabulky 
$T_0,T_1,\dots,T_{s-1}$ budou uloženy v tabulce $T$. Když $
s=O(|S|)$, 
pak tato metoda vyžaduje $O(|S|)$ prostoru. Abychom určili $
s$, 
zvolme $c>1$ a položme $s=\sigma (|S|)$, kde $\sigma (n)=\frac 
43\sqrt 6(1+c)n$ pro 
každé $n$. Nyní popíšeme algoritmy. Zde $n$ je velikost reprezentované množiny, $s=\sigma(n)$ a $2m(j)$ je velikost tabulky $T_j$ pro $j=0,1,\dots,s-1$.

\subsubsection{Algoritmy}


{\bf INSERT$(x)$}: \newline 
$n:=n+1$ \newline 
{\bf if} $n\le s$ {\bf then}\newline 
\phantom{---}$j:=h(x)$, $|S_j|:=|S_j|+1$\newline 
\phantom{---}{\bf if} $|S_j|\le m(j)$ a pozice $h_j(x)$ v $T_j$ je prázdná {\bf then}\newline 
\phantom{------}vložíme $x$ do tabulky $T_j$  na pozici $
h_j(x)$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $|S_j|\le m(j)$ a pozice $h_j(x)$ v $T_
j$ je obsazená {\bf then}\newline 
\phantom{---------}vytvoříme seznam $S_j$ prvků v tabulce $
T_j$\newline 
\phantom{---------}vyprázdníme tabulku $T_j$\newline 
\phantom{---------}zvolíme náhodně funkci $h_j\in \mathcal H_{
m(j)^2}$\newline 
\phantom{---------}{\bf while} $h_j$ není prostá na množině $
S_j$ {\bf do}\newline 
\phantom{------------}zvolíme náhodně funkci $h_j
\in \mathcal H_{m(j)^2}$\newline 
\phantom{---------}{\bf enddo}\newline 
\phantom{---------}{\bf for every} $y\in S_j$ {\bf do} vložíme $
y$ do $T_j$ na pozici $h_j(y)$ {\bf enddo}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$m(j):=2m(j)$\newline 
\phantom{---------}{\bf if} není dost prostoru pro tabulku $
T_j$ nebo 
$$\sum_{i=0}^{\sigma (m)-1}(m(i))^2\ge\frac {4n^2}{\sigma (n)}+n$$
\phantom{---------}{\bf then}\newline 
\phantom{------------}{\bf RehashAll}\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}alokujeme prostor pro novou prázdnou tabulku $
T_j$ \newline 
\phantom{------------}vytvoříme seznam $S_j$ prvků ze staré tabulky $
T_j$ a zrušíme ji\newline 
\phantom{------------}zvolíme náhodně funkci $h_j\in \mathcal H_{
m(j)^2}$\newline 
\phantom{------------}{\bf while} $h_j$ není prostá na množině $
S_j$ {\bf do}\newline 
\phantom{---------------}zvolíme náhodně funkci $
h_j\in \mathcal H_{m(j)^2}$\newline 
\phantom{------------}{\bf enddo}\newline 
\phantom{------------}{\bf for every} $y\in S_j$ {\bf do} vložíme $
y$ do $T_j$ na pozici $h_j(y)$ {\bf enddo}\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf RehashAll}\newline 
\phantom{---}{\bf endif\newline 
endif}


{\bf RehashAll}:\newline 
projdeme tabulku $T$ a tabulky $T_i$ a vytvoříme seznam 
prvků z množiny $S$\newline 
$s:=\sigma(n)$\newline 
zvolme náhodně $h\in \mathcal H_s$ \newline 
{\bf for every} $i=0,1,\dots,s-1$ {\bf do} $S_i:=\{x\in 
S\mid h(x)=i\}$ {\bf enddo\newline 
while} $\sum_{i=0}^{s-1}2(|S_i|)^2>\frac {8n^2}s+2n$ {\bf do}\newline 
\phantom{---}zvolme náhodně $h\in \mathcal H_s$ \newline 
\phantom{---}{\bf for every} $i=0,1,\dots,s-1$ {\bf do} $
S_i:=\{x\in S\mid h(x)=i\}$ {\bf enddo}\newline 
{\bf enddo}\newline
Komentář: zde $S_i$ jsou množiny vytvořené náhodně zvolenou 
funkcí $h$ \newline 
$n:=0$ \newline 
{\bf for every} $i=0,1,\dots,s-1$ {\bf do}\newline 
\phantom{---}$m(i):=2|S_i|$\newline 
\phantom{---}zvolíme náhodně $h_i\in \mathcal H_{m(i
)^2}$\newline 
\phantom{---}{\bf while} $h_i$ není prostá na množině $
S_i$ {\bf do}\newline 
\phantom{------}zvolíme náhodně $h_i\in \mathcal H_{m(i)^2}$\newline 
\phantom{---}{\bf enddo\newline 
enddo\newline 
for every} $x\in S$ {\bf do INSERT$(x)$ enddo}


{\bf DELETE$(x)$}:\newline 
$j:=h(x)$, $n:=n-1$, $|S_j|:=|S_j|-1$\newline 
odstraníme $x$ z pozice $h_j(x)$ v tabulce $T_j$, pozice bude prázdná \newline 
{\bf if} $n<\frac m{1+2c}$ {\bf then RehashAll endif}


{\bf MEMBER$(x)$}: \newline 
$j:=h(x)$\newline 
{\bf if} $x$ je na $h_j(x)$-té pozici v tabulce $T_j$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x$ je prvek $S$ \newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x$ není prvkem $S$\newline 
{\bf endif}


Algoritmy předpokládají, že při operaci {\bf INSERT$
(x)$} prvek $x$ nepatří do $S$ a při operaci {\bf DELETE$(x)$} $
x$ je prvkem $S$. Velikost reprezentované množiny je $n$. 

Uvedu složitost této metody bez důkazu.

\begin{veta}Popsaná metoda vyžaduje lineární paměť 
(neuvažuje se paměť potřebná pro zakódo\-vá\-ní hašovacích funkcí), operace {\bf MEMBER }
v nej\-horším případě vyžaduje čas $O(1)$ a očekávaná 
amortizovaná složitost operací {\bf INSERT} a {\bf DELETE} je také $
O(1)$.
\end{veta}

Toto zobecnění Fredman-Komlós-Szemerédiho metody navrhli 
Dietzfelbinger, Karlin, Mehl\-horn, Meyer auf der Heide, Rohnert 
a Tarjan.


Další nevýhoda Fredman-Komlós-Szemerédiho metody:\newline 
Navržená metoda pracuje pro $m<3n$, ale nezajistí $m=n$. 
Lze říct, že paměť je efektivně využita? Existuje 
metoda, která by umožnila návrh perfektní hašovací 
funkce pro $m=n$? Z výsledků pro 
$(N,m,n)$-perfektní soubory funkcí plyne existence 
$(N,n,n)$-perfektního souboru pro $n^N>e^{n+ln(n)}\ln(N)$. 
Zmíníme se orientačně o parametrizované metodě, která 
navr\-huje perfektní hašovací funkci pro $S\subseteq U$ a pro 
$|S|=n$. Parametr bude přirozené číslo $r$, které určuje, 
jaké hypergrafy jsou užity při konstrukci funkce. Proto 
nejdříve připomeneme několik definic.

Dvojice $(X,E)$, kde $X$ je množina a $E$ je systém 
$r$-prvkových podmnožin $X$, se nazývá $r$-\emph{hypergraf}.  
Prvky v $E$ se nazývají \emph{hrany} $r$-hypergrafu.  
\emph{Cyklus} je hypergraf $(X,E)$, kde každý vrchol leží 
alespoň ve dvou různých hranách.  Naopak 
$r$-hypergraf $(X,E)$ se nazývá \emph{acyklický}, když 
žádný jeho podhypergraf není cyklus.  

Nyní popíšeme metodu, která je rozdělena do 
dvou kroků. Je dáno $S\subseteq U$ takové, že 
$|S|=n$.

Krok 1) Mějme $r$-hypergraf $(V,E)$, kde $|E|=n$.  Nalezneme 
zobrazení 
$$g:V\to \{0,1,\dots,n-1\}$$
takové, že funkce 
$h:E\to \{0,1,\dots,n-1\}$ definovaná $h(e)=\sum_{i=1}^rg(v_i)\bmod 
n$, 
kde $e=\{v_1,v_2,\dots,v_r\}$, je prostá (místo sčítání modulo $
n$ 
můžeme použít libovolnou grupovou operaci na 
množině $\{0,1,\dots,n-1\}$).  Pro acyklický $r$-hypergraf lze 
funkci $g$ zkonstruovat násle\-dujícím postupem.  Zvolíme 
bijekci $h:E\to \{0,1,\dots,n-1\}$ a pak definujeme $g$ 
následovně:  když $e=\{v_1,v_2,\dots,v_r\}$ a $g(v_i)$ je 
definováno pro $i=2,3,\dots,r$, pak 
$$g(v_1)=h(e)-\sum_{i=2}^rg(v_i)\bmod n.$$
Protože pro každý acyklický $r$-hypergraf existuje vrchol, který 
leží v jediné hraně, lze tento postup použít ke konstrukci $
g$ 
pomocí indukce (a tedy máme algoritmus pro konstrukci $g$).  

Krok 2) Nalezneme $r$ funkcí $f_1,f_2,\dots,f_r:U\to 
V$ takových, že 
$(V,E)$, kde 
$$E=\{\{f_1(x),f_2(x),\dots,f_r(x)\}\mid x\in S\},$$
 je acyklický 
$r$-hypergraf.  Pak hašovací funkce $f$ je definována 
$f(x)=\sum_{i=1}^rg(f_i(x))$ pro každé $x\in U$.  Z konstrukce 
vyplývá, že je perfektní na množině $S$.  

Autoři dokázali, že 
nejvhodnější alternativa je, když zobrazení $f_1
,f_2,\dots,f_r$ 
jsou náhodná zob\-razení náhodně zvolená. Bohu\-žel taková 
zobrazení neumíme zkonstruovat, ale autoři ukázali, že 
pro tyto účely lze použít náhodný výběr funkcí z 
nějakého $c$-univerzálního souboru funk\-cí. 

Autoři ukázali, že jejich algoritmus vyžaduje $
O(rn+|V|)$ 
času a $O(n\log n+r\log|V|)$ paměti. 

Tento metapostup navrhli Majewski, Wormald, Havas a Czech (1996).

Pro praktické použití je problematická 
reprezentace $r$-hyper\-gra\-fu a i náhodná volba funkcí 
$f_1,f_2,\dots,f_r$ (viz předchozí diskuze o $c$-univerzalitě).  Z 
požadavků na perfektní hašovací funkci je opět 
problémem splnění poža\-davku 4).  Nevím, jak je uvedená 
metoda prakticky pou\-ži\-telná a zda se někde používá.  

\subsection{Externí hašování}

Navržený postup je také znám pod názvem Faginův algoritmus. Tímto problémem se jako první asi zabýval Larsson.

Řešíme jiný problém -- uložení dat v externí 
paměťi. Hlavní problém -- minimalizovat přístupy na 
externí paměť. 

Předpoklady:  Ex\-ter\-ní pa\-měť je roz\-dě\-le\-na na 
strán\-ky, kaž\-dá strán\-ka ob\-sa\-hu\-je $b$ po\-lo\-žek (dat) 
(předpokládáme, že $b>1$, jinak to nemá smysl).  Vždy v 
jednom kroku načteme celou stránku do interní paměti 
nebo celou stránku v interní paměti v jednom kroku 
zapíšeme na externí medium.  Tyto operace jsou řádově 
pomalejší než operace v interní paměti.  

Podobný problém se také řeší pri práci s~cache-pamětí. V tom případě však 
neovlivňujeme, která stránka se bude načítat, kdežto v případě externí paměti to právě musíme řešit.

Náš cíl:  
Nalézt způsob ukládání dat do stránek externí 
paměti, aby se minimalizoval počet operací s~externí 
pamětí.  

Předpokládejme, že $h:U\to \{0,1\}^{*}$ je prosté 
zobrazení takové, že délka $h(u)$ je stejná pro všechny prvky 
univerza $U$.  Označme $k$ délku $h(u)$ pro $u\in U$. Pak $
h$ je 
hašovací funkce (to znamená, že hašovací funkce je přejmenování prvků).  Nechť $S\subseteq U$, pak pro slovo $
\alpha$ délky 
menší než $k$ definujme 
$$h^{-1}_S(\alpha )=\{s\in S\mid\alpha\text{\rm\ je prefix }h(s)\}
.$$
Řekneme, že $\alpha$ je \emph{kritické} \emph{slovo}, když 
$0<|h^{-1}_S(\alpha )|\le b$ a pro každý vlastní prefix $
\alpha'$ slova $\alpha$ platí 
$|h^{-1}_S(\alpha')|>b$.  Pro každé $s\in S$ existuje právě jedno 
kritické slovo $\alpha$, které je prefixem $h(s)$.  Definujme $
d(s)$ 
pro $s\in S$ jako délku kritického slova, které je prefixem 
$h(s)$ a 
$$d(S)=\max\{\text{\rm délka}(\alpha )\mid\alpha\text{\rm\ je kritické slovo}
\}=\max\{d(s)\mid s\in S\}.$$
Množinu $S$ reprezentujeme tak, že je jednoznačná 
korespondence mezi kritickými slovy a stránkami externí 
paměti slouží\-cí\-mi k reprezentaci $S$.  Na stránce 
příslušející kritickému slovu $\alpha$ je reprezentován soubor 
$h^{-1}_S(\alpha )$.  

Problém: jak nalézt stránku kritického slova 
$\alpha$?\newline 
Řešení: Adresář je funkce, která každému slovu $
\alpha$ o 
délce $d(S)$ přiřadí adresu stránky předpisem
\begin{enumerate}
\item když kritické slovo $\beta$ je prefixem $\alpha$, pak k $
\alpha$ je 
přiřazena strán\-ka korespondující s~$\beta$, jinak je k $
\alpha$ 
přiřazena strán\-ka $NIL$ -- speciální prázdná stránka.
\end{enumerate}

Korektnost: Pro různá kritická slova 
$\beta$ a $\gamma$ platí $h^{-1}_S(\beta )\cap h^{-1}_S(\gamma 
)=\emptyset$, a tedy pro každé slovo $\alpha$ 
délky $d(S)$ existuje nejvýše jedno kritické slovo, které 
je prefixem $\alpha$. Když $\alpha$ je slovo délky $d(S)$, pak nastane 
jeden z těchto tří případů:
\begin{enumerate}
\item
$h^{-1}_S(\alpha )\ne\emptyset$, pak $0<|h^{-1}_S(\alpha )|\le b$ a existuje právě jedno kritické slovo $
\beta$, 
které je prefixem $\alpha$; 
\item
$h^{-1}_S(\alpha )=\emptyset$ a existuje prefix $\alpha'$ slova $
\alpha$ takový, že 
$0<|h^{-1}_S(\alpha')|\le b$, pak existuje právě jedno kritické slovo, které je 
prefixem $\alpha'$ (a tedy také prefixem $\alpha$);
\item
$h^{-1}_S(\alpha )=\emptyset$ a pro každý prefix $\alpha'$ slova $
\alpha$ platí buď 
$h^{-1}_S(\alpha')=\emptyset$ nebo $|h^{-1}_S(\alpha')|>b$ (pak k $
\alpha$ je přiřazena 
stránka $NIL$).
\end{enumerate}

Mějme slovo $\alpha$ o délce $d(S)$. Označme $c
(\alpha )$ nejkratší 
prefix $\alpha'$ slova $\alpha$ takový, že každému slovu $\beta$ o délce $d(S)$, které má $\alpha'$ 
za prefix, je přiřazená stejná stránka jako slovu $\alpha$. Všimněme si, že když $h^{
-1}_S(\alpha )\ne\emptyset$, pak $c(\alpha )$ je 
kritické slovo. Platí silnější tvrzení, které tvrdí, že 
následující podmínky jsou ekvivalentní:
\begin{enumerate}
\item
stránka přiřazená slovu $\alpha$ je různá od $
NIL$;
\item
$c(\alpha )$ je kritické slovo;
\item
nějaký prefix $\alpha$ je kritické slovo.
\end{enumerate}
Všimněme si, že znalost adresáře umožňuje nalézt slovo 
$c(\alpha )$ pro každé slovo o délce $d(S)$.

Lineární uspořádání na slovech délky $
n$ nazveme 
\emph{lexikografické}, když $\alpha <\beta$, právě když 
$\alpha =\gamma 0\alpha'$ a $\beta =\gamma 1\beta'$ pro nějaká slova $
\gamma$, $\alpha'$ a $\beta'$. 
Lexikografické uspořádání vždy existuje a je 
jednoznačné.

Reprezentace adresáře: Je to seznam adres 
stránek o délce $2^{d(S)}$ takový, že adresa na $i$-tém místě 
odpovídá $i$-tému slovu délky $d(S)$ v lexikografickém 
uspořádání.

Příklad: $U$ je množina všech slov nad $\{
0,1\}$ o 
délce $5$, $h$ 
je identická funkce a $b=2$. Reprezentujme množinu  
$S=\{00000,\,00010,\,01000,\,10000\}$. Pak 
$d(00000)=d(00010)=d(01000)=2$, $d(10000)=1$, kritická slova 
jsou $00$, $01$ a $1$ a adresář je (místo adresy stránky 
uvedeme množinu, která je na této stránce uložena)
$$00\mapsto \{00000,00010\},\quad 01\mapsto \{01000\},\quad 10\mapsto 
11\mapsto \{10000\}.$$
Tedy $c(00)=00$, $c(01)=01$ a $c(10)=c(11)=1$.
Když odstraníme prvek $10000$, pak $1$ přestane být kritické 
slovo a adresář bude mít tvar
$$00\mapsto \{00000,00010\},\quad 01\mapsto \{01000\},\quad 10\mapsto 
11\mapsto NIL.$$
Opět platí $c(00)=00$, $c(01)=01$ a $c(10)=c(11)=1$.
V adresáři je také uloženo $d(S)$.

\subsubsection{Algoritmy}


Uvedeme zde jen slovní popis operací. Předpokládáme, že adresář 
je uložen v externí paměti na jedné stránce.

{\bf MEMBER$(x)$}\newline 
1) Spočítáme $h(x)$ a {\bf načteme} adresář do interní paměti. 
Vez\-me\-me prefix $\alpha$ slova $h(x)$ o délce $d(S)$ a nalezneme 
adresu stránky příslušející k $\alpha$. Když je to stránka 
$NIL$, pak $x\notin S$ a konec, jinak pokračujeme krokem 
2).\newline 
2) {\bf Načteme} stránku příslušející k $\alpha$ do interní 
paměti. Prohle\-dá\-me ji a pokud neobsahuje $x$, pak $x\notin 
S$ a 
konec. Když obsahuje $x$, pak provedeme požadované 
změny a stránku {\bf ulo\-ží\-me} do externí paměti na její 
původní místo. Konec.

{\bf INSERT$(x)$}\newline 
1) Spočítáme $h(x)$ a {\bf načteme} adresář do interní paměti. 
Vez\-me\-me prefix $\alpha$ slova $h(x)$ o délce $d(S)$ a nalezneme 
adresu stránky příslušející k $\alpha$ a slovo $
c(\alpha )$. 
Když stránka přiřazená k $\alpha$ je $NIL$, pokraču\-je\-me krokem 
3), v opačném případě pokraču\-je\-me krokem 2).\newline 
2) {\bf Načteme} stránku přiřazenou slovu $\alpha$. Když $
x$ je 
uloženo na této stránce, pak skončíme. Když $x$ není na 
této stránce, pak tam přidáme slovo $x$. Pokud na stránce 
je nejvýše $b$ prvků, pak {\bf uložíme} stránku 
na její původní místo a skončíme. Když na 
stránce je více než $b$ prvků, pak nalezneme nová 
kritická slova, 
která nám stránku rozdělí, a vytvoříme dvě stránky -- 
jednu {\bf uložíme} na místo původní stránky a 
druhou {\bf uložíme} na novou stránku. Pokračujeme krokem 
4).\newline 
3) Vytvoříme v interní paměti novou stránku, která 
obsahuje $x$, nalezneme novou stránku v externí paměti a 
tam {\bf uložíme} vytvořenou stránku (všem slovům, 
která mají $c(\alpha )$ za prefix, bude přiřazena tato stránka) a 
pokračujeme krokem 4).\newline 
4) {\bf Načteme} opět adresář do interní paměti, 
aktualizujeme adresy přiřazených stránek a případně 
zvětšíme adresář (to nastane, když nějaké nové kritické 
slovo má délku větší než $d(S)$, pak nové $d(S
)$ je právě 
délka tohoto slova -- obě kritická slova vzniklá v kroku 
2) mají stejnou délku). Aktualizovaný adresář {\bf uložíme} do 
externí paměti. Konec.

{\bf DELETE$(x)$}\newline 
1) Spočítáme $h(x)$ a {\bf načteme} adresář do interní paměti. 
Vez\-me\-me prefix $\alpha$ slova $h(x)$ o délce $d(S)$ a nalezneme 
adresu stránky příslušející k $\alpha$ a slovo $
c(\alpha )$. 
Když stránka přiřazená k $\alpha$ je $NIL$, pak skončíme. 
Označme $\beta'$ slovo, které má stejnou délku jako $c(\alpha 
)$ a 
liší se od $c(\alpha )$ pouze v posledním bitu. Když existuje 
slovo $\beta$ délky $d(S)$ takové, že $c(\beta )=\beta'$, pak stránka 
přiřazená k $\beta$ je \emph{kandidát}.\newline 
2) {\bf Načteme} stránku příslušnou k slovu $\alpha$ do interní 
paměti. Když tato stránka neobsahuje $x$, pak skončíme. 
Když tato stránka obsahuje $x$, pak odstraníme $x$ z této 
stránky. Když neexistuje kandidát nebo když nová 
stránka a stránka kandidáta dohromady obsahují více než $
b$ 
prvků, pak novou stránku {\bf ulo\-žíme} na její 
původní místo a skončíme. \newline 
3) Když nová stránka a stránka kandidáta mají 
dohromady $b$ prvků, pak {\bf načteme} stránku 
kandidáta do interní paměti. V interní paměti tyto 
stránky spojíme do jedné a tuto stránku pak 
{\bf ulo\-žíme} do externí paměti.\newline 
4) {\bf Načteme} adresář, kde zaktualizujeme adresy 
stránek. Po\-kud jsme sloučili dvě stránky, musíme nalézt 
nové $c(\alpha )$ (je to nejkratší prefix $\alpha'$ slova $
\alpha$ takový, že 
ke každému slovu $\beta$ o délce $d(S)$, které má $\alpha'$ za prefix, 
je přiřazena jedna z těchto adres: adresa stránky 
přiřazená k $\alpha$, adresa stránky kandidáta, $NIL$) a každému 
slovu o délce $d(S)$, které má nové $c(\alpha )$ za prefix, bude 
přiřazena adresa nové (spojené) stránky. Otestujeme, zda 
se adresář nemůže zkrátit (to nastane, když 
adresy stránek přiřazené $(2i+1)$-ímu slovu a $(2i+
2)$-ému 
slovu o délce $d(S)$ jsou stejné pro všechna $i$, 
pak se tato slova spojí a $d(S)$ se zmenší o $1$). Upravený 
adresář {\bf uložíme}. Konec.


Následující věta ukazuje, že jsme náš hlavní cíl splnili. Pro jednoduchost předpokládáme, že 
adresář je také uložen na externí paměti a že v 
interní paměti nemůže být uložen spolu s~nějakou jinou stránkou. 

\begin{veta}Operace {\bf MEMBER} vyžaduje nejvýše tři 
operace s~externí pamětí. Operace {\bf INSERT} a {\bf DELETE }
vyžadují nejvýše šest operací s~externí pamětí.
\end{veta}

V našem příkladu provedeme operaci 
{\bf INSERT$(00001)$}. Po přidání prvku stránka původně 
přiřazená k slovu $00$ vypadá takto $\{00000,00001,0001
0\}$. Tuto 
stránku rozdělíme na  
strán\-ky $\{00000,00001\}$ a $\{00010\}$. Přitom kritické slovo 
první strán\-ky je $0000$ a druhé strán\-ky je $0001$. Takže 
$d(S)=4$ a adresář vypadá 
\begin{align*}&0000\mapsto \{00000,00001\},0001\mapsto \{00010\},\\
&0010\mapsto 0011\mapsto NIL,\\
&0100\mapsto 0101\mapsto 0110\mapsto 0111\mapsto \{0100\},\\
&1000\mapsto 1001\mapsto 1010\mapsto 1011\mapsto \{10000\},\\
&1100\mapsto 1101\mapsto 1110\mapsto 1111\mapsto \{10000\}.\end{align*}
To znamená, že kromě adresy $00$ se ostatní slova rozdělila 
na čtyři slova, ale adresy zůstaly stejné. Jen u 
slova 00 vzniklá slova dostala různé adresy.

V původním příkladu 
provedeme operaci {\bf DELETE$(01000)$}. Pak kandidát je $00$ a po 
odstranění prvku $01000$ nastane spojení těchto dvou 
stránek. Po aktualizaci adres dostane adresář tvar
$$00\mapsto 01\mapsto \{00000,00010\},10\mapsto 11\mapsto \{10000
\},$$
tj. k prvnímu a druhému slovu je přiřazena stejná 
stránka a stejně tak k třetímu a čtvrtému slovu. Takže 
můžeme adresář zmenšit. Pak $d(S)=1$ a adresář má 
podobu  
$$0\mapsto \{00000,00010\},1\mapsto \{10000\}.$$

Vzniká otázka, jak je tato metoda efektivní. 
Hlavně jak efektivně využívá paměť. Platí

\begin{veta}Když velikost repre\-zentované množiny je $
n$, pak 
očekávaný počet použitých stránek je 
$\frac n{b\ln2}$ a očekáva\-ná velikost adresáře je $\frac 
e{b\ln2}n^{1+\frac 1b}$. 
\end{veta}

První tvrzení říká, že očekávaný počet 
prvků na stránce je $b\ln2\approx 0.69b$. Tedy zaplněno 
je asi 69\% míst. Tento výsledek není překvapující a je 
akceptovatelný. Horší je to s~adresářem, jak ukazuje 
následující tabulka

$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}velikost $S$ & $10^5$ & $10^6$ & $10^8$ & $10^{10}$ \hfill \cr\noalign{\hrule} 2 & $6.2\cdot10^7$ & $1.96\cdot10^8$ & $1.96\cdot10^{11}$ & $1.96\cdot10^{14}$ \cr\noalign{\hrule} $10$ & $1.2\cdot10^5$ & $1.5\cdot10^6$ & $2.4\cdot10^8$ & $3.9\cdot10^{10}$ \cr\noalign{\hrule} $50$ & $9.8\cdot10^3$ & $1.0\cdot10^6$ & $1.1\cdot10^8$ & $1.2\cdot10^{10}$ \cr\noalign{\hrule} $100$ & $4.4\cdot10^3$ & $4.5\cdot10^4$ & $4.7\cdot10^6$ & $4.9\cdot10^8$ \cr\noalign{\hrule}}}$$

kde jednotlivé řádky odpovídají hodnotám $
b$ 
uvedeným v prv\-ním sloupci. Protože očekávaná velikost 
adresáře se zvětšu\-je rychleji než lineárně (exponent u $
n$ je $1+\frac 1b$), 
tak nelze očekávat, že tuto metodu lze vždy použít. 
Výpočty i expe\-ri\-menty uka\-zu\-jí, že použitelná je do 
velikosti $|S|=10^{10}$, když $b\approx 100$. V tomto rozmezí je 
nárůst adresáře jen kolem 5\%. Pro větší $
n$ je 
třeba, aby $b$ bylo ještě větší.


\section{Stromy}

\subsection{Uspořádaný slovníkový problém}

Jedná se o rozšíření základního slovníkového problému. Je 
dáno totálně uspořádané univerzum $U$ (tj. pro každé dva 
různé prvky $u,v\in U$ platí buď $u<v$ nebo $v<
u$). Cílem 
je reprezentovat 
množinu $S\subseteq U$ a navrhnout algoritmy pro tyto operace:\newline 
{\bf MEMBER}, {\bf INSERT}, {\bf DELETE\newline 
MIN} -- nalezne nejmenší prvek v $S$,\newline 
{\bf MAX} -- nalezne největší prvek v $S$,\newline 
$\bold S\bold P\bold L\bold I\bold T(x)$ -- zkonstruuje reprezentace dvou množin 
$S_1=\{s\in S\mid s<x\}$ a $S_2=\{s\in S\mid s>x\}$ a oznámí, zda 
$x\in S$,\newline 
{\bf JOIN} -- používají se dvě verze této operace:\newline 
$\bold J\bold O\bold I\bold N\bold 2(S_1,S_2)$ -- jsou dány reprezentace množin $
S_1$ a $S_2$, které 
splňují $\max S_1<\min S_2$, vytvoří se reprezentace množiny 
$S=S_1\cup S_2$,\newline 
$\bold J\bold O\bold I\bold N\bold 3(S_1,x,S_2)$ -- jsou dány reprezentace množin $
S_1$ a $S_2$ a 
prvek $x\in U$ tak, že je splněno $\max S_1<x<\min S_2$, vytvoří 
se reprezentace množiny $S=S_1\cup \{x\}\cup S_2$.

Je vidět, že operace {\bf JOIN2} a {\bf JOIN3} lze pomocí ope\-rací 
{\bf INSERT} a {\bf DELETE} převést jednu na druhou. Proto často budeme 
popisovat pro danou strukturu jen jednu z nich. 
Občas se také používá operace\newline 
$\bold o\bold r\bold d(k)$ -- předpokádáme, že $k\le |S
|$, a operace nalezne $k$-tý 
nejmenší prvek v $S$.\newline 
Zřejmě operace {\bf MIN} a {\bf MAX} jsou speciálním případem 
ope\-race {\bf ord$(k)$}, 
přesně {\bf MIN} je operace $\bold o\bold r\bold d(1)$ a {\bf MAX} je operace $
\bold o\bold r\bold d(|S|)$.

\subsection{$(a,b)$-stromy}

Důležitou datovou strukturou vhodnou pro 
řešení uspořá\-dané\-ho slovní\-ko\-vé\-ho problému jsou 
$(a,b)$-stromy. Tuto datovou strukturu lze použít pro interní i 
pro externí paměť. Je to struktura založená na stromech. 
Nejobecnější grafová defini\-ce $(a,b)$-stromu je:\newline 
Nechť $1\le a<b$ jsou kladná přirozená čísla. Pak kořenový 
strom $(T,t)$ se nazývá $(a,b)$-\emph{strom}, když 
\begin{enumerate}
\item
když $v$ je vnitřní vrchol stromu $T$ různý od 
kořene $t$, pak má alespoň $a$ a nejvýše $b$ synů;
\item
všechny cesty z kořene do libovolného listu mají 
stejnou délku.
\end{enumerate}
Tato definice je příliš obecná a pro datové struktury se 
nehodí. Proto používáme její speciální případ. Datová 
struktura $(a,b)$-strom je definována jen na těchto stromech: 
Nechť $a$ a $b$ jsou přirozená čísla taková, že $
2\le a$ a 
$2a-1\le b$. Pak kořenový 
strom $(T,t)$ nazveme $(a,b)$-\emph{strom}, když platí 
\begin{enumerate}
\item
každý vnitřní vrchol $v$ stromu $T$ různý od 
kořene $t$ má alespoň $a$ a nejvýše $b$ synů;
\item
kořen je buď list nebo má alespoň dva syny a nejvýše $
b$ 
synů;
\item
všechny cesty z kořene do libovolného listu mají 
stejnou délku.
\end{enumerate}

Výhody našich $(a,b)$-stromů:\newline 
Když má $(a,b)$-strom \emph{výšku} $h>0$ (tj. délka každé 
cesty z kořene do libovolného listu je $h$), pak 
strom má alespoň $2a^{h-1}$ listů a nejvýše $b^
h$ 
listů.

\begin{tvrzeni}Mějme přirozená čísla $a$ a $
b$ taková, 
že $a\ge 2$ a $b\ge 2a-1$. Pak pro každé kladné přirozené 
číslo $n$ existuje $(a,b)$-strom, který má přesně $
n$ 
listů. Když $(a,b)$-strom má přesně $n$ 
listů, pak výška stromu je nejvýše $1+\log_a(\frac 
n2)$ a 
je alespoň $\log_bn$. Tedy výška stromu je $O(\log n)$.
\end{tvrzeni}

Mějme kořenový strom $(T,t)$ takový, že pro každý 
vnitřní vrchol $v$ platí:\newline 
když $v$ má $\rho (v)$ synů, pak jsou očíslovány od $
1$ do 
$\rho (v)$. Řekne\-me, že vrchol $v$ je v \emph{hloubce} $h$, když 
cesta z kořene $t$ do $v$ má délku $h$. Množina všech 
vrcholů v hloubce $h$ se nazývá $h$-\emph{tá} 
\emph{hladina}. \emph{Lexikografické} \emph{uspořádání} 
na $h$-té hladině je definováno rekurzivně:\newline 
\newline 
$v\le w$, právě když buď $\otec(v)<\otec(w)$ nebo 
$\otec(v)=\otec(w)$ a když $v$ je $i$-tý syn $\otec(v)$ a $w$ je 
$j$-tý syn $\otec(v),$ pak $i\le j$.  

Předpokládáme, že v $(a,b)$-stromu  
synové každého vnitřního vrcholu jsou uspořádány. Listy 
tvoří hladinu $h$, kde $h$ je hloub\-ka $(a,b)$-stromu, a je na nich 
definováno lexikografické uspořá\-dá\-ní.

Mějme lineárně uspořádané univerzum $U$ a 
množinu $S\subseteq U$.  Pak $(a,b)$-strom $(T,t)$ 
\emph{reprezentuje} množinu $S$, když má přesně $|S
|$ 
listů a je dán izomorfismus mezi lexikografickým uspořá\-dá\-ním 
listů stromu $T$ a uspořádanou množinou $S$ 
(tj.  bijekce $\key:\listop(T)\to S$, která pro $s,t\in S$ 
splňuje $s\le t$ v $U$, právě když $\key^{-1}(s)\le\key^{
-1}(t)$ v 
lexikografickém uspořádání na množině listů 
stromu $T$).  

Struktura vnitřních vrcholů 
$(a,b)$-stromu $(T,t)$ reprezentující\-ho množinu 
$S\subseteq U$:\newline 
$\rho (v)$ -- počet synů vrcholu $v$,\newline 
$S_v(1..\rho (v))$ -- pole ukazatelů na syny vrcholu $v$ takové, 
že $S_v(i)$ je $i$-tý syn vrcholu $v$ pro 
$i=1,2\dots,\rho (v)$,\newline 
$H_v(1..\rho (v)-1)$ -- pole prvků z $U$ takové, že $
H_v(i)$ 
je největší prvek z $S$ reprezentovaný v podstromu 
$i$-tého syna vrcholu $v$ (alternativa: $H_v(i)$ je prvek z $U$ 
takový, že největší prvek reprezentovaný v podstromu $
i$-tého 
syna vrcholu $v$ je menší nebo roven $H_v(i)$ a to je menší  
než nejmenší prvek reprezentovaný v podstromu $(i+1)$-ního 
syna vrcholu $v$).

Struktura listů:\newline 
listu $v$ je přiřazen prvek $\key(v)\in S$.

Někdy je ve struktuře každého vrcholu $v$ 
$(a,b)$-stromu různého od kořene ještě ukazatel 
$\otec(v)$ na otce vrcholu $v$.

Když $H_v(i)$ jsou prvky z reprezentované 
množiny, pak pro každý prvek $s\in S$ kromě největšího 
existuje právě jeden vnitř\-ní vrchol $v$ $(a,b)$-stromu 
a jedno $i$, že $H_v(i)=s$, a největší prvek v $S$ není prvek 
$H_v$ pro žádný vrchol $v$. Tento fakt se používá při 
implementaci, kde se vynechávají listy. Prvky z $S$ jsou 
reprezentovány v polích $H_v$ vnitř\-ních vrcholů 
stromu 
a největší prvek je uložen zvlášť nebo je k množině $S$ přidán 
formální největší prvek (a ten je pak "uložen" zvlášť). Je to prostorově 
efektivnější reprezentace množiny $S$, ale je technicky 
nepřehledná. Proto při práci s~$(a,b)$-stromy používám 
verzi s~listy.

Nyní uvedeme algoritmy pro $(a,b)$-stromy.

\subsubsection{Algoritmy}

Pomocný algoritmus

{\bf Vyhledej$(x)$\newline 
$t:=$}kořen stromu $T$, $w:=NIL$\newline 
{\bf while} $t$ není list {\bf do}\newline 
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $H_t(i)<x$ a $i<\rho (t)$ {\bf do} $i:=i+1$ {\bf enddo}\newline 
\phantom{---}{\bf if} $H_t(i)=x$ {\bf then} $w:=t$ {\bf endif}\newline 
$t:=S_t(i)$ {\bf enddo Výstup}: $t$ a $w$.

{\bf MEMBER$(x)$\newline 
Vyhledej$(x)$\newline 
if} $\key(t)=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $x\notin S$ {\bf endif

INSERT$(x)$\newline
Vyhledej$(x)$\newline 
if} $\key(t)\ne x$ {\bf then}\newline 
\phantom{---}vytvoř nový list $t'$, $\key(t'):=x$, $u:=\otec(t)$\newline 
\phantom{---}{\bf if} $\key(t)<x$ {\bf then}\newline 
(komentář: $x>\max S$)\newline 
\phantom{------}$S_u(\rho (u)+1):=t'$, $H_u(\rho (u)):=\key(t)$, $\rho (u):=\rho 
(u)+1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}najdi $i$, že $S_u(i)=t$\newline 
\phantom{------}$S_u(\rho (u)+1):=S(\rho (u))$, $j:=\rho (u)-1$\newline 
\phantom{------}{\bf while} $j\ge i$ {\bf do\newline 
\phantom{---------}$S_u(j+1):=S_u(j)$}, $H_u(j+1):=H_u(j)$, $j:=j-1$\newline 
\phantom{------}{\bf enddo\newline 
\phantom{------}$S_u(i):=t'$}, $H_u(i):=x$, $\rho (u):=\rho (u)+1$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$t:=u$\newline 
\phantom{---}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo\newline 
endif}

{\bf Štěpení$(t)$\newline 
if} $t$ je kořen stromu {\bf then}\newline 
\phantom{---}vytvoř nový kořen $u$ s~jediným synem $t$\newline 
{\bf endif}\newline 
$u:=\otec(t)$, najdi $i$, že $S_u(i)=t$,\newline 
vytvoř nový vnitřní vrchol $t'$, $j:=1$\newline 
{\bf while} $j<\lfloor\frac {b+1}2\rfloor$ {\bf do}\newline 
\phantom{---}$S_{t'}(j):=S_t(j+\lceil\frac {b+1}2\rceil )$, $H_{t'}(j):=H_t(j+\lceil\frac {b+1}2\rceil)$, $j:=j+1$\newline 
{\bf enddo\newline 
$S_{t'}(\lfloor\frac {b+1}2\rfloor ):=S_t(b+1)$}, $\rho (t):=\lceil\frac {
b+1}2\rceil$, $\rho (t'):=\lfloor\frac {b+1}2\rfloor$,\newline 
{\bf if} $i<\rho (u)$ {\bf then} $S_u(\rho (u)+1):=S_u(\rho (u))$ {\bf endif\newline}
$j:=\rho (u)-1$, $\rho (u):=\rho (u)+1$,\newline 
{\bf while} $j>i$ {\bf do}\newline 
\phantom{---}$S_u(j+1):=S_u(j)$, $H_u(j+1):=H_u(j)$, $j:=j-1$\newline 
{\bf enddo\newline 
$S_u(i+1):=t'$}, $H_u(i+1):=H_u(i)$, $H_u(i):=H_t(\rho (t))$, 
$t:=u$

{\bf DELETE$(x)$\newline 
Vyhledej$(x)$\newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}$u:=\otec(t)$, najdi $i$, že $S_u(i)=t$, a $j$, že $H_w(j)=x$, $k:=i$\newline 
\phantom{---}{\bf if} $w\ne u$ a $w\ne NIL$ {\bf then} $H_w(j):=H_u(\rho (u)-1)$ {\bf endif}\newline 
\phantom{---}{\bf while} $k<\rho (u)-1$ {\bf do}\newline 
\phantom{------}$H_u(k):=H_u(k+1)$, $S_u(k):=S_u(k+1)$, $k:=k+1$ \newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}{\bf if} $i\ne\rho(u)$ {\bf then} $S_u(\rho (u)-1):=S_u(\rho (u))$ {\bf endif}\newline
\phantom{---}$\rho (u):=\rho (u)-1$, odstraň $t$, $t:=u$ \newline 
\phantom{---}{\bf while} $\rho (t)<a$ a $t$ není kořen {\bf do}\newline 
\phantom{------}$y$ je bezprostřední bratr $t$\newline 
\phantom{------}{\bf if} $\rho (y)=a$ {\bf then Spojení$(t,y)$ else Přesun$
(t,y)$ endif}\newline 
\phantom{---}{\bf enddo\newline 
endif}

{\bf Spojení$(t,y)$\newline 
$u:=\otec(t)$}, najdi $i$, že $S_u(i)=t$, $j:=1$\newline 
{\bf if} $S_u(i-1)=y$ {\bf then} vyměň $t$ a $y$, $i:=i-1$ {\bf endif\newline 
while} $j<\rho (y)$ {\bf do}\newline 
\phantom{---}$S_t(\rho (t)+j):=S_y(j)$, $H_t(\rho (t)+j):=H_y(j)$, $j:=j+1$\newline 
{\bf enddo}\newline 
$H_t(\rho (t)):=H_u(i)$, $S_t(\rho (t)+\rho (y)):=S_y(\rho (y))$, $
\rho (t):=\rho (t)+\rho (y)$, odstraň $y$\newline 
{\bf while} $i<\rho (u)-1$ {\bf do}\newline 
\phantom{---}$S_u(i+1):=S_u(i+2)$, $H_u(i):=H_u(i+1)$, $i:=i+1$\newline 
{\bf enddo}\newline 
$\rho (u):=\rho (u)-1$\newline 
{\bf if} $u$ je kořen a $\rho (u)=1$ {\bf then}\newline 
\phantom{---}odstraň $u$\newline 
{\bf else}\newline 
\phantom{---}$t:=u$\newline 
{\bf endif}

{\bf Přesun$(t,y)$\newline 
$u:=\otec(t)$}, najdi $i$ takové, že $S_u(i)=t$\newline 
{\bf if} $S_u(i+1)=y$ {\bf then}\newline 
\phantom{---}$S_t(\rho (t)+1):=S_y(1)$, $H_t(\rho (t)):=H_u(i)$,\newline 
\phantom{---}$H_u(i):=H_y(1)$, $j:=1$\newline 
\phantom{---}{\bf while} $j<\rho (y)-1$ {\bf do}\newline 
\phantom{------}$S_y(j):=S_y(j+1)$, $H_y(j):=H_y(j+1)$, $j:=j+1$\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}$S_y(\rho (y)-1):=S_y(\rho (y))$, $\rho (t):=\rho (t)+1$, $\rho 
(y):=\rho (y)-1$\newline 
{\bf else}\newline
\phantom{---}$S_t(\rho (t)+1):=S_t(\rho (t))$, $j:=\rho (t)-1$\newline 
\phantom{---}{\bf while} $j>0$ {\bf do}\newline 
\phantom{------}$S_t(j+1):=S_t(j)$, $H_t(j+1):=H_t(j)$, $j:=j-1$\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}$\rho (t):=\rho (t)+1$, $S_t(1):=S_y(\rho (y))$, $H_t(1):=H_u(i-
1)$,\newline 
\phantom{---}$H_u(i-1):=H_y(\rho (y)-1)$, $\rho (y):=\rho (y)-1$\newline 
{\bf endif}

{\bf MIN\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list {\bf do} $t:=S_t(1)$ {\bf enddo}\newline 
$\key(t)$ je nejmenší prvek $S$

{\bf MAX\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list {\bf do} $t:=S_t(\rho (t))$ {\bf enddo}\newline 
$\key(t)$ je největší prvek $S$

{\bf JOIN2$(T_1,T_2)$}\newline
Předpoklad $T_i$ je $(a,b)$-strom reprezentující 
množinu $S_i$ pro $i=1,2$, které splňují $\max S_1<\min 
S_2$ 
(tento předpoklad je silnější než požadavek, že $
S_1$ a 
$S_2$ jsou disjunktní, ale algoritmus nekontroluje jeho splnění)\newline 
{\bf if} výška $T_1$ je větší nebo rovna výšce $T_2$ {\bf then}\newline 
\phantom{---}$t:=$kořen $T_1$, $k:=v(T_1)-v(T_2)$\newline 
\phantom{---}{\bf while} $k>0$ {\bf do} $t:=S_t(\rho (t))$, $k:=k-1$ {\bf enddo}\newline \phantom{---}{\bf Spojení$(t,$}kořen $T_2)$, $t:=\otec(t)$\newline 
\phantom{---}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo\newline 
else}\newline 
\phantom{---}$t:=$kořen $T_2$, $k:=v(T_2)-v(T_1)$ \newline 
\phantom{---}{\bf while} $k>0$ {\bf do} $t:=S_t(1)$, $k:=k-1$ {\bf enddo}\newline \phantom{---}{\bf Spojení$(t,$}kořen $T_1)$, $t:=\otec(t)$\newline 
\phantom{---}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo\newline 
endif}

{\bf SPLIT$(T,x)$\newline 
$Z_1$}, $Z_2$ prázdné zásobníky, $t:=$kořen $T$\newline 
{\bf while} $t$ není list {\bf do}\newline
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $H_t(i)<x$ a $i<\rho (t)$ {\bf do} $i:=i+1$ {\bf enddo}\newline \phantom{---}$t:=S_t(i)$\newline 
\phantom{---}{\bf if} $i=2$ {\bf then} vlož podstrom vrcholu $S_t(1)$ do $Z_1$ 
{\bf endif}\newline 
\phantom{---}{\bf if} $i>2$ {\bf then}\newline 
\phantom{------}vytvoř nový vrchol $t_1$, $\rho (t_1)=i-1$,\newline 
\phantom{------}{\bf for every} $j=1,2,\dots,i-2$ {\bf do}\newline 
\phantom{---------}$S_{t_1}(j):=S_t(j)$, $H_{t_1}(j):=H_t(j)$\newline 
\phantom{------}{\bf enddo}\newline 
\phantom{------}$S_{t_1}(i-1):=S_t(i-1)$, vlož podstrom vrcholu $t_1$ do $Z_1$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}{\bf if} $i=\rho (t)-1$ {\bf then}\newline 
\phantom{------}vlož podstrom $S_t(\rho (t))$ do $Z_2$ 
\phantom{---}{\bf endif}\newline 
\phantom{---}{\bf if} $i<\rho (t)-1$ {\bf then}\newline 
\phantom{------}vytvoř nový vrchol $t_2$, $\rho (t_2):=\rho (t)-i$\newline 
\phantom{------}{\bf for every} $j=1,2,\dots,\rho (t)-i-1$ {\bf do}\newline 
\phantom{---------}$S_{t_2}(j):=S_t(i+j)$, $H_{t_2}(j):=H_t(i+j)$\newline 
\phantom{------}{\bf enddo}\newline 
\phantom{------}$S_{t_2}(\rho (t)-i):=S_t(\rho (t))$, vlož podstrom $t_2$ do $Z_2$ \newline 
\phantom{---}{\bf endif\newline 
enddo\newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$\newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x\notin S$\newline 
\phantom{---}{\bf if} $\key(t)<x$ {\bf then}\newline 
\phantom{------}vlož podstrom vrcholu $t$ do $Z_1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}vlož podstrom vrcholu $t$ do $Z_2$\newline 
\phantom{---}{\bf endif\newline 
endif}\newline 
$T_1:=\text{ vrchol }Z_1$, odstraň $T_1$ ze $Z_1$\newline 
{\bf while} $Z_1\ne\emptyset$ {\bf do}\newline 
\phantom{---}$T':=$vrchol $Z_1$, odstraň $T'$ ze $Z_1$, $T_1:=${\bf JOIN}$(T',T_1)$\newline enddo\newline 
$T_2:=\text{ vrchol }Z_2$, odstraň $T_2$ ze $Z_2$\newline 
{\bf while} $Z_2\ne\emptyset$ {\bf do}\newline 
$T':=\text{ vrchol }Z_2$, odstraň $T'$ ze $Z_2$, $T_2:=${\bf JOIN$(T_2,T')$\newline 
enddo}

Poznámky k algoritmům. \newline 
Odkaz na otce vrcholu: buď je v každém vrcholu $v$ 
stromu $T$ přímo odkaz na $\otec(v)$, nebo se v proceduře 
{\bf Vyhledej} vkláda\-jí vrcholy do zásobníku a $\otec
(v)$ 
je vrchol v zásobníku před vrcholem $v$.

Při operaci {\bf SPLIT} se zásobníky používají 
jednoprůchodově -- nejprve se naplní a v této části 
algoritmu se nepoužije operace {\bf pop}, pak se vyprázdní a v této 
fázi se nepoužívá operace {\bf push}. V okamžiku, když jsou 
zásobníky naplněné, platí:
\begin{itemize}
\item
v zásobnících jsou uloženy $(a,b)$-stromy reprezentující 
podmnožiny $S$;
\item 
když $(a,b)$-stromy $T_i$ a $T_{i+1}$ reprezentují množiny $S_
i$ a $S_{i+1}$ a jsou v zá\-sobníku $Z_1$ (nebo $Z_2$) a strom $T_{i+1}$ následuje 
po stromu $T_{i}$, pak platí $\max S_i<\min S_{i+1}<x$ (nebo 
$\min S_i>\max S_{i+1}>x$) a výška $T_i$ je větší nebo 
rovna výšce $T_{i+1}$;
\item
když $T_i$ a $T_{i+1}$ jsou dva po sobě následující $
(a,b)$-stromy v 
zásobníku $Z_j$ pro $j=1,2$, které mají stejnou výšku, pak 
následující strom v zásobníku $Z_j$ má ostře menší výšku.
\end{itemize}

Toto plyne z první fáze algoritmu operace {\bf SPLIT} a zajišťuje 
korektnost druhé fáze algoritmu. 

Dále si všimněme, že podprocedury {\bf Štěpení}, {\bf Spojení} a {\bf Pře\-sun }
vyžadují čas $O(1)$, a proto algoritmy pro operace {\bf MEMBER}, 
{\bf INSERT}, {\bf DELETE}, {\bf MIN}, {\bf MAX}, {\bf JOIN2} a pro první fázi algoritmu 
{\bf SPLIT} vyžadují čas $O(1)$ pro práci v dané hladině.  Protože 
hladin je nejvýše $\log_a|S|$, můžeme shrnout: 

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, 
{\bf DE\-LETE}, {\bf MIN}, {\bf MAX}, {\bf JOIN2} a {\bf SPLIT} v $
(a,b)$-stromech vy\-žadují 
v nejhorším případě čas $O(\log_a|S|)$, kde $
S$ je 
re\-pre\-zen\-tovaná množina.  
\end{veta}

Je třeba ještě odhadnout spotřebovaný čas ve druhé fázi 
algoritmu pro operaci {\bf SPLIT}. Nejprve si všimněme, že 
algoritmus {\bf JOIN2$(T_1,T_2)$} vyžaduje ve skutečnosti jen čas 
rovný 
$O(\text{\rm rozdíl výšek stromů }T_1\text{\rm \ a }
T_2)$. Když po naplnění 
zásobník $Z_j$ pro $j=1,2$ obsahuje stromy $U_1,U_2,\dots,U_
k$ v tomto 
pořadí, pak $k\le 2\log_a|S|$ a vyprázdnění zásobníku $
Z_j$ 
vyžaduje 
čas $O(\sum_{i=1}^{k-1}(u_i-u_{i+1}+1)=O(u_1+k)$, kde $u_i$ je výška stromu $
U_i$ pro 
$i=1,2,\dots,k$. Protože výška stromu $U_1$ je nejvýše rovna výšce 
stromu $T$, dostáváme, že druhá fáze algoritmu {\bf SPLIT} vyžaduje 
čas $O(\log_a|S|)$ a důkaz je kompletní. 

Nyní popíšeme algoritmus pro operaci {\bf ord$
(k)$}. Tato 
operace se často nazývá $k$-tá pořádko\-vá statistika
Tato operace není podporována navrženou 
strukturou, pro její efektivní implementaci musíme 
rozšířit strukturu vnitřního vrcholu $v$ o pole\newline 
$P_v(1..\rho (v)-1)$, kde $P_v(i)$ je počet prvků $S$ reprezentovaných 
v podstromu $i$-tého syna vrcholu $v$.

 

Udržovat pole $P_v$ v aktuálním stavu znamená při úspěšném 
pro\-vedení aktualizační operace projít cestu z vrcholu do koře\-ne 
a aktualizovat pole $P$. Uvedeme algoritmus pro 
naleze\-ní $k$-té pořádkové statistiky.

{\bf ord$(k)$\newline 
if} $k>|S|$ {\bf then} neexistuje $k$-tý nejmenší prvek, konec 
{\bf endif\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list {\bf do}\newline 
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $k>P_t(i)$ a $i<\rho (t)$ {\bf do}\newline 
\phantom{------}$k:=k-P_t(i)$, $i:=i+1$\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}$t:=S_t(i)$\newline 
{\bf enddo}\newline 
$\key(t)$ je hledaný $k$-tý nejmenší prvek

Invariant algoritmu: V každém okamžiku platí, 
že původní $k$ se rovná aktuální $k+$počet prvků z 
$S$, které jsou v podstromech vrcholů stromu, které v 
lexikografickém uspořádání předcházejí $i$-tému synu 
vrcholu $t$. Korektnost algoritmu plyne z tohoto 
invariantu.

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, 
{\bf DE\-LETE}, {\bf MIN}, {\bf MAX}, {\bf SPLIT}, {\bf JOIN2} a {\bf ord$
(k)$} pro všechna $k$ v 
rozšířené struktuře $(a,b)$-stromu vy\-ža\-dují v 
nejhorším pří\-pa\-dě čas $O(\log|S|)$, kde $S$ je reprezentovaná 
množina.  
\end{veta}

$(a,b)$-stromy se používají jak v interní tak v 
externí paměti. Jaké hodnoty $a$ a $b$ je vhodné 
používat?\newline 
Pro interní paměť jsou doporučené hodnoty $a=2$, $
b=4$ 
nebo $a=3$ a $b=6$.\newline 
Pro externí paměť jsou doporučené hodnoty $a\approx 
100$, 
$b=2a$.

Když je množina reprezentovaná $(a,b)$-stromem 
uložena na serveru a má k ní přístup více 
uživatelů, vzniká problém s~aktualizačními 
operacemi. Tyto operace mění strukturu $(a,b)$-stromu a 
v důsledku toho se v něm jiný uživatel 
může ztratit. Tento problém se dá  
řešit tak, že při aktu\-alizačních operacích 
se uzavře celý strom.

 

Nevýhoda: ostatní uživatelé  
do něho nemají přístup a nemohou pracovat. Tzv. paralelní 
implementace operací {\bf INSERT} a {\bf DELETE} nabízí jiné, 
efektivnější řešení.

Předpoklad: $b\ge 2a$. \newline 
Při operaci {\bf INSERT} jsou ve vyhledávací fázi vždy 
uzavřeny vrcholy $t$, $\otec(t)$ a synové vrcholu $t$. 
Algoritmus zjistí, ve kterém synu vrcholu $t$ má 
pokračovat, a pak, když $\rho (t)=b$, provede {\bf Štěpení }
(proto je nutně $b\ge 2a$, abychom po této ope\-raci měli 
zase $(a,b)$-strom). V algoritmu pak odpadne vyva\-žo\-vací 
část (tj. {\bf Štěpení} při cestě vzhůru ke 
kořeni).

Při operaci {\bf DELETE} jsou ve vyhledávací fázi uzavřeny 
vrcholy $t$, $\otec(t)$, bezprostřední bratr $y$ vrcholu $
t$ a 
jejich synové. 
Když $\rho (t)=a$, pak po najiti vrcholu, kde se bude 
pokračovat, se provede buď {\bf Přesun} (když $\rho (
y)>a$) nebo 
{\bf Spojení} (když $\rho (y)=a$). Stejně jako při operaci 
{\bf INSERT} se vynechá vyva\-žo\-vací část 
uzavírající původní algoritmus.

Tato úprava vyžaduje sice více {\bf Štěpení}, {\bf Spojení} a
{\bf Přesunů}, ale asymptoticky vychází čas stejný 
(jen je větší multiplikativní konstanta). Doporučené 
hodnoty $a$ a $b$ jsou $a\approx 100$ a $b=2a+2$ při uložení na serveru 
v externí paměti, ve vnitřní paměti 
se doporučuje $a=2$, $b=6$.

Operace {\bf JOIN2} lze také paralelizovat, ale operaci {\bf SPLIT  }
paralelizovat nelze.

$(a,b)$-stromy dávají také zajímavé aplikace pro 
třídicí 
algoritmy. Použití $(a,b)$-stromů pro setřídění 
náhodné posloupnosti není vhodné, režie na udržování 
struktury $(a,b)$-stromu vede k tomu, že multiplikativní 
konstanta by byla o hodně větší než u klasických 
třídicích algoritmů. Také uložení $(
a,b)$-stromu 
vyžaduje více paměti než je potřeba pro klasické 
algoritmy. Situace se podstatně změní, když vstupní 
posloupnost je před\-tří\-děná a je ji třeba jen dotřídit. 
Klasické algoritmy většinou nejsou schopné využít faktu, že 
posloupnost je předtříděná, a jejich časová náročnost je 
prakticky stejná (někdy i horší) jako u náhodné 
posloupnosti. Na rozdíl od nich algoritmus $A$-{\bf sort }
založený na $(a,b)$-stromech je schopen předtříděnost 
využít a má na předtříděných posloupnostech lepší 
výsledky než klasické algoritmy.

Modifikace $(a,b)$-stromů pro algoritmus 
$A$-{\bf sort}. Máme $(a,b)$-strom reprezentující vstupní 
posloupnost, je dán ukazatel $\Prv$ na první list, listy 
$(a,b)$-stromu jsou propojeny do seznamu v rostoucím 
lexikografickém pořadí (ukazatel na následující prvek je 
$\Nasl$) a je dána cesta z prvního listu do kořene (to 
znamená, že na cestě z prvního listu do kořene známe 
pro každý vrchol $v$ jeho otce). Nyní uvedeme algoritmus 
$A$-{\bf sort}. 

$A$-{\bf sort$(x_1,x_2,\dots,x_n)$\newline 
$i:=n-1$}, vytvoř jednoprvkovy strom s~vrcholem $t$\newline 
$\key(t):=x_n$, $\Prv:=t$\newline 
{\bf while} $i\ge 1$ {\bf do $A$-Insert$(x_i)$}, $i:=i-1$ {\bf enddo}\newline 
$y_1:=\key(\Prv)$\newline 
{\bf while} $i\le n$ {\bf do\newline 
\phantom{---}$y_i:=\key(t)$}, $i:=i+1$, $t:=\Nasl(t)$\newline 
{\bf enddo\newline 
Výstup}: $(y_1,y_2,\dots,y_n)$ setříděná posloupnost $
(x_1,x_2,\dots,x_n)$

$A$-{\bf Insert$(x)$\newline 
$t:=\Prv$\newline
while} $t\ne\text{\rm kořen }T$ a $H_t(1)<x$ {\bf do $t:=\otec(t)$ enddo\newline 
while} $t\ne\text{\rm list}$ {\bf do}\newline 
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $H_t(i)<x$ a $i<\rho (t)$ {\bf do} $i:=i+1$ {\bf enddo}\newline 
\phantom{---}{\bf if} $i>1$ {\bf then} $v:=S_t(i-1)$ {\bf else} $v:=S_t(\rho (t))$ {\bf endif}\newline 
\phantom{---}$t:=S_t(i)$\newline 
{\bf enddo\newline 
if} $\key(t)\ne x$ {\bf then\newline }
\phantom{---}vytvoř nový list $t'$, $\key(t')=x$,\newline
\phantom{---}{\bf if} $t$ je kořen {\bf then}\newline 
\phantom{------}vytvoř nový kořen $u$, $\rho (u):=2$\newline 
\phantom{------}{\bf if} $\key(t)>x$ {\bf then}\newline 
\phantom{---------}$H_u(1):=x,$ $S_u(1):=t'$, $S_u(2):=t$,\newline
\phantom{---------}$\Prv:=t'$, $\Nasl(t'):=t$, $\Nasl(t):=NIL$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$H_u(1):=\key(t)$, $S_u(1):=t$, $S_u(2):=t'$\newline
\phantom{---------}$\Prv:=t$, $\Nasl(t):=t'$, $\Nasl(t'):=NIL$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\otec(t)$\newline 
\phantom{------}{\bf if} $\key(t)<x$ {\bf then}\newline  
(komentář: $x>\max S$)\newline 
\phantom{---------}$S_u(\rho (u)+1):=t'$, $H_u(\rho(u)):=\key(t)$, $\rho(u):=\rho(u)+1$\newline 
\phantom{---------}$\Nasl(t):=t'$, $\Nasl(t'):=NIL$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}najdi $i$, že $S_u(i)=t$, $S_u(\rho(u)+1):=S(\rho(u))$,\newline 
\phantom{---------}$j:=\rho (u)-1$, $\Nasl(v):=t'$, $\Nasl(t'):=t$\newline 
\phantom{---------}{\bf while} $j\ge i$ {\bf do\newline 
\phantom{------------}$S_u(j+1):=S_u(j)$}, $H_u(j+1):=H_u(j)$, $j:=j-1$\newline 
\phantom{---------}{\bf enddo}\newline 
\phantom{---------}$S_u(i):=t'$, $H_u(i):=x$, $\rho (u):=\rho (u)+1$,\newline 
\phantom{---------}{\bf if} $t=\Prv$ {\bf then} $\Prv:=t'$ {\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$t:=u$\newline 
\phantom{------}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo}\newline 
\phantom{---}{\bf endif\newline 
endif}

Korektnost algoritmu plyne z faktu, že $\key$ je 
izomorfismus uspo\-řá\-dání a seznam listů je v 
rostoucím pořadí. Protože $v$ je vždy bez\-prost\-řední 
předchůdce $t$, je seznam korektně definován. 
U\-ka\-zatel $\otec(t)$ je dán na cestě z vrcholu $\Prv$ do 
kořene, pro ostatní vrcholy se řeší stejným 
způsobem jako pro $(a,b)$-stromy.

Složitost algoritmu: Algoritmus $A$-{\bf sort} vyžaduje více 
času i více paměti než klasické třídicí algoritmy, ale jejich 
asymptotická složitost je stejná. Jeho výhoda je v použití 
na před\-tří\-děné posloupnosti. Mějme posloupnost $
(x_1,x_2,\dots,x_n)$ 
prvků z to\-tálně uspořádaného univerza $U$ a definujme 
$$F=|\{(i,j)\mid i<j,\,x_j<x_i\}|.$$
Zřejmě $F=0$, právě když posloupnost 
$(x_1,x_2,\dots,x_n)$ je setří\-děná. Dále $0\le F\le\binom 
n2$ a $F=\binom n2$, právě 
když je posloupnost $(x_1,x_2,\dots,x_n)$ klesající. To vede k tomu 
brát $F$ jako míru předtříděnosti posloupnosti. Spočítáme 
složitost algoritmu $A$-{\bf sort} v závislosti na $n$ a $F$

Zřejmě algoritmus $A$-{\bf sort v} nejhorším případě vyžaduje čas, 
který potřebuje $A$-{\bf Insert}, plus $O(n)$.  Algoritmus $
A$-{\bf Insert$(x)$ }
vyžaduje čas potřebný na nalezení místa, kam vložit $
x$, plus 
$O(\text{\rm počet volání {\bf Štěpení}})$.  Protože každý běh procedury 
{\bf Ště\-pení} vytvořil jeden vnitřní vrchol $
(a,b)$-stromu a protože $a\ge 2$ 
a $(a,b)$-strom po skončení volání $A$-{\bf Insert} má $
n$ listů, 
je vnitřních vrcholů $(a,b)$-stromu $<n$.  Proto všechny 
běhy procedury $A$-{\bf Insert} vyžadují čas na nalezení míst 
jednotlivých prvků plus $O(n)$.  Když procedura 
$A$-{\bf Insert$(x)$} při hledání místa pro prvek $x$ skončila ve výšce $
h$ 
(tj.  první cyklus se $h$-krát opakoval), pak nalezení místa pro 
prvek $x$ vyžadovalo čas $O(h)$.  Všechny prvky reprezentované 
$(a,b)$-stromem pod prvním vrcholem ve výšce $h-1$ jsou menší 
než $x$ a je jich alespoň $a^{h-1}$.  Když $x=x_i$, pak počet 
prvků reprezentovaných $(a,b)$-stromem při běhu 
procedury $A$-{\bf Insert$(x)$}, které jsou menší než $
x$, je počet $j$ takových, že $i<j$ a $x_j<x_i$.
Označme $f_i$ tento počet. Pak platí 
$$a^{h-1}\le f_i\implies h-1\le\log_af_i\implies h\in O(\log f_i).$$

Proto v nejhorším případě čas potřebný pro nalezení 
pozice $x_i$ je $O(\log f_i)$. Odtud plyne, že čas algoritmu potřebný k 
běhu algoritmu $A$-{\bf sort} je 
$$O((\sum_{i=1}^n\log f_i)+n).$$

Zřejmě $\sum_{i=1}^nf_i=F$ a nyní využijeme toho, že geometrický 
průměr je vždy menší nebo roven aritmetickému 
průměru, a odtud dostáváme 
\begin{align*}\sum_{i=1}^n\log f_i=&\log\prod_{i=1}^nf_i=n\log(\prod_{i
=1}^nf_i)^{\frac 1n}\le\\
&n\log\frac {\sum_{i=1}^nf_i}n=n\log\frac Fn.\end{align*}

\begin{veta}Algoritmus $A$-{\bf sort} na setřídění $
n$-členné 
posloupnosti vyžaduje v nejhorším případě čas 
$O(n+n\log\frac Fn)$, kde $F$ je míra setříděnosti vstupní 
posloupnosti.
\end{veta}

Zhodnocení: Protože $A$-{\bf sort} nepoužívá operaci 
{\bf DELETE}, doporučuje se použít $(2,3)$-stromy. Když se 
budou třídit posloupnosti s~mírou $F\le n\log n$, pak 
algoritmus $A$-{\bf sort} bude potře\-bo\-vat v nejhorším případě 
čas $O(n\log\log n)$. Mehlhorn a Tsa\-kalidis dokázali, že když 
$F\le 0.02n^{1.57}$, pak algoritmus $A$-{\bf sort} je rychlejší než 
algoritmus {\bf Quicksort}.

\subsubsection{Propojené stromy s~prstem}

\emph{Hladinově} \emph{propojený} $(a,b)$-\emph{strom} \emph{s} 
\emph{prstem} je $(a,b)$-strom, kde struktura vnitřního 
vrcholu různého od kořene je 
rozšířena (proti klasickému $(a,b)$-stromu) o 
ukazatele:\newline 
$\otec(v)$, $\levy(v)$, $\pravy(v)$, kde\newline 
$\levy(v)$ ukazuje na největší vrchol (v lexikografic\-kém 
uspořá\-dá\-ní) ve stejné hladině jako $v$, který je menší než 
$v$ (když neexistuje, tak je to $NIL$),\newline 
$\pravy(v)$ ukazuje na nejmenší vrchol (v lexikografic\-kém 
uspořá\-dá\-ní) ve stejné hladině jako $v$, který je větší než 
$v$ (když ne\-existuje, tak je to $NIL$).\newline 
Navíc je dán ukazatel 
$\Prst$ na některý list. 

Zde se liší hlavně vyhledávání, které je zobecněním 
postupu $A$-{\bf sortu}. Začínáme od listu $p$, na který ukazuje 
$\Prst$. Když $x$ je menší než prvek reprezentovaný tímto 
listem, pak se pokračuje v jeho otci $v$, a když $p$ 
byl $i$-tý syn $v$, tak se pomocí pole $H_v$ zjišťuje, zda $
x$ 
nemá být reprezentován v podstromu jeho $j$-tého syna pro 
$j<i$. Když ne, pokračuje se  ukazatelem $\levy(v)$. 
Když $x$ není reprezentován ani v jeho podstromu, 
tak se celý postup opakuje o hladinu výš (zkoumá se otec vrcholu). 
Když $x$ je větší než prvek reprezentovaný listem $
p$, 
je postup zrcadlově obrácený. Když se nalezne 
vrchol, v jehož podstromu má $x$ ležet, pak se aplikuje od 
tohoto vrcholu (místo od kořene) procedura {\bf Vyhledej}.



Struktura kromě operací uspořádaného 
slovníkového prob\-lé\-mu 
ještě používá přidanou ope\-raci {\bf PRST$(x)$}, která nastaví ukazatel 
$\Prst$ na list, který reprezentuje nejmenší prvek větší 
nebo rovný $x$ (pokud $x>\max S$, tak ukazatel $\Prst$ bude 
ukazovat na největší list). Operace provedou vyhledání a 
pak pokračují klasickým způsobem.

Použití: Tato struktura je velmi výhodná pro 
úlohy, kde vždy skupina po sobě jdoucích ope\-rací  
pracuje v blízkém okolí něja\-ké\-ho $x\in U$. Pak 
vyhledání prvku je rychlejší než v klasickém 
$(a,b)$-stromu, viz $A$-{\bf sort}.

Vyvažovací operace {\bf Štěpení, Spojování, Přesun }
vyžadují čas $O(1)$, ale ve skutečnosti jsou nejpomalejší 
částí 
algoritmů pro operace {\bf INSERT} a {\bf DELETE}.  Omezení 
jejich počtu vedlo k menší složitosti algoritmu $A$-{\bf sort}.  To motivovalo analýzu 
jejich použití.\newline 
Libovolný běh algoritmu {\bf INSERT }
volá podproceduru {\bf Štěpe\-ní} nejvýše $\log(|
S|)$-krát a libovolný běh 
algoritmu  {\bf DELETE} mů\-že nejvýše $\log(|S|
)$-krát zavolat podproceduru 
{\bf Spojení }
a nejvýše jednou podproceduru {\bf Přesun}.  V obecném 
případě tyto od\-ha\-dy nejdou zlepšit.  Pro vhodný typ 
$(a,b)$-stromu však amortizovaný počet vyvažovacích 
ope\-rací (začínáme-li s~ 
pů\-vod\-ně práz\-dným stromem) je konstantní.

Pro pevné $a$ a $b$ označme 
$$c=\min\{\min\{2a-1,\lceil\frac {b+1}2\rceil \}-a,b-\max\{2a-1,\lfloor\frac {
b+1}2\rfloor \}\}.$$
Připomínáme, že \emph{výška} \emph{vrcholu} v kořenovém stromě je 
maximální délka cesty z něho do některého listu.

\begin{veta}Nechť $b\ge 2a$ a $a\ge 2$. Nechť $\mathcal P$ je 
posloupnost $n$ operací {\bf INSERT} a {\bf DELETE}, aplikujme ji na 
prázdný $(a,b)$-strom. Označme\newline 
$St_h$ -- počet {\bf Štěpení} ve výšce $h$ při aplikaci $
\mathcal P$, $St=\sum_hSt_h$;\newline 
$Sp_h$-- počet {\bf Spojení} ve výšce $h$ při aplikaci $
\mathcal P$, 
$Sp=\sum_hSp_h$;\newline 
$P_h$ -- počet {\bf Přesunů} ve výšce $h$ při aplikaci $
\mathcal P$, 
$P=\sum_hP_h$.\newline 
Pak platí
\begin{enumerate}
\item
$$P\le n\quad \text{\rm a}\quad (2c-1)St+cSp\le n+c+\frac {c(n-2)}{a+c-1};$$
\item
$$St_h+Sp_h+P_h\le\frac {2(c+2)n}{(c+1)^h}.$$
\end{enumerate}
\end{veta}

Z definice plyne, že $c\ge 1$, a protože $a\ge 2$, z 1) dostaneme
$$St+Sp\le\frac nc+1+\frac {n-2}a\le n+1+\frac {n-2}2\le\frac {3n}
2.$$
Amortizovaný počet vyvažovacích operací splňuje tedy 
$$\frac {P+St+Sp}n\le\frac 52.$$

Důkaz je založen na bankovním principu -- 
navrhneme kvantitativní ohodnocení $(a,b)$-stromu, 
nalezneme jeho horní odhad a popíšeme, jak 
toto ohodnocení mohou změnit vyvažo\-vací ope\-race. Srovnání 
těchto odhadů dá požadovaný výsledek.

Mějme $(a,b)$-strom $T$, pro vnitřní vrchol 
$v$ různý od kořene definuj\-me 
$b(v)=\min\{\rho (v)-a,b-\rho (v),c\}$, pro 
kořen $r$ definuj\-me $b(r)=\min\{\rho (r)-2,b-\rho (r),c\}$. 

\begin{pozorovani}Pro vnitřní vrchol stromu $v$  
různý od kořene platí
\begin{enumerate}
\item
$b(v)\le c$;
\item
když $\rho (v)=a$ nebo $\rho (v)=b$, pak $b(v)=0$;
\item
když $\rho (v)=a-1$ nebo $\rho (v)=b+1$, pak $b(v)=-1$;
\item
když $\rho (v)=2a-1$, pak $b(v)=c$;
\item
Když $v'$ a $v^{\prime\prime}$ jsou dva různé vrcholy stromu 
různé od kořene takové, že $\rho (v')=\lceil\frac {
b+1}2\rceil$ a 
$\rho (v^{\prime\prime})=\lfloor\frac {b+1}2\rfloor$, pak $b(v')+
b(v^{\prime\prime})\ge 2c-1$;
\item
pro kořen $r$ platí $b(r)\le c$.
\end{enumerate}
\end{pozorovani}

Strom $(T,r)$ ohodnotíme 
\begin{align*} b_h(T)=&\sum \{b(v)\mid v\ne r\text{\rm\ vnitřní vrchol stromu }\text{\rm\ ve výšce }
h\}\\
b(T)=&\sum_{h=1}^{\infty}b_h(T)+b(r).\end{align*}
Řekneme, že $(T,r,v)$ je \emph{parciální} 
$(a,b)$-\emph{strom}, když $r$ je kořen stromu, $v$ je vnitřní 
vrchol $T$ a platí:
\begin{itemize}
\item
když $v\ne r$, pak $a-1\le\rho (v)\le b+1$ a $2\le\rho (r)\le 
b$;
\item
když $v=r$, pak $2\le\rho (r)\le b+1$;
\item
když $t$ je vnitřní vrchol $T$ různý od $v$ a $
r$, pak 
$$a\le\rho (t)\le b;$$
\item
všechny cesty z kořene $r$ do nějakého listu mají stejnou 
délku.
\end{itemize}

Nyní rozložíme operace {\bf INSERT} a {\bf DELETE} do 
jednotlivých akcí se stromem a vyšetří\-me vliv těchto 
akcí na jeho ohodnocení. Důkazy lemmat jsou 
založené na následujícím pozorování

\begin{pozorovani}Mějme dva stromy $T$ a $T'$, které mají 
stejnou množinu vrcholů ve výšce $h$. Pak platí:
\begin{enumerate}
\item
když každý vrchol ve výšce $h$ má stejný počet synů 
v obou stromech, pak $b_h(T)=b_h(T')$;
\item
když všechny vrcholy ve výšce $h$ až na jeden vrchol mají stejný 
počet synů v obou stromech a počet synů u zby\-lé\-ho vrcholu se ve stromech $
T$ a $T'$ liší nejvýše o $1$, pak $b_h(T)\ge b_h(T')-
1$.
\end{enumerate}
\end{pozorovani}

\begin{lemma_counting}Když $(T,r)$ je $(a,b)$-strom a když strom $
T'$ 
vznikne z $T$ přidáním/ubráním jednoho syna vrcholu $
v$ 
ve výšce $1$ (tj. přidávaný/ubíraný syn je list), pak 
$(T',r,v)$ je parciální $(a,b)$-strom a platí 
\begin{align*} b_1(T')\ge&b_1(T)-1\quad\text{\rm a }b_h(T')=b_h(T)\text{\rm\ pro }
h>1;\\
b(T')\ge&b(T)-1.\end{align*}
\end{lemma_counting}

\begin{lemma_counting}Nechť $(T,r,v)$ je parciální $(a,b)$-strom, 
$\rho (v)=b+1$ a $v$ je ve výšce $l\ge 1$. Když $T'$ vznikne z $
T$ 
operací {\bf Štěpení$(v)$}, pak $(T',r,\otec(v))$ je parciální 
$(a,b)$-strom a platí:  
\begin{align*} b_l(T')\ge&b_l(T)+2c,\text{\rm\ }b_{l+1}(T')\ge b_{l+1}(
T)-1\\
b_h(T')=&b_h(T)\text{\rm\ pro }h\ne l,l+1;\quad b(T')\ge b(T)+2c-
1.\end{align*}
\end{lemma_counting}

\begin{lemma_counting}Nechť $(T,r,v)$ je parciální $(a,b)$-strom, 
$\rho (v)=a-1$, $v$ je ve výšce $l\ge 1$ a $y$ je bezprostřední bratr $v$ takový že $\rho(y)=a$. Když $T'$ vznikne z $T$ operací {\bf Spojení$(v,y)$}, pak $(T',r,\otec(v))$ je parciální $(a,b)$-strom a 
platí:  
\begin{align*} b_l(T')\ge&b_l(T)+c+1,\text{\rm\ }b_{l+1}(T')\ge b_{l+1}
(T)-1\\
b_h(T')=&b_h(T)\text{\rm\ pro }h\ne l,l+1;\quad b(T')\ge b(T)+c.\end{align*}
\end{lemma_counting}

\begin{lemma_counting} Nechť $(T,r,v)$ je parciální $(a,b)$-strom, 
$\rho (v)=a-1$, $v$ je výšce $l\ge 1$ a $y$ je bezprostřední bratr $v$ takový, že $\rho(y)>a$. 
Když $T'$ vznikne z $T$ operací {\bf Přesun$(v,y)$}, 
pak $(T',r)$ je $(a,b)$-strom a platí:  
$$b_l(T')\ge b_l(T)\text{\rm\ a }b_h(T')=b_h(T)\text{\rm\ pro }h\ne 
l;\quad b(T')\ge b(T).$$
\end{lemma_counting}

Označme $T_k$ $(a,b)$-strom vzniklý provedením posloupnosti 
$\mathcal P$ na prázdný $(a,b)$-strom. Sečtením předchozích 
výsledků dostá\-váme

\begin{dusledek_counting}Když položíme 
\begin{gather*} St_0+Sp_0=\text{\rm počet listů v }T_k\le n
,\quad\text{\rm pak}\\
b_h(T_k)\ge 2cSt_h+(c+1)Sp_h-St_{h-1}-Sp_{h-1}\text{\rm\ pro }h\ge 
1.\end{gather*}
Dále $b(T_k)\ge (2c-1)St+cSp-n$, kde $n$ je délka posloupnosti $
\mathcal P$.
\end{dusledek_counting}

První výraz upravíme (využíváme, že $
c\ge 1$):
\begin{align*} St_h+Sp_h\le&\frac {b_h(T_k)}{c+1}+\frac {St_{h-1}+Sp_{h
-1}}{c+1}\le\\
&\frac {b_h(T_k)}{c+1}+\frac {b_{h-1}(T_k)}{(c+1)^2}+\frac {St_{h
-2}+Sp_{h-2}}{(c+1)^2}\le\dots\le\\
&\sum_{i=0}^{h-1}\frac {b_{h-i}(T_k)}{(c+1)^{i+1}}+\frac n{(c+1)^
h}=\\
&\frac n{(c+1)^h}+\sum_{l=1}^hb_l(T_k)\frac {(c+1)^l}{(c+1)^{h+1}}
.\end{align*}

Nyní odhadneme shora $b(T_k)$.

\begin{lemma_counting}Když $T$ je $(a,b)$-strom s~$m$ listy, pak 
$0\le b(T)\le c+(m-2)\frac c{a+c-1}$.
\end{lemma_counting}

\begin{proof}Pro $0\le j<c$ označme $m_j$ počet 
vnitřních vrcholů různých od kořene, 
které mají přesně $a+j$ synů, a $m_c$ označme 
počet vnitřních vrcholů různých od 
kořene, které mají alespoň $a+c$ synů. Když 
vrchol $v$ má $a+j$ synů, pak $b_T(v)\le j$ a pro 
každý vnitřní vrchol $v$ platí $b_T(v)\le c$. Tedy 
$b(T)\le c+\sum_{j=0}^cjm_j$. Z vlastností stromů plyne 
\begin{align*}2+\sum_{j=0}^c(a+j)m_j\le&\sum \{\rho (v)\mid v\text{\rm\ je vnitřní vrchol }
T\}=\\
&m+\sum_{j=0}^cm_j.\end{align*}
Odtud plyne
$$\sum_{j=0}^c(a+j-1)m_j\le m-2.$$
Protože $\frac j{a+j-1}\le\frac c{a+c-1}$ pro každé $j$ takové, že $
0\le j\le c$, 
dostáváme
\begin{align*} b(T)\le&c+\sum_{j=0}^cjm_j=c+\sum_{j=0}^c\frac j{a+j-1}(
a+j-1)m_j\le\\
&c+\frac c{a+c-1}(m-2)\end{align*}
a lemma je dokázáno.
\end{proof}

Nyní dokážeme tvrzení (1) Věty. Protože každá operace 
{\bf DE\-LETE} použije nejvýše jednu operaci {\bf Přesun} (a operace 
{\bf INSERT} operaci {\bf Přesun} nepoužívá) dostáváme, že 
$$P\le\text{\rm počet operací {\bf DELETE}}\le n$$
a první nerovnost platí. 
Abychom dokázali druhou nerovnost, spojíme druhé 
tvrzení v Důsledku 5 a Lemma 6 ($T_k$ má nejvýše 
$n$ listů) 
$$(2c-1)St+cSp-n\le b(T_k)\le c+(n-2)\frac c{a+c-1}$$
Odtud plyne požadovaná nerovnost a (1) je dokázáno.

Důkaz (2) využije následující odhad.

\begin{lemma_counting}Pro každé $h\ge 1$ a pro každý 
$(a,b)$-strom $T$ s~$m$ listy platí 
$$\sum_{l=1}^hb_l(T)(c+1)^l\le (c+1)m.$$
\end{lemma_counting}

\begin{proof}Pro $0\le j<c$ a pro libovolné $h$ 
označme $m_j(h)$ počet vrcholů ve výšce $h$ 
různých od kořene, které mají přesně $a
+j$ 
synů, a $m_c(h)$ počet vrcholů ve výšce $
h$ 
různých od kořene, které mají alespoň $a+c$ 
synů. Pak máme
\begin{align*} b_h(T)\le&\sum_{j=0}^cjm_j(h)\text{\rm},\\
\sum_{j=0}^c(a+j)m_j(h)\le&\sum_{j=0}^cm_j(h-1)\text{\rm\ pro každé }
h\ge 1,\end{align*}
kde dodefinováváme $\sum_{j=0}^cm_j(0)=m$. Tyto vztahy 
použijeme v následujícím odhadu. Platí 
\begin{align*}\sum_{l=1}^hb_l(T)&(c+1)^l\le\sum_{l=1}^h\big[(c+1)^l\big
(\sum_{j=0}^cjm_j(l)\big)\big]\le\\
&\sum_{l=1}^h\big[(c+1)^l\big(\sum_{j=0}^cm_j(l-1)-a\sum_{j=0}^cm_
j(l)\big)\big]=\\
&(c+1)\sum_{j=0}^cm_j(0)-(c+1)^ha\sum_{j=0}^cm_j(h)+\\
&\quad\sum_{l=1}^{h-1}(c+1)^{l+1}\big(\sum_{j=0}^cm_j(l)-\frac a{
c+1}\sum_{j=0}^cm_j(l)\big)\le\\
&(c+1)m,\end{align*}
kde rovnost jsme získali přerovnáním sčítanců 
tak, aby výrazy $\sum_{j=0}^cm_j(l)$ byly u sebe, a poslední 
nerovnost plyne z toho, že $\frac a{c+1}\ge 1$, a tedy druhý sčítanec 
v předchozím výrazu není kladný.
\end{proof}
 

Zkombinujeme odhad $St_h+Sp_h$ s~Lemmatem 7 a 
dostaneme
\begin{align*} St_h+Sp_h\le&\frac n{(c+1)^h}+\sum_{l=1}^hb_l(T_k)\frac {
(c+1)^l}{(c+1)^{h+1}}\le\\
&\frac n{(c+1)^h}+\frac {n(c+1)}{(c+1)^{h+1}}=\frac {2n}{(c+1)^h}
.\end{align*}
Protože $P_h\le Sp_{h-1}-Sp_h\le St_{h-1}+Sp_{h-1}\le\frac {2n}{
(c+1)^{h-1}}$ 
dostáváme, že 
\begin{align*} St_h+Sp_h+P_h\le&\frac {2n}{(c+1)^h}+\frac {2n}{(c+1)^{h
-1}}=\frac {2n+2n(c+1)}{(c+1)^h}=\\
&\frac {2n(c+2)}{(c+1)^h}\end{align*}
a důkaz (2) ve Větě je hotov.

Věta vysvětluje, proč jsou doporučené hodnoty $
b\ge 2a$ -- 
pak je počet vyvažovacích ope\-rací během posloupnosti 
operací {\bf INSERT} a {\bf DELETE} lineární vzhledem k délce 
této posloupnosti. Pro $b=2a-1$ lze lehce nalézt 
posloupnost operací {\bf INSERT} a {\bf DELETE} o délce $n$ takovou, 
že její aplikace na prázdný $(a,b)$-strom vyžaduje počet 
vyvažovacích operací ú\-měrný $n\log n$ (pro každé 
dostatečně velké $n$). Podobná věta platí i pro paralelní 
implementaci $(a,b)$-stromů, ale platí za 
předpokladu $b\ge 2a+2$. Pro $b=2a$ nebo $b=2a+1$ lze 
nalézt posloupnost, která je protipříkladem. Proto se 
doporučuje hodnota $b=2a+2$ pro paralelní implementaci 
$(a,b)$-stromu. Pro propojené $(a,b)$-stromy platí silnější 
verze.

\begin{veta}Předpokládejme, že $b\ge 2a$ a $a\ge 2$. Mějme 
hladinově propojený $(a,b)$-strom s~prstem $T$, který reprezentuje 
$n$-prvkovou množinu. Pak posloupnost $\mathcal P$ operací {\bf MEMBER},
{\bf INSERT}, {\bf DELETE} a {\bf PRST} aplikovaná na $T$ vyžaduje čas 
$$O(\log(n)+\text{\rm\ čas na vyhledání prvků})
.$$
\end{veta}

Vysvětlení: Začínáme v libovolném 
propojeném $(a,b)$-stro\-mě $T$, proto jeho struktura 
může být nevýhodná pro danou pos\-loupnost operací $
\mathcal P$. 
Abychom se dostali do vhodného režimu, může 
být třeba až $\log(n)$ vyvažovacích operací. Čas na 
vy\-hledává\-ní nemůžeme ovlivnit, ten musí 
ovlivnit uživatel.

Aplikace: analýza hladinově propojených stromů s~prstem 
u\-mož\-nila návrh algoritmu, který pro dvě množiny $
S_1$ a $S_2$ 
repre\-zentované propojenými $(a,b)$-stromy, kde $b\ge 2a$ a 
$a\ge 2$, 
zkonstruuje propojený $(a,b)$-strom reprezentující množinu 
$S_1\cup S_2$ (nebo množinu $\Delta (S_1,S_2)=(S_1\setminus S_
2)\cup (S_2\setminus S_1)$ nebo 
$S_1\cap S_2$ nebo $S_1\setminus S_2$) v čase $O(\log\binom {n
+m}m)$, kde 
$n=\max\{|S_1|,|S_2|\}$ a $m=\min\{|S_1|,|S_2|\}$. Detaily budou v letním 
semestru.

Vyvažování při operaci {\bf INSERT} lze provádět 
tak, že operace {\bf Štěpení$(t)$} se provede, jen když oba 
bratři vrcholu $t$ mají $b$ synů. Jinak se provádí 
operace {\bf Přesun}. Nevím o žádném seriózním pokusu tyto 
alternativy porovnat.   

\subsection{Vyhledávání v uspořádaném poli}

Zadání úlohy: Máme podmnožinu $S$ lineárně 
uspořádaného univerza a $S$ je uložena v poli 
$A[1..|S|]$ tak, že pro $i<j$ je $A(i)<A(j)$. Pro dané $x\in 
U$ 
máme zjistit, zda $x\in S$ (operace {\bf MEMBER$(x)$}).

Řešení:  Pokud $x<A(1)$ nebo $A(|S|)<x$, pak $
x$ 
není prvkem $S$.  V opačném případě buď $x=
A(1)$ nebo 
$x=A(|S|)$ nebo máme dvě hodnoty $d$ 
a $h$ takové, že $1\le d<d+1<h\le |S|$ a $A(d)<x<A(h)$.  Pak 
najdeme $n$ takové, že $d<n<h$, a dotazem 
zjistíme, zda $x=A(n)$ (pak končíme a $x\in S$) nebo 
$x<A(n)$ (pak položíme $h=n$) nebo $x>A(n)$ (pak 
položíme $d=n$) a proces opakujeme.  Končíme, když 
$d+1\ge h$, pak $x\notin S$. Na začátku položíme $d=1$ a $
h=|S|$.
Formální zápis algoritmu:

{\bf MEMBER$(x)$\newline 
if} $x=A(1)$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$ stop\newline 
{\bf else}\newline 
\phantom{---}{\bf if} $x<A(1)$ {\bf then}\newline 
\phantom{------}{\bf Výstup}: $x\notin S$ stop\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$d=1$\newline 
\phantom{---}{\bf endif\newline
\bf endif\newline 
if} $x=A(|S|)$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$ stop\newline 
{\bf else}\newline 
\phantom{---}{\bf if} $x>A(|S|)$ {\bf then}\newline 
\phantom{------}{\bf Výstup}: $x\notin S$ stop\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$h=|S|$\newline 
\phantom{---}{\bf endif\newline
endif\newline 
while} $d+1<h$ {\bf do}\newline 
\phantom{---}$n:=\text{{\bf next}}(d,h)$\newline 
\phantom{---}{\bf if} $\bold x=A(n)$ {\bf then}\newline 
\phantom{------}{\bf Výstup}: $\bold x\in S$ stop\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $x<A(n)$ {\bf then} $h:=n$ {\bf else} $d:=n$ {\bf endif}\newline 
\phantom{---}{\bf endif\newline 
enddo\newline 
Výstup}: $x\notin S$ stop

V tomto metaalgoritmu je {\bf next$(d,h)$} funkce, která 
nalezne hodnotu $n$ takovou, že $d<n<h$. Korektnost plyne 
z pozorování, že když $d+1=h$, pak $A(d)<x<A(h)$ 
implikuje, že neexistuje $i$ takové, že $x=A(i)$, a tedy 
$x\notin S$. Efektivita algoritmu záleží na fukci {\bf next}. 
Zpracování dotazu vyžaduje čas $O(1)$ a počet 
dotazů je 
počet volání funkce {\bf next}. 

Unární vyhledávání: {\bf next$(d,h)=d+1$}, pak každý 
dotaz zvětší $d$ o $1$, a tedy největší počet 
dotazů je $|S|$. Algoritmus v nej\-horším případě 
vyžaduje čas $O(|S|)$ a očekávaný počet dotazů při 
rovnoměrném rozložení množiny $S$ a prvku $x$ je $\frac {
|S|}2$ 
(tedy očekávaný čas je $O(|S|)$). 

Poznámka: Duální přístup je, když 
{\bf next$(d,h)=h-1$}, výsled\-ky se nezmění. Při aplikacích je 
někdy výhodné použít funkci {\bf next$(d,h)=\min\{d
+c,h-1\}$}, 
kde $c$ je nějaká konstanta (pak krok není $1$, ale $c$). Jak 
uvidíme později, jsou situace, kdy je výhodné  
takovéto unární vyhledávání použít.

Binární vyhledávání: {\bf next$(d,h)=\lceil\frac {
d+h}2\rceil$}, pak 
každý dotaz zmenší rozdíl $h-d$ přibližně na polovinu. 
Počet dotazů je nejvýše $3+\log(|S|-2)$, 
algoritmus tedy v 
nejhorším případě vyžaduje čas $O(\log|S|)$ a  
očekávaný čas při rovnoměrném roz\-ložení množiny $
S$ a 
$x\in U$ je také $O(\log|S|)$.

Interpolační vyhledávání: 
{\bf next$(d,h)=d+\lceil\frac {x-A(d)}{A(h)-A(d)}(h-d)\rceil$}. V nejhorším případě 
musíme položit více než $\frac {|S|}2$ dotazů, a proto čas 
v nejhorším případě je $O(|S|)$, ale při rovnoměrném 
roz\-ložení množiny $S$ a $x\in U$ je očekávaný čas 
$O(\log\log|S|)$. To je založeno na faktu, že hodnota {\bf next }
závisí i na velikosti $x$. Když $x$ je velké, tak hodnota 
{\bf next} je posunuta do větších hodnot, když $x$ je malé, 
pak je posunuta do menších hodnot.

Poznámka: Když rozložení prvků není 
rovnoměrné, ale je zná\-mé, pak podle toho můžeme  
upravit funkci {\bf next} a očekávaný čas algoritmu se 
nezmění.

Pro následující funkci {\bf next} bude 
jednodušší spočítat očekáva\-ný počet dotazů než 
pro interpolační vyhledávání, ale výsledek je 
asymptoticky stejný.

\subsubsection{Zobecněné kvadratické vyhledávání}

Funkce {\bf next }
je zde definována složitější procedurou, jejíž vý\-sle\-dek 
závisí i na předcho\-zích situacích a na výsledku dotazu.
Procedura zadává dotazy v blocích. První dotaz v bloku je 
interpolační a procedura přitom zjistí velikost kroku a 
zda $x$ je menší nebo větší než první dotaz v bloku.  
Pak střídá unární a binární vy\-hledávání. Blok končí, 
když rozdíl mezi $h$ a $d$ je nejvýše velikost 
kroku. Krok v následujícím bloku klesne 
přibližně na odmoc\-ninu velikosti kroku v tomto bloku. 
Procedura používá boolské pro\-měnné $blok$, $typ$, $
smer$. 
Proměnná $blok$ je inicializována hodnotou $false$ a určuje, 
zda se dotaz zadává v rámci stejného bloku nebo nikoliv. 
Proměnná $typ$ určuje, zda příští dotaz je unární (když 
$typ=true$) nebo binární. Proměnná $smer$ určuje, zda 
dotazy jsou menší než první dotaz v bloku ($smer=tr
ue$) 
nebo větší. Dále procedura používá proměnnou $
krok$ 
typu integer, která obsahuje velikost kroku v rámci 
bloku. Hodnoty těchto pro\-měn\-ných se předávají z jednoho 
volání procedury do dalšího volání (tj. jsou to 
globální proměnné, které se neinicializují voláním 
procedury {\bf next}). 

{\bf next$(d,h)$\newline 
if} $blok$ {\bf then}\newline 
\phantom{---}{\bf if} $typ$ {\bf then}\newline 
\phantom{------}{\bf if} $smer$ {\bf then}\newline 
\phantom{---------}{\bf next}$(d,h):=h-krok$\newline 
\phantom{---------}{\bf if} $A(\text{{\bf next}}(d,h))<x$ {\bf then}\newline
\phantom{------------}$blok:=false$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}{\bf next}$(d,h):=d+krok$\newline 
\phantom{---------}{\bf if} $A(\text{{\bf next}}(d,h))>x$ {\bf then}\newline \phantom{------------}$blok:=false$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$typ:=false$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\min\{h-\lceil\frac {d+h}2\rceil ,\lceil\frac {d+h}2\rceil-d\}<krok$ {\bf then}\newline 
\phantom{---------}$blok:=false$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}{\bf next}$(d,h):=\lceil\frac {d+h}2\rceil$, $typ:=true$\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}$krok:=\lfloor\sqrt {h-d}\rfloor$, 
{\bf next$(d,h):=d+\lceil\frac {x-A(d)}{A(h)-A(d)}(h-d)\rceil$},\newline 
\phantom{---}{\bf if} $A(\text{{\bf next}}(d,h))>x$ {\bf then}\newline 
\phantom{------}$smer:=true$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$smer:=false$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$typ:=true$, $blok:=true$\newline 
{\bf endif}

Po dvou dotazech klesne $h-d$ buď pod $\sqrt {h-d}$ nebo pod 
$\frac {h+d}2$. Proto procedura v nejhorším případě použije 
nejvýše $8+2\log(|S|-1)+2\log\log|S|$ dotazů, a tedy v nejhorším 
případě vyžaduje čas $O(\log|S|)$.

Nyní spočítáme očekávaný počet dotazů 
během jednoho bloku za předpokladu rovnoměr\-ného rozdělení dat. Nechť $p_i$ je prav\-dě\-podobnost, že 
v rámci bloku se položí ales\-poň $i$ dotazů. Pak 
očekávaný počet dotazů v rámci bloku je 
$$E(C)=\sum_{i\ge 1}i(p_i-p_{i+1})=\sum_{i\ge 1}p_i.$$
Nyní odhadneme $p_i$.  Označme $n+d$ argument prvního dotazu 
(interpolační vyhledávaní) v rámci bloku a nechť $
krok=k$ 
v rámci bloku.  Označme $X=|\{i\mid i>d,\,A(i)\le x\}|$ na 
začátku bloku, pak $X$ je náhodná proměnná závislá na 
argumentu ope\-race a bloku.  Když se v bloku položí 
alespoň $i$ dotazů pro $i>2$, pak $|X-n|\ge\lfloor\frac {
i-2}2\rfloor k$, 
protože každý unární dotaz, jehož položení  
nezmění blok, nalezne dalších $k$ hodnot $i$ v rozdílu $|X-n|$. 
Tedy 
$$p_i\le\Prob(|X-n|\ge\lfloor\frac {i-2}2\rfloor k).$$
Použijeme Čebyševovu nerovnost pro náhodnou 
proměn\-nou $X$. Když $Y$ je náhodná proměnná s~očekávanou 
(střední) hodnotou $\mu$ a rozptylem $\sigma^2$, pak Čebyševova 
nerovnost říká, že 
$$\Prob(|Y-\mu |\ge t)\le\frac {\sigma^2}{t^2}\qquad\text{\rm pro každé }
t>0.$$

Uvažujme okamžik, kdy jsme na začátku nějakého 
bloku. Pro\-tože $S$ je vybraná s~rovno\-měr\-ným rozdělením, je 
pravděpodob\-nost, že $A(i)<x$ pro $d<i<h$, rovna 
$p=\frac {x-A(d)}{A(h)-A(d)}$, a pak pravděpodobnost, že 
$X=j$, je $\binom {h-d}jp^j(1-p)^{h-d-j}$. To znamená, že $X$ je náhodná 
veličina s~binomickým rozdělením s~rozsahem $d-h$ a pravděpodobností $p$, a tedy její očekávaná 
hodnota je
$$\mu =\sum_{j=0}^{h-d}j\binom {h-d}jp^j(1-p)^{h-d-j}=p(h-d)$$
a rozptyl má hodnotu 
$$\sigma^2=\sum_{j=0}^{h-d}(j-\mu )^2\binom {h-d}jp^j(1-p)^{h-d-j}
=p(1-p)(h-d).$$
Když si uvědomíme, že $k=\lfloor\sqrt {h-d}\rfloor$ a $
n=p(h-d)$, pak dostáváme
\begin{align*} p_i,p_{i+1}\le&\Prob(|X-n|\ge\lfloor\frac {i-2}2\rfloor k 
)\le\frac {4p(1-p)(h-d)}{(i-2)^2k^2}\le\\
&\frac {4p(1-p)}{(i-2)^2}\le\frac 1{(i-2)^2},\end{align*}
protože pro $0\le p\le 1$ je $p(1-p)\le\frac 14$. Když shrneme tato pozorování, 
dostává\-me, že 
\begin{align*} E(C)=&\sum_{i\ge 1}p_i\le 2+2\sum_{i\ge 3}\frac 1{(i-2)^2}=
2+2\sum_{i\ge 1}\frac 1{i^2}=\\
&2+2\frac {\pi^2}6=2+\frac {\pi^2}3\approx 5.3\end{align*}
Závěr: očekávaný počet dotazů v bloku je menší než $
6$.

Když $E(T(n))$ je očekávaný počet dotazů pro operaci 
{\bf MEMBER} a když $|S|=n$, pak platí 
$$E(T(n))\le E(C)+E(T(\sqrt n)).$$
Protože $E(T(1))=1$ a $E(T(2))\le 2$, dostáváme z rekurentního 
vzorce, že 
$$E(T(n))\le 2+E(C)\log\log n\qquad\text{\rm pro }n\ge 2.$$

\begin{veta}Čas operace {\bf MEMBER} v uspořádaném poli délky $
n$ při 
zobec\-něném kvadra\-tickém vyhledávání je v nejhorším 
přípa\-dě $O(\log n)$. Když rozdělení vstupních dat je 
rovno\-měr\-né, pak očekávaný čas je $O(\log\log n)$. 
\end{veta}

Nevýhoda této datové struktury 
spočívá v neexistenci přiroze\-ných efektivních implementací 
ope\-rací {\bf INSERT}, {\bf DELETE}, {\bf SPLIT} a {\bf JOIN}. Přirozené 
implementace těchto ope\-rací vyža\-dují čas 
$O(|S|)$, zhruba řečeno musíme pohybovat s~téměř kaž\-dým prvkem. 
Pokusem o řešení 
tohoto problému byl návrh binár\-ních vyhledávacích 
stromů.

\subsection{Binární vyhledávací stromy}

Binární vyhledávací strom je struktura pro binár\-ní 
vyhledávání v uspořáda\-ném poli rozta\-ženém do roviny a 
vyhledávání odpo\-ví\-dá cestě ve stro\-mě. Formální 
definice:

Předpokládáme, že $U$ je lineárně uspořádané 
univerzum a $S\subseteq U$.  \emph{Binární} \emph{vyhledávací} 
\emph{strom} $T$ \emph{reprezentující} množinu $S$ je úplný 
binární strom (tj. každý vrchol je buď listem nebo má 
dva syny, levého a pravého), kde existuje bijekce mezi 
množinou $S$ a vnitřními vrcholy stromu taková, že
\begin{itemize}
\item
když $v$ je vnitřní vrchol stromu $T$, kterému je přiřazen 
prvek $s\in S$, pak každému vnitřnímu vrcholu $u$ v 
podstromu levého syna vrcholu $v$ je přiřazen prvek z $S$ 
menší než $s$ a každému vnitřnímu vrcholu $
w$ v 
podstromu pravého syna vrcholu $v$ je přiřazen prvek z $S$ 
větší než $s$.
\end{itemize}

Strukura vnitřního vrcholu $v$:\newline 
ukazatel $\otec(v)$ na otce vrcholu $v$,\newline 
ukazatel $\levy(v)$ na levého syna vrcholu $v$,\newline 
ukazatel $\pravy(v)$ na pravého syna vrcholu $v$,\newline 
atribut $\key(v)$ -- prvek z $S$ přiřazený vrcholu $v$.
Když $v$ je kořen stromu, pak hodnota ukazatele $\otec(v)$ 
je $NIL$. List má ukazatele pouze na otce.

Každý list reprezentuje interval mezi dvěma 
sousedními prvky z $S$ -- přesně, když $u$ je list a je 
levým synem vrcholu $v$, nalezneme vrchol na cestě z $u$ 
do kořene nejblíže $u$ takový, že je pravým synem 
vrcholu $w$. Pak $u$ repre\-zentuje interval $(\key(w),\key(v))$ a 
když vrchol $w$ neexistuje, pak $u$ repre\-zentuje 
interval $(-\infty ,\key(v))$ a prvek $\key(v)$ je nej\-menší prvek v 
$S$.  Když $u$ je list a je pravým synem vrcholu $v$, 
nalezneme vrchol na cestě z $u$ do kořene nejblíže 
$u$ takový, že je levým synem vrcholu $w$. Pak $u$ repre\-zentuje 
interval $(\key(v),\key(w))$ a když takový vrchol $w$ neexistuje, 
pak $u$ repre\-zentuje interval $(\key(v),+\infty )$ a prvek $\key
(v)$ 
je největší prvek v $S$.  

Při implementaci binárních vyhledávácích 
stromů je výhodné vynechat listy (místo nich bude 
ukazatel $NIL$). Při návrhu algoritmů je však 
naopak výhodné 
pracovat s~listy (vyhlíží to logičtější). Proto při návrhu 
algoritmů budeme předpokládat, že stromy mají 
listy reprezentující intervaly.

Navrhneme algoritmy pro binární vyhledávací stromy 
rea\-lizují\-cí operace z uspořádaného slovníkového problému.

{\bf Vyhledej$(x)$\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list a $\key(t)\ne x$ {\bf do}\newline 
\phantom{---}{\bf if} $\key(t)>x$ {\bf then} $t:=\levy(t)$ {\bf else} $t:=\pravy(t)$ {\bf endif\newline 
enddo

MEMBER$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ není list {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif

INSERT$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ je list {\bf then}\newline 
$t$ se změní na vnitřní vrchol, $\key(t):=x$,\newline 
$\levy(t)$ a $\pravy(t)$ jsou nové listy, jejichž otcem je $t$\newline 
{\bf endif

DELETE$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ není list {\bf then}\newline 
\phantom{---}{\bf if} $\levy(t)$ je list {\bf then\newline}
\phantom{------}odstraníme vrchol $\levy(t)$, $\otec(\pravy(t)):=\otec(t)$\newline 
\phantom{------}{\bf if} $t=\levy(\otec(t))$ {\bf then}\newline
\phantom{---------}$\levy(\otec(t)):=\pravy(t)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(t)):=\pravy(t)$\newline 
\phantom{------}{\bf endif\newline}
\phantom{------}odstraníme vrchol $t$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\levy(t)$\newline 
\phantom{------}{\bf while} $\pravy(u)$ není list {\bf do}\newline \phantom{---------}$u:=\pravy(u)$\newline 
\phantom{------}{\bf enddo}\newline 
\phantom{------}$\key(t):=\key(u)$, odstraníme vrchol $\pravy(u)$,\newline 
\phantom{------}$\otec(\levy(u)):=\otec(u)$\newline 
\phantom{------}{\bf if} $u=\levy(\otec(u))$ {\bf then}\newline 
\phantom{---------}$\levy(\otec(u)):=\levy(u)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(u)):=\levy(u)$\newline 
\phantom{------}{\bf endif\newline}
\phantom{------}odstraníme vrchol $u$\newline 
\phantom{---}{\bf endif\newline 
endif}

{\bf MIN\newline 
$t:=$}kořen stromu\newline 
{\bf while} levý syn $t$ není list {\bf do} $t:=\levy(t)$ {\bf enddo\newline 
Výstup}: prvek reprezentovaný $t$ je nejmenší prvek v $
S$

{\bf MAX\newline 
$t:=$}kořen stromu\newline 
{\bf while} pravý syn $t$ není list {\bf do} $t:=\pravy(t)$ {\bf enddo\newline 
Výstup}: prvek reprezentovaný $t$ je největší prvek v $
S$

{\bf SPLIT$(x)$}:\newline 
$T_1$ a $T_2$ jsou prázdné stromy\newline 
$u_1:=u_2:=NIL$\newline 
$t:=\text{\rm kořen stromu }T$\newline 
{\bf while} $t$ není list a $\key(t)\ne x$ {\bf do\newline}
\phantom{---}{\bf if} $\key(t)>x$ {\bf then\newline 
\phantom{------}$u:=\levy(t)$}, $\levy(t):=NIL$, $\otec(u):=NIL$\newline 
\phantom{------}{\bf if} $T_2$ je prázdný strom {\bf then}\newline \phantom{---------}$T_2:=\text{\rm podstrom vrcholu }t$\newline
\phantom{------}{\bf else}\newline 
\phantom{---------}$\levy(u_2):=t$, $\otec(t):=u_2$\newline 
\phantom{------}{\bf endif}\newline
\phantom{------}$u_2:=t$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\pravy(t)$, $\pravy(t):=NIL$, $\otec(u):=NIL$\newline
\phantom{------}{\bf if} $T_1$ je prázdný strom {\bf then}\newline \phantom{---------}$T_1:=\text{\rm podstrom vrcholu }t$\newline
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(u_1):=t$, $\otec(t):=u_1$\newline 
\phantom{------}{\bf endif}\newline
\phantom{------}$u_1:=t$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$t:=u$\newline 
{\bf enddo\newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}$\otec(\levy(t)):=u_1$, $\pravy(u_1):=\levy(t)$\newline 
\phantom{---}$\otec(\pravy(t)):=u_2$, $\levy(u_2):=\pravy(t)$\newline 
\phantom{---}$\otec(u_1):=NIL$, $\otec(u_2):=NIL$, {\bf Výstup}: $x\in S$\newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x\notin S$\newline 
{\bf endif\newline }
Komentář: $T_1$ je binární vyhledávací strom reprezentující 
mno\-ži\-nu 
$\{s\in S\mid s<x\}$ a $T_2$ je binární vyhledávací strom 
reprezentující množinu $\{s\in S\mid s>x\}$.

{\bf JOIN3$(T_1,x,T_2)$} -- předpokládáme, že když $
T_i$ reprezentuje 
množinu $S_i$ pro $i=1,2$, pak $\max S_1<x<\min S_2$\newline 
vytvořme nový vrchol $u$, $\key(u)=x$, $\otec(u):=NIL$, \newline 
$\otec(\text{kořene }T_1):=u$, $\otec(\text{kořene }T_2):=u$, \newline 
$\levy(u):=$kořen $T_1$, $\pravy(u):=$kořen $T_2$.

Abych dokázali korektnost algoritmu {\bf Vyhledej} -- 
jedná se o modifikaci vyhledávání v uspořádaném poli --
popíšeme po\-drobněji vlastnosti binárního vyhledávacího 
stromu. Nej\-prve rozšíříme universum o dva nové prvky, o nový 
nejmenší prvek $-\infty$ a o nový největší prvek $+\infty$. 
Mějme binární vyhledávací strom $T$ reprezentující 
množinu $S$, pak pro vrchol $t$ stromu $T$ definujeme indukcí hodnoty $\lambda(t)$ 
a $\pi(t)$. Když $r$ je kořen, pak $\lambda(r)=-\infty$ a $\pi(r)=+\infty$. 
Když hodnoty $\lambda(t)$ a $\pi(t)$ jsou pro vrchol $t$ definovány, pak pro levého syna $u$ vrcholu $t$ definujeme $\lambda(u)=\lambda(t)$ a $\pi(u)=\key(y)$
a pro pravého syna $w$ vrcholu $t$ definujeme $\lambda(w)=\key(t)$ a $\pi(w)=\pi(t)$.
Nyní dokážeme

\begin{lemma}Je-li $T'$ podstrom binárního vyhledávacího 
stromu $T$ určený vrcholem $t$, pak $T'$ reprezentuje množinu 
$S\cap (\lambda (t),\pi (t))$. Navíc interval $(\lambda (t),\pi 
(t))$ je největší interval, 
který obsahuje jenom prvky z $S$, které jsou reprezentovány 
vrcholy podstromu $T'$. Navíc, když $t$ je list, pak $<\lambda(t),\pi(t)>$ je interval repreyentovaný listem $t$.
\end{lemma}

\begin{proof}Tvrzení dokážeme indukcí.  Zřejmě platí, 
když $t$ je kořen stromu $T$.  Předpokládej\-me, že platí pro vrchol 
$t$ a doká\-že\-me ho pro syny vrcholu $t$.  Označme $t_l$ levého syna 
vrcholu $t$, $t_p$ pravého syna vrcholu $t$.  Z definice binárního 
vyhledávacího stromu stromu plyne, že když $u$ je vnitřní 
vrchol v podstromu $T$ určeném vrcholem $t_l$ a když $v$ je vnitřní 
vrchol v podstromu $T$ určeném vrcholem $t_p$, pak 
$\key(u)<\key(t)<\key(v)$.  Nyní platnost tvrzení pro $t$ 
implikuje platnost tvrzení i pro vrcholy $t_l$ a $t_p$. 
\end{proof}

Korektnost podprocedury {\bf Vyhledej} plyne z 
následujícího invariantu:
\begin{itemize}
\item
Když při vyhledávání $x$ vyšetřujeme vrchol $
t$, pak 
$$\lambda (t)<x<\pi (t).$$
\end{itemize}
Toto tvrzení se lehce dokáže indukcí z popisu algoritmu 
{\bf Vy\-hledej}.  Tedy operace {\bf Vy\-hledej} je korektní a korekt\-nost 
ope\-rací {\bf MEMBER} a {\bf INSERT} je teď zřejmá. V operaci {\bf DELE\-TE},  
když $\levy(t)$ je list, pak korektnost je zřejmá. Když $\levy
(t)$ 
není list, pak algoritmus nalezne list $v$ takový, že $\pi(v)=x$. 
Pak pro $u=\otec(v)$ platí $v=\pravy(u)$ a $\lambda(v)=\key(u)$ a 
$(\lambda(v),\pi(v))\cap S=\emptyset$. Když $y=\key(u)$, pak 
odstranění vrcholů $u$ a $v$ dává binární vyhledávací strom reprezentující $S\setminus \{y\}$. 
Protože $(y,x)\cap S=\emptyset$, tak příkaz $\key(t):=y$ dává binární 
vyhledávací strom reprezentující $S\setminus \{x\}$ a proto operace 
{\bf DELETE} je korektní. 

Korektnost operací {\bf MIN}, {\bf MAX} a {\bf JOIN3} plyne z definice 
binárního vyhledavacího stromu.  Korektnost operace {\bf SPLIT }
plyne z korektnosti algoritmu {\bf Vyhledej} a z faktu, že $u_
1$ je otec 
nej\-pravějšího listu stromu $T_1$ a $u_2$ je otec nejlevějšího listu stromu $T_2$.  
Protože ke stromu $T_1$ se přidává část stromu $T$ reprezentující 
prvky, které jsou větší než prvky reprezentované v $
T_1$, a ke 
stromu $T_2$ se přidává část stromu $T$ reprezentující prvky, 
které jsou menší než prvky reprezentované v $T_2$, korektnost 
algoritmu pro operaci {\bf SPLIT} je jasná.  

Zpracování jednoho vrcholu vyžaduje čas $O(
1)$ a 
algoritmus se pohybuje po jedné cestě z kořene do 
nějakého listu. Označme $\hloubka(T)$ délku nejdelší cesty 
z kořene do nějakého listu. Pak dostáváme

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, {\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, 
{\bf JOIN3} a {\bf SPLIT} v binár\-ním vy\-hledá\-va\-cím stro\-mě $
T$ vyžadují 
čas $O(\hloubka(T))$. 
\end{veta}

Bohužel ani struktura binárních vyhledávacích 
stromů nepodporuje efektivní implementaci operace 
{\bf ord$(k)$}. Pro její efektivní implentaci je vhodné rozšířit 
datovou strukturu tak, že u každého vrcholu $t$ je deklarován 
také údaj $p(t)$ -- počet listů v podstromu určeném 
vrcholem $t$. Po provedení operací {\bf INSERT}, {\bf DELETE}, {\bf JOIN3} a 
{\bf SPLIT} je pak nutné aktualizovat tuto položku na cestě z 
vrcholu do kořene. Následující algoritmus pak 
realizuje operaci {\bf ord}$(k)$.

{\bf ord$(k)$ \newline 
$t:=$}kořen stromu \newline 
{\bf if} $k\ge p(t)$ {\bf then} $k$-tý prvek neexistuje, {\bf stop endif\newline 
while} true {\bf do}\newline 
\phantom{---}{\bf if} $k>p(\levy(t))$ {\bf then}\newline 
\phantom{------}$k:=k-p(\levy(t))$, $t:=\pravy(t)$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $k<p(\levy(t)$ {\bf then}\newline 
\phantom{---------}$t:=\levy(t)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\key(t)$ je $k$-tý prvek reprezentované množiny, stop \newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
enddo}

Korektnost algoritmu plyne z následujícího invariantu:  
Když algoritmus má v daném okamžiku v proměnné $t$ vrchol $
v$ 
a hodnota proměnné $k$ je $k'$, pak $k$-tý prvek v $S$ se rovná 
$k'$-tému prvku v intervalu reprezentovaném v podstromu 
stromu $T$ určeném vrcholem $v$.  Protože na počátku algoritmu 
je $v$ kořen stromu a interval je $S$ (a $k'=k$), tak na počátku 
běhu algoritmu invariant platí.  Předpokládejme, že platí v 
některém kroku.  Nechť $u$ je levý syn $v$, $w$ je pravý syn $
v$ a 
$I_a$ je interval reprezovaný podstromem $T$ určeným vrcholem $
a$.  
Pak $|I_u|=p(u)-1$, $\max I_u<\key(v)<\min I_w$ a 
$I_v=I_u\cup \{\key(v)\}\cup I_w$.  Odtud plyne, že když $k'
<p(u)$, pak 
$k'$-tý prvek v intervalu $I_v$ je $k'$-tý prvek v intervalu $
I_u$, když 
$k'>p(u)$, pak $k'$-tý prvek v intervalu $I_v$ je $(k'-p(u))$-tý prvek 
v intervalu $I_w$, a když $k'=p(u)$, pak $k'$-tý prvek v intervalu $
I_v$ 
je $\key(v)$.  Odtud plyne invariant a korektnost algoritmu.  
Podle stejných argumentů jako v předchozím případě 
dostaneme, že časová složitost algoritmu je $O(\hloubka
(T))$.  
Tedy můžeme tato fakta shrnout.  

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, {\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, 
{\bf JOIN3}, {\bf SPLIT} a $\bold o\bold r\bold d(k)$ pro všechna $
k$ v rozšířených binár\-ních 
vy\-hledávacích stromech vyžadují čas $O(\hloubka
(T))$, kde $T$ je 
reprezentující strom. 
\end{veta}

Tento výsledek motivuje používání binárních 
vyhledávacích stromů, které splňují další 
podmínku, která má zajistit, že 
$\hloubka(T)=O(\log|S|)$.  V takovémto případě mluvíme o 
\emph{vyvážených} \emph{binárních} 
\emph{vyhledávacích} \emph{stromech}.  Je však nutné 
přidat k ope\-racím {\bf INSERT}, {\bf DELETE}, {\bf JOIN3} a {\bf SPLIT} další 
kroky, které 
zaručí, že po jejich provedení strom opět splňuje 
požadované podmínky.  To vede k požadavku, aby 
vyvažovací operace byly rychlé a provádělo se jich málo.  

Při náhodné posloupnosti operací {\bf INSERT} a {\bf DELETE} je 
velká pravděpodobnost, že dostaneme náhodný binární 
vy\-hledávací strom.  Je známo, že očekávaná hodnota proměn\-né 
$\hloubka(T)$ je $O(\log|S|)$.  Protože se nepoužívají vyvažovací 
operace, můžeme dostat lepší výsledek (časově) než pro 
vyvá\-žené binár\-ní vyhledávací stromy.  Tento problém se teď 
intenzivně studu\-je.  Velká pozornost je věnována 
pravděpodobnost\-ním modifikacím binárních vyhledávacích 
stromů.  Hledají se však i další možnosti.  

Studují se tzv.  samoupravující struktury.  Zde se 
pracuje s~datovou strukturou bez dodatečných informací, ale 
operace nad touto strukturou provádí vyvažování v závislosti 
na argumentu operace.  Dokázalo se, že existuje strategie 
vyvažování, která zajišťuje dobré chování bez ohledu na 
vstupní data.  Další strategie je, že se jen zjišťuje, zda datová 
struktura nemá výraz\-ně špatné chování, a pokud ho má nebo 
po dlouhé řadě úspěš\-ných aktualizačních operací se vybuduje 
nová datová struktura (s optimálním chováním).  Třetí, 
poměrně stará, strategie je zalo\-že\-na na předpokladu, že 
známe rozdělení vstupních dat.  Zde se datová struktura 
předem upravuje pro toto rozdělení.  Ukazuje se, že tyto 
strategie mají úspěch.  Další podrobnosti v letním semestru.  

Nyní si ukážme dvě operace se stromy, na nichž jsou 
založeny  vyvažovací operace pro binární vyhledávací 
stromy. Obě ope\-race vyžadují čas $O(1)$.

Mějme vrchol $v$ binárního vyhledávacího stromu $
T$ a 
jeho syna $u$, který je vnitřní vrchol.  Pak {\bf Rotace$
(v,u)$} je 
znázorněna na obrázku \ref{rotace} a provádí ji následující algoritmus.  

\begin{figure}[h!]
  \centerline{
    \input fig1.tex
    }
  \caption{Rotace $(v,u)$}
  \label{rotace}
\end{figure}

{\bf Rotace$(v,u)$\newline} 
$\otec(u):=\otec(v)$,\newline 
{\bf if} $v=\levy(\otec(v))$ {\bf then}\newline 
\phantom{---}$\levy(\otec(v)):=u$\newline 
{\bf else}\newline 
\phantom{---}$\pravy(\otec(v)):=u$\newline 
{\bf endif\newline 
$\otec(v):=u$\newline 
if} $u=\levy(v)$ {\bf then}\newline 
\phantom{---}$\otec(\pravy(u)):=v$, $\levy(v):=\pravy(u)$, $\pravy(u):=v$\newline 
{\bf else}\newline 
\phantom{---}$\otec(\levy(u)):=v$, $\pravy(v):=\levy(u)$, $\levy(u):=v$\newline 
{\bf endif}

Všimněme si, že při {\bf Rotace} můžeme 
aktualizovat i funkci $p$. Pro vrchol $w\ne u,v$ se její hodnota 
nemění, nová hodnota $p(u)$ je rovná původní hodnotě 
$p(v)$ a novou hodnotu $p(v)$ dostaneme jako 
$p(\levy(v))+p(\pravy(v))$.

Mějme vrchol $w$ stromu $T$, jeho syna $v$ a jeho 
syna $u$ takového, že $u$ není list a $v$ je pravý syn 
vrcholu $w$, právě když $u$ je levý syn vrcholu $v$. Pak 
{\bf Dvojita}-{\bf rotace$(w,v,u)$} je znázorněna na obrázku a provádí 
ji následující algoritmus.

\begin{figure}[h!]
  \centerline{
    \input fig2.tex
    }
  \caption{Dvojita-rotace$(w,v,u)$}
\end{figure}

{\bf Dvojita}-{\bf rotace$(w,v,u)$\newline 
$\otec(u):=\otec(w)$\newline 
if} $w=\levy(\otec(w))$ {\bf then}\newline 
\phantom{---}$\levy(\otec(w)):=u$\newline 
{\bf else}\newline 
\phantom{---}$\pravy(\otec(w)):=u$\newline 
{\bf endif}\newline 
$\otec(v):=u$, $\otec(w):=u$\newline 
{\bf if} $v=\levy(w)$ {\bf then}\newline  
\phantom{---}$\levy(w):=\pravy(u)$, $\otec(\pravy(u)):=w$, $\pravy(v):=\levy(u)$\newline \phantom{---}$\otec(\levy(u)):=v$, $\levy(u):=v$, $\pravy(u):=w$\newline 
{\bf else}\newline 
\phantom{---}$\pravy(w):=\levy(u)$, $\otec(\levy(u)):=w$, $\levy(v):=\pravy(u)$\newline 
\phantom{---}$\otec(\pravy(u)):=v$, $\levy(u):=w$, $\pravy(u):=v$\newline 
{\bf endif}

Také zde můžeme v čase $O(1)$ spočítat nové hodnoty $
p$. 
Pro vrchol $x\ne u,v,w$ se hodnota nemění, nová hodnota 
$p(u)$ je 
rovná původní hodnotě $p(w)$ a nové hodnoty $
p(v)$ 
a $p(w)$ 
získáme pod\-le stejného vzorce  jako v {\bf Rotace}.

\subsection{AVL-stromy}

Binární vyhledávací strom je 
\emph{AVL}-\emph{strom}, když pro každý vnitř\-ní vrchol 
$v$ se délka nejdelší cesty z jeho levého syna do 
listu a délka nejdelší cesty z jeho pravého syna do listu 
liší nejvýše o $1$.  

Pro vnitřní vrchol $v$ stromu $T$ označme $\eta 
(v)$ 
délku nejdelší cesty z vrcholu $v$ do listu.

 

Struktura vnitřních vrcholů v 
AVL-stromech je rozšířena o hodnotu $\omega$:\newline 
$\omega (v)=-1$, když 
$$\eta (\text{\rm levý syn vrcholu }v)=\eta (\text{\rm pravý syn vrcholu }
v)+1;$$
$\omega (v)=0$, když 
$$\eta (\text{\rm levý syn vrcholu }v)=\eta (\text{\rm pravý syn vrcholu }
v);$$
$\omega (v)=+1$, když
$$\eta (\text{\rm levý syn vrcholu }v)+1=\eta (\text{\rm pravý syn vrcholu }
v).$$

Všimněme si, že hodnota $\eta (v)$ pro vnitřní vrcholy 
$v$ stromu $T$ není nikde uložena.  Hodnoty $\eta$ jsme schopni 
spočítat z hodnot $\omega$, ale není to třeba.  Stačí, když po 
aktualizačních operacích budeme umět aktualizovat 
hodnoty $\omega$ a upravit binární vy\-hledávací strom tak, 
aby byl opět AVL-strom.

Odhad velikosti $\eta (\text{\rm kořen }T)$ v závislosti na 
velikosti reprezentované množiny $S$.\newline 
Když $T$ je AVL-strom a $v$ je vnitřní vrchol $T$, pak 
podstrom $T$ určený vrcholem $v$ je opět AVL-strom. 
Označme\newline 
$mn(i)$ velikost nejmenší množiny reprezentované 
AVL-stromem $T$ takovým, že $$\eta (\text{\rm kořen }T)=i,$$ 
$mx(i)$ velikost největší množiny reprezentované 
AVL-stromem $T$ takovým, že $$\eta (\text{\rm kořen }T)=i.$$ 
Z definice AVL-stromu plynou rekurze
\begin{gather*} mn(i)=mn(i-1)+mn(i-2)+1,\,mx(i)=2mx(i-1)+1,\\
\text{a }mn(1)=mx(1)=1,\quad mn(2)=2,\quad mx(2)=3.\end{gather*}
Nejprve spočítáme $mx$.

Dokážeme, že $mx(i)=2^i-1$. Tento vzorec je 
splněn pro $i=1,2$. Dále 
$$mx(i+1)=2mx(i)+1=2(2^i-1)+1=2^{i+1}-1.$$
Tím je vzorec dokázán. 

Abychom spočítali $mn$, připomeneme si definici Fibonacciho čísel. \emph{Fibonacciho} 
\emph{číslo} $F_i$ je definováno rekurencí
$$F_1=F_2=1\text{\rm\ a }F_{i+2}=F_i+F_{i+1}\text{\rm\ pro všechna }
i\ge 3.$$
Pak platí vzorec $F_i=\frac {\big(\frac {1+\sqrt 5}2\big)^i-\big
(\frac {1-\sqrt 5}2\big)^i}{\sqrt 5}$ pro všechna $i\ge 1$ 
(dokážeme si ho v části o haldách). 

Protože 
$-1<\frac {1-\sqrt 5}2<0$ a $\frac {1+\sqrt 5}2>1$, dostáváme, že 
$$\lim_{n\mapsto\infty}F_n\sqrt 5(\frac {1+\sqrt 5}2)^{-n}=1.$$
Proto existují konstanty $0<c_1<c_2$ takové, že 
$$c_1(\frac {1+\sqrt 5}2)^i<\sqrt 5F_i<c_2(\frac {1+\sqrt 5}2)^i.$$

Dokážeme, že $mn(i)=F_{i+2}-1$. Protože $F_3
=2$ a 
$F_4=3$, 
tvrzení platí pro $i=1$ a $i=2$. Dále 
\begin{align*} mn(i+2)=&mn(i+1)+mn(i)+1=\\&F_{i+3}-1+F_{i+2}-1+1=F_{i+4}-1.\end{align*}
Z toho indukcí plyne požadovaný vztah. 

Když AVL-strom $T$ o výšce $i$ reprezentuje množinu $
S$ o 
velikosti $n$, pak platí 
$$\frac {c_1}{\sqrt 5}(\frac {1+\sqrt 5}2)^{i+2}-1<F_{i+2}-1\le n
\le 2^i-1.$$
Po zlogaritmování z toho okamžitě dostáváme
$$\log(\frac {c_1}{\sqrt 5})+(i+2)\log(\frac {1+\sqrt 5}2)<\log(n
+1)<i.$$
Protože $\log(\frac {1+\sqrt 5}2)\approx 0.69\approx\frac 1{1.
44}$ dostáváme, že pro dostatečně velká $n$ 
platí, že $0.69i<\log(n+1)\le i$. Odtud plyne, že 
$\log(n+1)\le i\le 1.44\log(n)$, a tedy $i=\Theta (\log(n))$.

Operace {\bf MEMBER$(x)$} pro AVL-stromy je stejná jako 
ope\-race {\bf MEMBER$(x)$} pro nevy\-vá\-žené binární vyhledávací 
stro\-my. Aktualizační operace pro AVL-stromy nejprve provedou 
příslušnou ope\-raci pro nevyvážené binární vyhledávací stromy 
a pak násle\-du\-je jejich vyvažovací část. Při úspěšně 
provedené operaci {\bf IN\-SERT$(x)$} v nevyvážených binárních 
stromech změníme vhod\-ný list $t$ na vnitřní vrchol 
stromu reprezentující $x$ a přidáme k $t$ dva syny, kteří 
budou listy. Důsledkem je, že definujeme 
$\omega (t)=0$. Protože se však zvětšila hodnota $\eta 
(t)$ (bylo 
$\eta (t)=0$ a teď je $\eta (t)=1$), zavoláme proceduru 
{\bf Kontrola-INSERT$(t)$}, která zajistí správnou hodnotu 
funkce $\omega$ pro otce $t$. Navíc, když zjistí, že se zvětšila 
hodnota $\eta$ vrcholu otce $t$, pak zavolá sama sebe na vrchol 
otec $t$. Nejprve provedeme analýzu situace. 

Mějme vrchol $t$, jeho $\eta (t)=a$ (ale $a$ neznáme), na 
začátku 
ope\-ra\-ce {\bf INSERT} bylo $\eta (t)=a-1$.  V podstromu určeném 
vrcholem $t$ máme už správné hodnoty $\omega$.  Vrchol $
v$ je otcem $t$, 
$t=\levy(v)$ a $\omega (v)$ má ještě původní hodnotu.  

\begin{lemma}Když se hodnota $\eta (t)$ při operaci {\bf INSERT }
zvětšila a $t$ nebyl listem před operaci, pak po operaci 
neplatí $\omega (t)=0$.
\end{lemma}

Označme $u=\pravy(v)$ a uvažme případy:\newline 
A) $\omega (v)=1$, pak $\eta (u)=a$ a $\eta (v)=a+1$ se nezměnilo, 
tedy stačí položit $\omega (v)=0$.\newline 
B) $\omega (v)=0$, pak $\eta (u)=a-1$ a $\eta (v)=a+1$ se změnilo, 
tedy musíme položit $\omega (v)=-1$ a zavolat proceduru 
{\bf Kontrola-INSERT} na vrchol $v$.\newline 
C) $\omega (v)=-1$, pak $\eta (u)=a-2$ a $\eta (v)=a+1$ se změnilo. 
Nyní $\omega (v)=-2$ a to je zakázané. Označme $t_1=\levy
(t)$, 
$t_2=\pravy(t)$ ($\omega (t)=0$ nenastane, viz Lemma). 
\newline 
C1) $\omega (t)=-1$, pak $\eta (t_1)=a-1$, $\eta (t_2)=a-2$ a provedeme 
{\bf Rotace$(v,t)$}. Pak $t_2$ je druhý syn $v$ a stačí položit 
$\omega (v)=\omega (t)=0$.\newline 
C2) $\omega (t)=1$, pak $\eta (t_1)=a-2$, $\eta (t_2)=a-1$ a provedeme 
{\bf Dvojita-rotace$(v,t,t_2)$}. Pro $t_3=\levy(t_2)$ a $t_4=\pravy
(t_2)$ 
platí:\newline 
C2i) $\omega (t_2)=1\implies\eta (t_3)=a-3$ a $\eta (t_4)=a-2$ a stačí 
položit $\omega (t)=-1$, $\omega (v)=\omega (t_2)=0$, protože $
\eta (t_2)=a$.\newline 
C2ii) $\omega (t_2)=0\implies\eta (t_3)=\eta (t_4)=a-2$ a stačí položit 
$\omega (t_2)=\omega (v)=\omega (t)=0$, protože $\eta (t_2)=a$. \newline 
C2iii) $\omega (t_2)=-1\implies\eta (t_3)=a-2$ a $\eta (t_4)=a-3$ a 
stačí položit $\omega (v)=1$, $\omega (t_2)=\omega (t)=
0$, protože $\eta (t_2)=a$.\newline 
Když $t$ je pravý syn $v$, pak situace je symetrická.\newline 
Popíšeme proceduru {\bf Kontrola-INSERT}.

{\bf Kontrola-INSERT$(t)$\newline 
$v:=\otec(t)$\newline 
if} $t=\levy(v)$ {\bf then}\newline 
\phantom{---}{\bf if} $\omega (v)=1$ {\bf then}\newline 
\phantom{------}$\omega (v):=0$ \newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{---------}$\omega (v):=-1$, $t:=v$, {\bf Kontrola-INSERT}$(t)$\newline 
\phantom{------}{\bf else}\newline
\phantom{---------}{\bf if} $\omega (t)=-1$ {\bf then}\newline 
\phantom{------------}{\bf Rotace$(v,t)$}, $\omega (v):=0$, $\omega (t):=0$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$w:=\pravy(t)$, {\bf Dvojita-rotace$(v,t,w)$},\newline 
\phantom{------------}{\bf if} $\omega (w)=0$ {\bf then}\newline 
\phantom{---------------}$\omega (t):=0$, $\omega (v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------------}$\omega (v):=0$, $\omega (t):=-1$\newline 
\phantom{---------------}{\bf else}\newline 
\phantom{------------------}$\omega (v):=1$, $\omega (t):=0$\newline 
\phantom{---------------}{\bf endif}\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{------------}$\omega (w):=0$\newline 
\phantom{---------}{\bf endif}\newline
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf if} $\omega (v)=-1$ {\bf then}\newline 
\phantom{------}$\omega (v):=0$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{---------}$\omega (v):=1$, $t:=v$, {\bf Kontrola-INSERT}$(t)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}{\bf if} $\omega (t)=1$ {\bf then}\newline 
\phantom{------------}{\bf Rotace$(v,t)$}, $\omega (v):=0$, $\omega (t):=0$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$w:=\levy(t)$, {\bf Dvojita-rotace$(v,t,w)$},\newline 
\phantom{------------}{\bf if} $\omega (w)=0$ {\bf then}\newline 
\phantom{---------------}$\omega (t):=0$, $\omega (v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------------}$\omega (v):=0$, $\omega(t):=-1$\newline 
\phantom{---------------}{\bf else}\newline 
\phantom{------------------}$\omega (v):=1$, $\omega (t):=0$\newline 
\phantom{---------------}{\bf endif}\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{------------}$\omega (w):=0$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}

Všimněme si, že po provedení {\bf Rotace} nebo
{\bf Dvojita-rotace} vyvažování v operaci {\bf INSERT} končí. Tedy 
operace {\bf INSERT} provádí nejvýše jednu proceduru {\bf Rotace }
nebo {\bf Dvojita-rota\-ce}. Korektnost vyvažovací operace je 
založena na faktu, že když se zvětší hodnota $
\eta (t)$, pak 
nemůže být $\omega (t)=0$. Tento fakt se využívá  v 
{\bf if}-příkazu na 5-tém a 6-tém řádku a na 13-tém a 14-tém  
řádku programu.

Popíšeme vyvažovací operaci pro operaci 
{\bf DELETE}.  Před\-po\-kládejme, že $t$ je vrchol, jehož otec se 
odstranil (tj.  bratr $t$ byl list) a hodnota $\eta (t)$ je menší 
než byla hodnota $\eta (\otec(t))$.  Proto zavoláme proceduru 
{\bf Kontrola-DELETE$(t)$}.  Tato procedura zajistí správnou 
hodnotu funkce $\omega$ pro otce $t$.  Navíc, když zjistí, že se 
zmenšila hodnota $\eta$ vrcholu otce $t$, pak zavolá sama sebe 
na vrchol otec $t$. Popíšeme analýzu situace, na níž je 
založena korektnost procedury {\bf Kontrola-DELETE$(t)$}.  

V analýze je důležité, že když procedura {\bf Kontrola-DELETE }
přesune vrchol $x$ na místo vrcholu $y$, pak skutečná hodnota $
\eta (x)$ 
je buď původní hodnota $\eta (y)$ nebo je přesně o $
1$ menší. Všimněte si, že to platí. 

Dán vrchol $t$, jehož hodnota $\eta (t)$ se zmenšila (o $
1$).  V 
podstromu určeném vrcholem $t$ jsou hodnoty $\omega$ aktualizovány, 
$v=\otec(t)$ a $\omega (v)$ je původní.  Předpokládejme 
$t=\levy(v)$, $u=\pravy(v)$ a $\eta (t)=a$ ($a$ je neznámé).  Nastávají 
případy:\newline 
A) když $\omega (v)=1$, pak $\eta (u)=a+2$ a $\eta (v)=a+3$ (původně 
bylo $\eta (t)=a+1$).  Označme $u_1=\levy(u)$, $u_2=\pravy(u)$.\newline 
A1) $\omega (u)=1\implies\eta (u_1)=a,\,\eta (u_2)=a+1$.  Provedeme 
{\bf Rotace$(v,u)$}.  
Vrchol $u_1$ je druhým synem $v$ a platí $\eta (t)=\eta (u_
1)=a$, 
$\eta (v)=\eta (u_2)=a+1$ a $\eta (u)=a+2$.  Tedy položme $\omega 
(v)=\omega (u)=0$ a 
zavolejme {\bf Kontrola-DELETE} na vrchol $u$.\newline 
A2) $\omega (u)=0\implies\eta (u_1)=\eta (u_2)=a+1$. Provedeme 
{\bf Rotace$(v,u)$}. Vrchol $u_1$ je druhým synem $v$ a platí 
$\eta (t)=a$, $\eta (u_1)=a+1=\eta (u_2)$, $\eta (v)=a+2$, $\eta 
(u)=a+3$. Položme 
$\omega (v)=1$, $\omega (u)=-1$ a končíme.

 

A3) $\omega (u)=-1\implies\eta (u_1)=a+1,\,\eta (u_2)=a$.  Provedeme 
{\bf Dvojita-rotace$(v,u,u_1)$}.  Pro $u_3=\levy(u_1)$, 
$u_4=\pravy(u_1)$ nastanou případy:\newline 
A3i) $\omega (u_1)=-1\implies\eta (u_3)=a,\,\eta (u_4)=a-1$ a tedy 
$\eta (v)=\eta (u)=a+1$ a $\eta (u_1)=a+2$. Proto položíme 
$\omega (v)=\omega (u_1)=0$, $\omega (u)=1$ a zavoláme proceduru {\bf Kontrola-DELETE }
na vrchol $u_1$.\newline 
A3ii) $\omega (u_1)=0\implies\eta (u_3)=\eta (u_4)=a$ a tedy 
$\eta (v)=\eta (u)=a+1$ a $\eta (u_1)=a+2$. Proto položíme 
$\omega (v)=\omega (u_1)=\omega (u)=0$ a zavoláme proceduru {\bf Kontrola-DELETE }
na vrchol $u_1$.\newline 
A3iii) $\omega (u_1)=1\implies\eta (u_3)=a-1,\,\eta (u_4)=a$ a tedy 
$\eta (v)=\eta (u)=a+1$ a $\eta (u_1)=a+2$. Proto položíme 
$\omega (u)=\omega (u_1)=0$, $\omega (v)=-1$ a zavoláme proceduru {\bf Kontrola-DELETE }
na vrchol $u_1$.\newline 
B) když $\omega (v)=0$, pak $\eta (u)=a+1$ a $\eta (v)=a+2$. 
Stačí položit $\omega (v)=1$ a skončit.\newline 
C) když $\omega (v)=-1$, pak $\eta (u)=a$ a $\eta (v)=a+2$. 
Nyní položíme $\omega (v)=0$ a 
zavoláme proceduru {\bf Kontrola-DELETE} na vrchol $v$.

{\bf Kontrola-DELETE$(t)$\newline 
$v:=\otec(t)$\newline 
if} $t=\levy(v)$ {\bf then}\newline 
\phantom{---}{\bf if} $\omega (v)=1$ {\bf then}\newline 
\phantom{------}$u:=\pravy(v)$\newline 
\phantom{------}{\bf if} $\omega (u)\ge 0$ {\bf then}\newline 
\phantom{---------}{\bf Rotace$(v,u)$}\newline 
\phantom{---------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{------------}$\omega (v):=1$, $\omega (u):=-1$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$\omega (u):=\omega (v):=0$, $t:=u$, {\bf Kontrola-DELETE}$(t)$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$w:=\levy(u)$, {\bf Dvojita-rotace}$(v,u,w)$\newline 
\phantom{---------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------}$\omega (u):=0$, $\omega (v):=-1$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}{\bf if} $\omega (w):=0$ {\bf then}\newline 
\phantom{---------------}$\omega (u):=0$, $\omega(v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}$\omega (u):=1$, $\omega (v):=0$\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{---------}$\omega (w):=0$, $t:=w$, {\bf Kontrola-Delete}$(t)$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{------}$\omega (v):=1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$\omega (v):=0$, $t:=v$, {\bf Kontrola-DELETE}$(t)$\newline \phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf if} $\omega (v)=-1$ {\bf then}\newline 
\phantom{------}$u:=\levy(v)$\newline 
\phantom{------}{\bf if} $\omega (u)\le 0$ {\bf then}\newline 
\phantom{---------}{\bf Rotace}$(v,u)$\newline 
\phantom{---------}{\bf if} $\omega (u)=0$ {\bf then}\newline 
\phantom{------------}$\omega (v):=-1$, $\omega (u):=1$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$\omega (u):=\omega (v):=0$, $t:=u$, {\bf Kontrola-DELETE}$(t)$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$w:=\pravy(u)$, {\bf Dvojita-rotace$(v,u,w)$}\newline 
\phantom{---------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------}$\omega (u):=-1$, $\omega (v):=0$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}{\bf if} $\omega (w):=0$ {\bf then}\newline 
\phantom{---------------}$\omega (u):=0$, $\omega(v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}$\omega (u):=0$, $\omega (v):=1$\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{---------}$\omega (w):=0$, $t:=w$, {\bf Kontrola-Delete}$(t)$\newline
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{---------}$\omega (v):=-1$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\omega (v):=0$, $t:=v$, {\bf Kontrola-DELETE}$(t)$\newline \phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}

V operaci {\bf DELETE} se může stát, že procedury 
{\bf Rotace} nebo {\bf Dvojita-rotace} jsou volány až $\log(
|S|)$-krát. 
To je výrazný rozdíl proti operaci {\bf INSERT}. Proto operace 
{\bf DELETE} je pomalejší než operace {\bf INSERT}, i když 
asymptoticky jsou stejně rychlé. Korektnost se 
ověří přímo.

\begin{veta}Datová struktura AVL-strom 
umožňuje implementaci operací {\bf MEMBER}, {\bf INSERT} a 
{\bf DELETE}, které vyžadují čas $O(\log(|S|))$ (kde $
S$ je 
reprezentovaná množina).  Ope\-race {\bf INSERT} zavolá 
nejvýše jednu proceduru {\bf Rotace} nebo {\bf Dvo\-ji\-ta-rotace}.  
\end{veta}

\subsection{Červeno-černé stromy}

Binární vyhledávací strom $T$ reprezentující 
množinu $S$, jehož vrcholy jsou obarveny červeně nebo 
černě (každý vrchol má právě jednu barvu) tak, že jsou 
splněny podmínky:
\begin{itemize}
\item
listy jsou obarveny černě,
\item
když $v$ je vrchol obarvený červeně, pak je buď kořen 
stromu nebo jeho otec je obarven černě,
\item
všechny cesty z kořene do listů mají stejný 
počet čer\-ných vrcholů
\end{itemize}
se nazývá \emph{červeno}-\emph{černý} \emph{strom}. 

Nejprve ukážeme, že červeno-černé stromy jsou 
vyvážené stro\-my, tj. $$\hloubka(T)=O(\log(|S|).$$
Předpokládejme, že $T$ je červeno-černý strom, který má 
na cestě z kořene do listu právě $k$ černých 
vrcholů. Pak pro počet vrcholů $\#T$ 
stromu $T$ platí 
$$2^k-1\le \#T\le 2^{2k}-1.$$
Nejmenší takový strom má všechny vrcholy černě 
obarvené a je to úplný pravidelný binární strom o 
výšce $k-1$, což dává dolní odhad.  Největší takový 
strom má všechny vrcholy v sudých hladinách obarveny 
červeně a v lichých hladinách černě, je to úplný 
pravidelný binární strom o výšce $2k-1$ a tím je dán 
horní odhad. Tedy $k\le\log(1+\#T)\le 2k$.
Protože velikost $S$ je počet vnitřních vrcholů, 
dostáváme, že $\#T=2|S|+1$. Z vlastností červeno-černých 
stromů plyne, že 
$$k\le\hloubka(T)\le 2k.$$
Tedy

\begin{tvrzeni}Když červeno-černý strom $T$ 
reprezentuje množinu $S$, pak $$\hloubka(T)\le 2\log(2|S|+2)=1+\log(|S|+1).$$
\end{tvrzeni}

Pro červeno-černé stromy navrhneme algoritmy 
realizující ope\-race z uspořádaného slovní\-ko\-vého problému.  
Operace {\bf MEMBER} pro červeno-černé stromy je stejná jako pro 
nevyvážené binární vyhledávací stromy. Operace 
{\bf IN\-SERT} a {\bf DELETE} mají dvě části:  nejprve se provede 
ope\-race {\bf INSERT} nebo {\bf DELETE} pro nevyvážené binární 
vy\-hledávací stromy a pak následují vyvažovací operace, které 
zajistí, že výsledný strom splňuje pod\-mín\-ky pro červeno-černé 
stromy (stejné schéma jako pro AVL-stromy). Schéma operací 
{\bf JOIN} a {\bf SPLIT} bude vycházet z jejich realizací v $
(a,b)$-stromech. 
V operaci {\bf JOIN} prohledáváním nalezneme místo, kde se 
stromy  
dají spojit (a aplikujeme operaci {\bf JOIN} pro 
nevyvážené 
binární vyhledá\-va\-cí stromy), a pak použijeme 
vyvažovací operace. Algoritmus ope\-race {\bf SPLIT} rozdělí červeno-černý strom 
do několika menších podle cesty vyhledávající $
x$ (podobně jako 
v $(a,b)$-stromech) a na tyto stromy pak aplikuje operaci {\bf JOIN }
a zkonstruuje hledané červeno-černé stromy. Algoritmy pro 
ope\-race {\bf MIN} a {\bf MAX} jsou stejné jako pro nevyvážené binární 
vyhledávací stromy.

Nejprve popíšeme vyvažovací operace. 
Dvojice $(T,v)$ se nazývá 2-\emph{parciální}
\emph{červeno}-\emph{černý} \emph{strom}, když $T$ je 
binární vyhledávací strom, každý vrchol je obarven 
červeně nebo černě, $v$ je 
vnitřní vrchol stromu $T$ obarvený červeně a platí:
\begin{itemize}
\item
listy jsou obarveny černě,
\item
když $t$ je vrchol obarvený červeně, pak je buď kořen 
stromu nebo $t=v$ nebo jeho otec je obarven černě,
\item
všechny cesty z kořene do listů mají stejný 
počet čer\-ných vrcholů.
\end{itemize}

Vyvažování 2-parciálního červeno-černého stromu $(T',v)$ 
pro\-vá\-dí procedura {\bf Vyvaz-IN\-SERT$(v)$}.  Po jejím 
provedení buď do\-sta\-neme čer\-ve\-no-černý strom nebo 
je procedura {\bf Vyvaz-IN\-SERT} zavolána na vrchol $
v'$ takový, 
že $(T',v')$ je 2-parciální červe\-no-černý strom a $
v'$ je děd $v$ 
(tj.  je o dvě hladiny blíž ke kořeni než vrchol $
v$). 

Obarvení je realizováno rozšířením struktury vrcholu $v$ 
o boolskou proměnnou $b(v)$, kde $b(v)=0$ znamená, že $v$ je obarven 
červeně, a $b(v)=1$ znamená, že $v$ je obarven černě.

Popíšeme proceduru {\bf Vyvaz-INSERT$(v)$} (předpokládáme, že 
$v$ je obarven červeně). Pro zjednodušení $s(v
)=levy$, když $v=\levy(\otec(v))$, a $s(v)=pravy$ pro  
$v=\pravy(\otec(v))$.

{\bf Vyvaz-INSERT$(v)$}.\newline 
{\bf if} $v$ není kořen $T'$ a $b(\otec(v))=0$ {\bf then}\newline 
\phantom{---}{\bf if} $otec(v)$ je kořen {\bf then}\newline 
\phantom{------}$b(\otec(v)):=1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$w:=\otec(v)$, $u:=\bratr(w)$\newline 
\phantom{------}{\bf if} $b(u)=0$ {\bf then}\newline 
\phantom{---------}$v:=\otec(w)$, $b(w):=1$, $b(u):=1$\newline 
\phantom{---------}$b(v):=0$, {\bf Vyvaz-INSERT$(v)$} (Viz Obrázek \ref{fig3})\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$t:=\otec(w)$\newline 
\phantom{---------}{\bf if} $s(w)=s(v)$ {\bf then}\newline 
\phantom{------------}{\bf Rotace$(t,w)$}, $b(t):=0$, $b(w):=1$ (Viz Obrázek \ref{fig4})\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}{\bf Dvojita-rotace$(t,w,v)$}, $b(t):=0$, $b(v):=1$ (Viz Obrázek \ref{fig5})\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}

Na obrázku $b$ značí černou barvu a $r$ značí červenou 
barvu. Otec vrcholu $w$ je označen $t$. 


\begin{figure}[h!]
  \centerline{
    \input fig3.tex
    }
  \caption{}
  \label{fig3}
\end{figure}

\begin{figure}[h!]
  \centerline{
    \input fig4.tex
    }
  \caption{}
  \label{fig4}
\end{figure}


\begin{figure}[h!]
  \centerline{
    \input fig5.tex
    }
  \caption{}
  \label{fig5}
\end{figure}


$2$-parciální červeno-černé stromy vznikají při 
operacích {\bf INSERT} a {\bf JOIN.}  Při operaci {\bf DELETE} se poruší 
struktura červeno-černých stromů jiným 
způsobem a vznikne 3-parciální červeno-čer\-ný strom.  

Řekneme, že dvojice $(T,v)$ je \emph{3}-\emph{parciální} 
\emph{červeno}-\emph{černý} \emph{strom}, když $T$ je binární 
vy\-hledávací strom, každému vrcholu je při\-řazena právě jedna z 
dvojice barev červená -- černá, $v$ je vrchol ve stromu $
T$ a 
platí následující podmínky: 
\begin{itemize}
\item
listy a vrchol $v$ jsou obarveny černě,
\item
když $t$ je vrchol obarvený červeně, pak je buď kořen 
stromu nebo jeho otec je obarven černě,
\item
existuje číslo $k$ takové, že všechny cesty z kořene do 
listů, které neobsahují vrchol $v$, obsahují právě 
$k$ čer\-ných vrcholů, a všechny cesty z kořene do 
listů prochá\-ze\-jí\-cí vrcholem $v$ obsahují $
k-1$ černých 
vrcholů.
\end{itemize}

Popíšeme proceduru {\bf Vyvaz-DELETE$(v)$}, která se 
použije na 3-parciální červeno-černý strom $(T,v)$, když $
v$ není jeho 
kořen.  Výsledkem procedury bude buď červeno-černý strom 
nebo zavolání procedury {\bf Vyvaz-DELE\-TE$(v')$}, kde $v'$ je otcem 
vrcholu $v$.  Z faktu, že když $(T,v)$ je 3-parciální červeno-černý 
strom a $v$ je jeho kořen, pak $T$ je červeno-černý strom, plyne, 
že aplikací {\bf Vyvaz-DELETE$(v)$} na 3-parciální červeno-černý strom 
$(T,v)$ dostaneme červeno-černý strom.  

{\bf Vyvaz-DELETE$(v)$\newline 
$u:=\bratr(v)$}, $t:=\otec(v)$\newline 
{\bf if} $b(u)=0$ {\bf then}\newline 
\phantom{---}{\bf Rotace}$(t,u)$, $b(u):=1$, $b(t):=0$, $u:=\bratr(v)$\newline 
{\bf endif\newline}
(Viz Obr. \ref{fig6}, Komentář: nyní $b(u)=1$)\newline 
$w_1$ je syn $u$ takový, že $s(v)=s(w_1)$, $w_2:=\bratr(w_1)$\newline 
{\bf if} $b(w_1)=b(w_2)=1$ {\bf then}\newline 
\phantom{---}$b(u):=0$\newline 
\phantom{---}{\bf if} $b(t):=0$ {\bf then}\newline 
\phantom{------}$b(t):=1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $t$ není kořen stromu {\bf then}\newline \phantom{---------}$v:=t$, {\bf Vyvaz-DELETE}$(v)$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif} (Viz Obr. \ref{fig7})\newline 
{\bf else}\newline 
\phantom{---}{\bf if} $b(w_1)=1$ {\bf then}\newline 
(Komentář: $b(w_2)=0$)\newline 
\phantom{------}{\bf Rotace$(t,u)$}, $b(w_2):=1$, $b(u):=b(t)$, $b(t):=1$ (Viz Obr. \ref{fig8})\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf Dvojita-rotace}$(t,u,w_1)$, $b(w_1):=b(t)$, $b(t):=1$ (Viz Obr. \ref{fig9})\newline
\phantom{---}{\bf endif\newline 
endif}

V následujících obrázcích jsou vrcholy, které 
nemají specifikovanou barvu (mohou být jak červené tak černé).
Tyto barvy budeme označovat $a$, $a'$. Důvod je, že se 
tato barva může přenést do cílového stromu, ale 
i na jiný vrchol. V tomto smyslu jsou tyto barvy určeny vstupním 
stromem a specifikují tyto barvy v cílovém stromě. V Obr. \ref{fig7} 
se barva $a$ v cílovém stromě neobjevuje.


\begin{figure}[h!]
  \centerline{
    \input fig6.tex
    }
  \caption{}
  \label{fig6}
\end{figure}

\begin{figure}[h!]
  \centerline{
    \input fig7.tex
    }
  \caption{}
  \label{fig7}
\end{figure}

\begin{figure}[h!]
  \centerline{
    \input fig8.tex
    }
  \caption{}
  \label{fig8}
\end{figure}


\begin{figure}[h!]
  \centerline{
    \input fig9.tex
    }
  \caption{}
  \label{fig9}
\end{figure}

Nyní popíšeme algoritmy realizující operace {\bf INSERT}, 
{\bf DE\-LE\-TE}, {\bf JOIN3} a {\bf SPLIT} pro červeno-černé stromy.  
Před\-po\-klá\-dejme, že $T$ je červeno-černý strom reprezentující 
množinu $S$ a pro\-vá\-dí\-me operaci {\bf INSERT$(x)$} pro $
x\notin S$.  Když 
ope\-race {\bf IN\-SERT$(x)$} pro nevyvážené binární vyhledávací stro\-my 
vytvoří strom $T'$, kde vrchol $v$ reprezentuje $x$, pak $
v$ 
obar\-ví\-me červeně a syny $v$ (jsou to listy) obarvíme černě.  
Dostáváme, že $(T',v)$ je 2-parciální červeno-černý strom, a pak 
aplikujeme proceduru {\bf Vyvaz-INSERT}.  

Operace {\bf INSERT} v červeno-černých stromech 
volá nejvýše $2+\log(|S|)$-krát proceduru {\bf Vyvaz-INSERT} a 
provede nejvýše jednu rotaci nebo dvojitou rotaci.

Operace {\bf DELETE} je řešena stejným způsobem 
jako ope\-race {\bf INSERT}, ale při operaci {\bf DELETE} je porušena třetí 
pod\-mín\-ka v definici červeno-černých stro\-mů a 
vyvažování je technicky náročnější.  
Předpokádejme, že $T$ je červeno-černý strom. Když chceme 
provést operaci {\bf DELETE}, pak nejprve provedeme algoritmus {\bf DELETE} 
pro nevyvážené 
binární vyhledávací stro\-my. Při provádění jsme 
odstranili vrchol $u$ a jeho syna $w$, který je list. Na 
místo vrcholu $u$ se dostal jeho druhý syn $v$, který 
obarvíme černě. Pak jsou splněny první 
dvě podmínky v definici červeno-černých 
stromů a pokud vrchol $u$ nebo vrchol $v$ byl
obarven červeně, pak je splněna i 
třetí podmínka. Pokud vrchol $u$ i vrchol $v$ byly obarveny 
černě, pak každá cesta z kořene do listu obsahující 
vrchol $v$ má o jeden černý  vrchol méně  než cesta z 
kořene do listu neobsahující vrchol $v$ (chybí černý  
vrchol $u$), a tedy $(T,v)$ je 3-parciální červeno-černý strom. 
Nyní aplikujeme proceduru {\bf Vyvaz-DELETE}.
Analýza poskytuje rychlý test na to, zda 
vznikne červeno-černý strom nebo 3-parciální 
červeno-černý strom (pak $v$ je list). 

Mějme červeno-černé stromy $T_1$ a $T_2$ reprezentující 
množiny $S_1$ a $S_2$ a mějme prvek $x\in U$ takový, že 
$\max S_1<x<\min S_2$.  Nejprve zajistíme, že kořeny $T_
1$ i $T_2$ jsou 
obarveny černě.  Předpokládejme, že $k_i$ je počet černých 
vrcholů na cestě z kořene do listů ve stromě 
$T_i$ pro $i=1,2$.  Když $k_1=k_2$, pak stačí provést {\bf JOIN3$
(T_1,x,T_2)$ }
pro nevyvážené binární vyhledávací stromy (kořen obarvíme 
červeně).  Problém je, když $k_1\ne k_2$.  Například 
předpokládejme, že $k_1>k_2$.  Pak začneme v kořeni stromu $
T_1$ a 
jdeme po pravých synech dolů tak dlouho, až nalezneme 
černý vrchol $v$ takový, že všechny cesty z $v$ do listů 
v $T_1$ obsahují právě $k_2$ černých vrcholů.  Pak 
provedeme {\bf JOIN3} pro nevyvážené binární vyhledavací stromy 
na podstrom $T_1$ určený vrcholem $v$, na $x$ a na $T_2$. Kořen $
w$ 
vzniklého stromu obarvíme červeně a tento strom vložíme do 
$T_1$ místo podstromu určeného vrcholem $v$. Pak $(T_1,w
)$ je 
$2$-parciální červeno-černý strom a aplikujeme proceduru 
{\bf Vyvaz-INSERT}. Případ $k_2>k_1$ se řeší symetricky. 

Algoritmus pro operaci {\bf SPLIT} je velmi podobný 
algoritmu pro $(a,b)$-stromy. Vy\-hledává\-me vrchol 
reprezentující $x$. Když jsme ve vrcholu $t$ a pokračujme akcí 
$t:=\levy(t)$, pak dvojici $\key(t)$ a podstrom $T$ určený pravým 
synem $t$ vložíme do zásobníku $Z_2$, když pokračujeme akcí 
$t:=\pravy(t)$, pak do zásobníku $Z_1$ vložíme dvojici podstrom $
T$ 
určený levým synem $T$ a $\key(t)$. Když $\key(t)=x$, pak do $
Z_1$ 
vložíme podstrom určený levým synem $t$ a do $Z_2$ podstrom 
určený pravým synem $t$. Když $t$ je list, pak do $Z_1$ i $
Z_2$ vložíme 
jednoprvkové stromy. Ze zásobníku $Z_1$ pomocí operace {\bf JOIN3 }
vytvoříme strom $T_1$ a ze zásobníku $Z_2$ pomocí operace {\bf JOIN3 }
dostaneme strom $T_2$. 

Nyní popíšeme algoritmy pro tyto operace.

{\bf INSERT$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ je list {\bf then}\newline 
\phantom{---}$t$ se změní na vnitřní vrchol, $\key(t):=x$\newline 
\phantom{---}pro vrchol $t$ vytvořme syny $\levy(t)$ a $\pravy(t)$\newline 
\phantom{---}$b(t):=0$, $b(\levy(t)):=1$, $b(\pravy(t)):=1$, {\bf Vyvaz-INSERT$(t)$\newline
endif

DELETE$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ není list {\bf then}\newline 
\phantom{---}$vyv:=false$ \newline 
\phantom{---}{\bf if} $\levy(t)$ je list {\bf then}\newline 
\phantom{------}$v:=\pravy(t)$\newline 
\phantom{------}{\bf if} $b(t)=1$ a $b(v)=1$ {\bf then}\newline 
\phantom{---------}$vyv:=true$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}odstraníme vrchol $\levy(t)$, $\otec(v):=\otec(t)$\newline 
\phantom{------}{\bf if} $t=\levy(\otec(t))$ {\bf then}\newline 
\phantom{---------}$\levy(\otec(t)):=v$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(t)):=v$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$b(v):=1$, odstraníme vrchol $t$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\levy(t)$\newline 
\phantom{------}{\bf while} $\pravy(u)$ není list {\bf do} $u:=\pravy(u)$ {\bf enddo}\newline 
\phantom{------}$\key(t):=\key(u)$, $v:=\levy(u)$ \newline 
\phantom{------}{\bf if} $b(u)=1$ a $b(v)=1$ {\bf then}\newline 
\phantom{---------}$vyv:=true$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}odstraníme vrchol $\pravy(u)$, $\otec(v):=\otec(u)$\newline
\phantom{------}{\bf if} $u=\levy(\otec(u))$ {\bf then}\newline 
\phantom{---------}$\levy(\otec(u)):=v$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(u)):=v$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$b(v):=1$, odstraníme vrchol $u$\newline 
\phantom{---}{\bf endif} \newline 
\phantom{---}{\bf if} $vyv$ {\bf then Vyvaz-DELETE$(v)$ endif\newline 
endif}

{\bf JOIN3$(T_1,x,T_2)$\newline 
if} $b(\text{kořen }T_1)=0$ {\bf then} $b(\text{kořen }T_1)
:=1$ {\bf endif\newline 
if} $b(\text{kořen }T_2)=0$ {\bf then} $b(\text{kořen }T_2)
:=1$ {\bf endif}\newline 
$k_1$ je počet černých vrcholů v $T_1$ z kořene do listů \newline 
$k_2$ je počet černých vrcholů v $T_2$ z kořene do listů \newline 
{\bf if} $k_1\ge k_2$ {\bf then}\newline 
\phantom{---}$t:=\text{ kořen }T_1$, $i:=k_1-k_2$ \newline 
\phantom{---}{\bf while} $i>0$ {\bf do}\newline 
\phantom{------}$t:=\pravy(t)$\newline 
\phantom{------}{\bf if} $b(t)=1$ {\bf then} $i:=i-1$ {\bf endif}\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}vytvoř vrchol $u$, $b(u):=0$, $\key(u):=x$\newline 
\phantom{---}{\bf if} $t$ není kořen $T_1$ {\bf then}\newline 
\phantom{------}$\otec(u):=\otec(t)$, $\pravy(\otec(t)):=u$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$\otec(t):=u$, $\otec(\text{kořen }T_2):=u$ \newline 
\phantom{---}$\pravy(u):=\text{ kořen }T_2$, $\levy(u):=t$, {\bf Vyvaz-INSERT$(T_1,u)$\newline 
else}\newline 
\phantom{---}$t:=\text{kořen }T_2$, $i:=k_2-k_1$ \newline 
\phantom{---}{\bf while} $i>0$ {\bf do}\newline 
\phantom{------}$t:=\levy(t)$\newline 
\phantom{------}{\bf if} $b(t)=1$ {\bf then} $i:=i-1$ {\bf endif}\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}vytvoř vrchol $u$, $b(u):=0$, $\key(u):=x$ \newline 
\phantom{---}$\otec(u):=\otec(t)$, $\levy(\otec(t)):=u$, $\otec(t):=u$ \newline 
\phantom{---}$\otec(\text{kořen }T_1):=u$, $\levy(u):=\text{ kořen }T_1$ \newline 
\phantom{---}$\pravy(u):=t$, {\bf Vyvaz-INSERT}$(T_2,u)$\newline 
{\bf endif}

{\bf SPLIT$(x)$\newline 
$Z_1$} a $Z_2$ jsou prázdné zásobníky, $t:=\text{ kořen }T$\newline 
{\bf while} $\key(t)\ne x$ a $t$ není list {\bf do}\newline 
\phantom{---}{\bf if} $\key(t)>x$ {\bf then}\newline 
\phantom{------}vlož $(\key(t),\pravy(t))$ do $Z_2$, $t:=\levy(t)$ \newline 
\phantom{---}{\bf else}\newline 
\phantom{------}vlož $(\levy(t),\key(t))$ do $Z_1$, $t:=\pravy(t)$ \newline 
\phantom{---}{\bf endif\newline 
enddo \newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$, $T_1$ je podstrom $T$ určený $\levy(t)$ \newline 
\phantom{---}$T_2$ je podstrom $T$ určený $\pravy(t)$ \newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x\notin S$, $T_1$ a $T_2$ jsou jednoprvkové stromy\newline 
{\bf endif \newline 
while} $Z_1\ne\emptyset$ {\bf do}\newline 
\phantom{---}$(t,x)$ je na vrcholu $Z_1$, odstraň $(t,x)$ ze $Z_1$ \newline 
\phantom{---}$T'$ je podstrom $T$ určený $t$, $T_1:=${\bf JOIN3$(T',x,T_1
)$ \newline 
enddo\newline 
while} $Z_2\ne\emptyset$ {\bf do}\newline 
\phantom{---}$(x,t)$ je na vrcholu $Z_2$, odstraň $(x,t)$ ze $Z_1$ \newline 
\phantom{---}$T'$ je podstrom $T$ určený $t$, $T_2:=${\bf JOIN3$(T_2,x,T'
)$ \newline 
enddo}

Korektnost algoritmů je vidět z 
obrázků. Všimněme si při ope\-raci {\bf DELETE}, že když $
u$ je 
obarven červeně, pak po provedení {\bf Rotace$(t,u)$} bude $
(T,v)$ opět 
3-parciální červeno-černý strom a vrchol $t$ bude obarven červeně.  
Pak z Obr.  5 je vidět, že dostaneme červeno-černý 
strom. Tedy můžeme shrnout:

\begin{veta}Algoritmy operací {\bf MEMBER}, {\bf INSERT}, 
{\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, {\bf JOIN3} a {\bf SPLIT} pro červeno-černé 
stro\-my vyžadují v nejhorším případě čas $O
(\log(|S|)$, kde $S$ je 
reprezentovaná množina.  Operace {\bf INSERT} a {\bf JOIN3} zavolají 
nejvýše jednou buď {\bf Rotace} nebo {\bf Dvojita-rota\-ce} a operace 
{\bf DE\-LE\-TE} zavolá nejvýše dvakrát {\bf Rotace} nebo {\bf Rotace} a 
{\bf Dvojita-ro\-ta\-ce}.  
\end{veta}

Všimněte si, že operace {\bf JOIN3} ve skutečnosti 
vyžaduje čas $O(|k_1-k_2|+1)$. Protože $Z_1$ a $Z_2$ obsahují nejvýše 
$\log(|S|)$ položek, tak se odhad časové složitosti operace {\bf SPLIT }
prove\-de stejným způsobem jako v $(a,b)$-stromech. 
V ostatních pří\-pa\-dech je odhad časové složitosti vidět z toho, 
že $\hloubka(T)=O(\log(|S|))$ a akce na každé hladině vyžadují jen 
$O(1)$ času.

Pokud chceme mít i algoritmus pro operaci {\bf ord$
(k)$}, pak 
musíme rozšířit strukturu o funkci $p$. Pak lze použít přímo 
algoritmus pro {\bf ord$(k)$} v nevyvážených binárních vyhledávacích 
stromech. Připomeňme si, že procedury {\bf Rotace} a {\bf Dvojita-rotace }
mohou aktualizovat funkci $p$ v čase $O(1)$. Proto dostáváme 

\begin{veta}Algoritmy operací {\bf MEMBER}, 
{\bf INSERT}, {\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, {\bf JOIN3}, {\bf SPLIT} a {\bf ord$
(k)$} pro 
roz\-ší\-ře\-nou strukturu červeno-černých stromů vyžaduje 
v nejhorším případě čas $O(\log(|S|)$, kde $S$ je reprezentovaná 
množina.  Operace {\bf INSERT} a {\bf JOIN3} zavolají nejvýše jednou buď 
{\bf Rotace} nebo {\bf Dvojita-rota\-ce} a operace {\bf DELETE} zavolá nejvýše 
dvakrát {\bf Rotace} nebo jednou {\bf Rotace} a {\bf Dvojita-rotace}.  \end{veta}

Vzniká otázka, proč se tolik pozornosti věnuje 
procedurám {\bf Rotace} a {\bf Dvojita-rotace}. Sice vyžadují čas 
$O(1)$, ale jsou to nej\-složitější akce vyžadující nejvíce času. 
V mnoha aplikacích (pou\-žívají se hlavně ve výpočetní geometrii), 
tvar stromu spolu s~parametry nesou ještě 
další zakódované informace. Při změně tvaru stromu je 
třeba je přepočítat. {\bf Rotace} a {\bf Dvojita-rotace} mění tvar 
stromu, kdežto posun směrem ke kořeni pouze mění 
obarvení. V tomto případě pak {\bf Rotace} nebo {\bf Dvo\-ji\-ta-rotace }
vyžaduje čas $O(|S|)$ (obvykle je třeba prohlédnout celý 
strom) a nikoliv $O(1)$.

\subsection{Váhově vyvážené stromy}

V osmdesátých letech se ve výpočetní geometrii 
hodně použí\-va\-ly $BB(\alpha )$-stromy, proto se o nich alespoň 
orientačně zmíníme. Mějme reálné číslo $
\alpha$ takové, že 
$\frac 14<\alpha\;\le\frac {\sqrt 2}2$. Pro strom $T$ označme $
p(T)$ počet 
listů ve stromu $T$. Binární vyhledávací strom $T$ 
reprezentující množinu $S$ se nazývá $BB(\alpha )$-\emph{strom}, 
když pro každý vnitřní vrchol $v$ platí:
$$\alpha\le\frac {p(T_l)}{p (T_v)}=1-\frac {p(T_r)}{p(T_v)}\le 1-\alpha$$
kde $T_v$ je podstrom $T$ určený vrcholem $v$, $T_l$ je podstrom 
$T$ určený levým synem vrcholu $v$, $T_r$ je podstrom $T$ 
určený pravým synem vrcholu $v$. Platí

\begin{tvrzeni}Když $T$ je $BB(\alpha )$-strom reprezentující 
$n$-prvkovou množinu, pak 
$$\hloubka(T)\le 1+\frac {\log(n+1)-1}{\log\frac 1{1-\alpha}}.$$
\end{tvrzeni}

Důsledek je, že $BB(\alpha )$-stromy patří do 
skupiny vyvážených binárních vyhledávacích 
stro\-mů.  Vyvažování se provadí opět pomocí 
{\bf Rotace} a {\bf Dvojita-rotace} a popisuje ho následu\-jí\-cí 
technické tvrzení. 

\begin{tvrzeni}Pro každé $\alpha$ existuje konstanta $
d$ 
taková, že $\alpha <d<1-\alpha$ a pro každý binární vyhledávací 
strom $T$ s~kořenem $t$ splňující podmínky
\begin{enumerate}
\item
podstromy $T_l$ a $T_r$ stromu $T$ určené levým a pravým 
synem $t$ jsou $BB(\alpha )$-stromy;
\item
$\frac {p(T_l)}{p(T)}<\alpha$, ale $\alpha\le\frac {
p(T_l)}{p(T)-1}\le 1-\alpha$ nebo $\alpha\le\frac {
p(T_l)+1}{p(T)+1}\le 1-\alpha$
\end{enumerate}
platí:\newline 
když $\rho\le d$ a provedeme {\bf Rotace$(t,\pravy(t))$}, nebo když 
$\rho >d$ a provedeme proceduru {\bf Dvojita-rotace$(t,\pravy(t),\levy(\pravy(t)))$}, pak dostaneme 
$BB(\alpha )$-strom (zde $\rho =\frac {p(T')}{p(T_r
)}$ a $T'$ je určen levým synem 
pravé\-ho syna kořene $t$).  
\end{tvrzeni}

Toto tvrzení a jeho symetrické verze jednoznačně ukazují, 
jak vyvažovat $BB(\alpha )$-stromy při aktualizačních 
operacích (podstrom $BB(\alpha )$-stromu je $BB(\alpha )$-strom). Pak dostáváme:

\begin{veta}Implementace operací {\bf MEMBER}, {\bf INSERT} a {\bf DELETE }v $BB(\alpha )$-stromech vyžaduje v nejhorším 
případě čas $O(\log(|S|))$, kde $S$ je 
reprezentovaná množina.
\end{veta}

Obliba $BB(\alpha )$-stromů byla zapříčiněna 
platností následující věty, která je analogií věty o 
vyvažovacích operacích pro $(a,b)$-stromy.

\begin{veta}Když $\alpha$ je reálné číslo takové, že 
$\frac 14<\alpha <1-\frac {\sqrt 2}2$, pak existuje konstanta $c>
0$ závislá jen na 
$\alpha$ taková, že každá posloupnost operací {\bf INSERT} a {\bf DELETE }
o délce $m$ aplikovaná na prázdný $BB(\alpha )$-strom volá 
nejvýše $cm$ procedur {\bf Rotace} a {\bf Dvojita-rotace}.
\end{veta}

\subsection{Historický přehled:}

$(a,b)$-stromy zavedli Bayer a McGreght (1972),\newline 
věty o počtu vyvažovacích operací pro $(a,b)$-stromy dokázali 
Huddleston a Mehlhorn (1982).\newline 
$A$-sort analyzovali Guibas, McGreight, Plass a Roberts (1977).

Analýza interpolačního vyhledávání pochází od Perla, 
Itai a Avniho (1978),\newline 
kvadratické vyhledávání analyzovali Perl a Reingold (1977).

Adelson-Velskij a Landis (1962) definovali 
AVL-stromy,\newline 
červeno-černé stromy definovali Guibas a Sedgewick 
(1978),\newline 
verze algoritmu {\bf DELETE} pochází od Tarjana (1983).
$BB(\alpha )$-stromy zavedli Nievergelt a Reingold (1973),\newline 
věty o jejich vyvažování dokázali Blum a Mehlhorn (1980).\newline 
Priorita AVL-stromů se odráží v 
jejim hojném používání, i když červeno-černé stromy 
jsou efektivnější.

\section{Haldy}
\subsection{Úvod}

V praxi se často setkáváme s~následujícím 
problémem, který vzniká na uspořádaném univerzu, jehož 
uspořádání se však v průběhu času mění. Úloha se 
liší od slovníkového problému v tom, že se nevyžaduje  
efektivní operace {\bf MEMBER}. Dokonce se předpokládá, že ope\-race 
dostane spolu s~argumentem informaci o uložení 
zpracovávaného prvku. 
Hlav\-ním požadavkem je rychlost provedední ostatních operací a malé 
paměťové nároky. Přitom v praxi obvykle nestačí znát jen 
asymptotickou složitost, důležitou roli hraje skutečná 
rychlost, kterou však neumíme obecně spočítat, protože je závislá na 
použitém systému a hardwaru. Přesto je při použití 
následujících struktur dobré mít realistickou představu o 
skutečných rychlostech operací a podle toho si vybrat 
vhodnou strukturu. 

Zadání problému: Nechť $U$ je univerzum. Je dána množina 
$S\subseteq U$ a funkce $f:S\to\mathbb R$, kde $\mathbb R$ jsou reálná čísla (tato 
funkce realizuje uspořádání na univerzu $U$ -- pro $u,
v\in U$ platí 
$u\le v$, právě když $f(u)\le f(v)$; změna uspořádání se pak realizuje 
změnou funkce $f$).
Máme navrhnout reprezentaci $S$ a $f$, která umožňuje 
operace:\newline 
{\bf INSERT$(s,a)$} -- přidá k množině $S$ prvek $s$ tak, že 
$f(s)=a$,\newline 
{\bf MIN} -- nalezne prvek $s\in S$ s~nejmenší hodnotou 
$f(s)$,\newline 
{\bf DELETEMIN} -- odstraní prvek $s\in S$ s~nejmenší hodnotou 
$f(s)$,\newline 
{\bf DELETE$(s)$} -- odstraní prvek $s\in S$ z množiny $S$,\newline 
{\bf DECREASE$(s,a)$} -- zmenší hodnotu $f(s)$ o $a$ (tj. 
$f(s):=f(s)-a$),\newline 
{\bf INCREASE$(s,a)$} -- zvětší hodnotu $f(s)$ o $a$ (tj. 
$f(s):=f(s)+a$).\newline 
Při operaci {\bf INSERT$(s,a)$} se předpokládá, že $
s\notin S$, a tento 
předpoklad operace {\bf INSERT} neověřuje. Při operacích {\bf DE\-LE\-TE$
(s)$},
{\bf DECREASE$(s,a)$ a INCREASE$(s,a)$} se před\-pokládá, že $
s\in S$, 
a operace navíc dostává informaci, jak najít  
prvek $s$ v reprezentaci $S$ a $f$. Haldy jsou typ 
struktury, která se používá pro řešení tohoto problému. 

\emph{Halda} je stromová struktura, kde vrcholy 
reprezentují prvky z $S$ a splňují lokální podmínku na 
$f$. Obvykle se používá následující podmínka nebo její 
duální verze:

\begin{enumerate}
\item[(usp)]
Pro každý vrchol $v$ platí: když $v$ reprezentuje prvek 
$s\in S$ a $\otec(v)$ reprezentuje $t\in S$, pak $f(t)\le f(s)$.
\end{enumerate}

Probereme několik verzí hald a budeme 
předpokládat, že vždy splňují tuto podmínku a že požadavek na 
provedení operací {\bf DELETE$(s)$}, {\bf DECREA\-SE$(s,a
)$} a {\bf INCREASE$(s,a)$ }
také zadává ukazatel na vrchol repre\-zentující $s\in 
S$.  Navíc budeme 
uvažovat operace

{\bf MAKEHEAP$(S,f)$} -- operace vytvoří haldu 
reprezentující množinu $S$ a funkci $f$,\newline 
{\bf MERGE$(H_1,H_2)$} -- předpokládá, že halda $H_i$ reprezentuje 
množinu $S_i$ a funkci $f_i$ pro $i=1,2$ a $S_1\cap S_2=\emptyset$. Operace 
vytvoří haldu $H$ reprezentující $S_1\cup S_2$ a $
f_1\cup f_2$, 
přičemž neověřuje disjunktnost $S_1$ a $S_2$.

\subsection{{Regulární haldy}}

První použité haldy byly binární neboli $
2$-regulární haldy. 
Tyto haldy jsou velmi oblíbené pro svou jednoduchost a 
názornost a pro velmi efektivní implementaci.

Předpokládejme, že $d>1$ je přirozené číslo. 
$d$-\emph{regulární} \emph{strom} je kořenový strom 
$(T,r)$, pro který existuje pořadí synů 
jednotlivých vnitřních vrcholů takové, že 
očíslování vrcholů pro\-hle\-dá\-váním do šířky 
(kořen $r$ je číslován $1$) splňuje následující vlastnosti
\begin{enumerate}
\item
každý vrchol má nejvýše $d$ synů,
\item
když vrchol není list, tak všechny vrcholy s~menším 
číslem mají právě $d$ synů,
\item
když vrchol má méně než $d$ synů, pak všechny 
vrcholy s~většími čísly jsou listy.
\end{enumerate}
Toto očíslování se nazývá \emph{přirozené} 
\emph{očíslování} $d$-regulárního stromu. 

\begin{tvrzeni}Každý $d$-regulární strom má nejvýše jeden 
vrchol, který není list a má méně než $d$ synů. Když 
$d$-regulární strom má $n$ vrcholů, pak jeho 
výška je $\lceil\log_d(n(d-1)+1)\rceil$. Nechť $o$ je přirozené očíslování 
vrcholů $d$-regulárního stromu. Když pro vrchol 
$v$ je $o(v)=k$, pak vrchol $w$ je syn vrcholu $v$, právě 
když $o(w)\in \{(k-1)d+2,(k-1)d+3,\dots,kd+1\}$, a vrchol $u$ je 
otcem vrcholu $v$, právě když $o(u)=1+\lfloor\frac {k-2}d
\rfloor$. 
\end{tvrzeni}

\begin{proof}První část tvrzení plyne přímo z požadavku 2) na 
$d$-regulární strom. Má-li $d$-regulární strom výšku $
k$, 
pak má alespoň $\Sigma_{i=0}^{k-1}d^i+1$ a nejvýše $\Sigma_{
i=0}^kd^i$ 
vrcholů. Proto
$$\frac {d^k-1}{d-1}<n\le\frac {d^{k+1}}{d-1}\quad ,\quad d^k-1<n
(d-1)\le d^{k+1}-1$$
a zlogaritmováním dostaneme
$$k<\log_d(n(d-1)+1)\le k+1.$$
Odtud plyne 
druhá část tvrzení.  Třetí část pro čísla synů dokážeme 
indukcí podle očíslová\-ní.  Synové kořene mají čísla 
$2,3,\dots$,$d+1$,  protože kořen má číslo $1$.  Když tvrzení platí 
pro vrchol s~číslem $k$, pak synové vrcholu s~číslem $
k+1$ 
mají čísla $kd+2,kd+3,\dots,kd+d+1$, což odpovídá 
číslům $(k+1-1)d+2,(k+1-1)d+3,\dots,(k+1)d+1$, a tedy 
tvrzení platí. Poslední část pak plyne z toho, že když $
i\in \{(k-1)d+2,(k-1)d+3,\dots,kd+1\}$, pak 
$1+\lfloor\frac {i-2}d\rfloor =k$. \qed
\end{proof}

Všimněme si, že speciálně pro $d=2$ mají synové vrcholu s~číslem $
k$ 
čísla $2k$ a $2k+1$ a otec vrcholu s~číslem $k$ má číslo 
$\lfloor\frac k2\rfloor$. Tedy pro $2$-regulární stromy je předpis pro nalezení 
synů a otce zvláště jednoduchý.  

Řekneme, že množina $S$ s~funkcí $f$ je reprezentována 
$d$-regulár\-ní haldou $H$, kde $H$ je $d$-regulární strom $
(T,r)$, když 
přiřazení prvků množiny $S$ vrcholům stromu 
$T$ je bijekce splňující podmínku \thetag{usp}. Toto přiřazení 
je realizováno funkcí $\key$, která vrcholu přiřazuje jím 
reprezentovaný prvek.

Defince $d$-regulárního stromu umožňuje velmi efektivní 
implementace $d$-regulárních hald.  Měj\-me množinu $
S$ 
reprezentovanou $d$-regulární haldou $H$ s~přirozeným 
očís\-lo\-vá\-ním $o$ $d$-regulární\-ho stromu $
(T,r)$.  Pak haldu $H$ 
můžeme reprezentovat polem $H[1..|S|]$, kde pro vrchol 
stromu $v$, pro který $o(v)=i$, je $H(i)=(\key(v),f(\key(v))$.  Algoritmy 
budeme popisovat pro stromy, protože je to názornější.  
Přeformulovat je pro pole je snadné (viz 
očíslování synů a otce vrcholu $v$).  Pro jednoduchost 
budeme pro vrchol $v$ psát $f(v)$ místo $f(\key(v))$, neboli $
f(v)$ 
bude označovat $f(s)$, kde $s$ je reprezentován vrcholem $v$.  U 
$d$-regulárního stromu předpo\-klá\-dáme, že známe přirozené 
očíslování, a fráze `poslední vrchol', `před\-cházející vrchol' atd.  
se vztahují k tomuto očíslování.  

\subsubsection{Algoritmy}

Pro $d$-regulární haldy není známa efektivní implementace operace 
{\bf MERGE}.  Efektivní implementace 
ostatních operací jsou založeny na pomocných 
operacích {\bf UP$(v)$} a {\bf DOWN$(v)$}.  Ope\-race {\bf UP$
(v)$} posunuje 
prvek $s$ reprezentovaný vrcholem $v$ směrem ke kořeni, 
dokud vrchol reprezentující prvek $s$ nesplňu\-je podmínku 
\thetag{usp}.  Operace {\bf DOWN$(v)$} je symetrická.  

 

{\bf UP$(v)$}:\newline 
{\bf while} $v$ není kořen a $f(v)<f(\otec(v))$ {\bf do\newline 
\phantom{{\rm ---}}}vyměň $\key(v)$ a $\key(\otec(v))$\newline 
\phantom{---}$v:=\otec(v)$\newline 
{\bf enddo

DOWN$(v)$}:\newline 
{\bf if} $v$ není list {\bf then\newline 
\phantom{{{\rm ---}}}$w:=$}syn vrcholu $v$ reprezentující prvek s~nejmenší 
hodnotou $f(w)$\newline 
\phantom{---}{\bf while} $f(w)<f(v)$ a $v$ není list {\bf do\newline 
\phantom{{\rm ------}}}vyměň $\key(v)$ a $\key(w)$, $v:=w$\newline 
\phantom{------}$w:=$syn vrcholu $v$ reprezentující prvek s~nejmenší 
hodnotou $f(w)$\newline 
\phantom{---}{\bf enddo\newline 
endif

INSERT$(s)$}:\newline 
$v:=$nový poslední list, $\key(v):=s$, {\bf UP$(v)$

MIN}:\newline 
{\bf Výstup} $\key(\text{\rm kořen}(T))$

{\bf DELETEMIN}:\newline 
$v:=$poslední list, $r:=$kořen, $\key(r):=\key(v)$\newline 
odstraň $v$\newline 
{\bf DOWN$(r)$

DELETE$(s)$}:\newline 
$v:=$vrchol reprezentující $s$\newline 
$w:=$poslední list\newline 
$t:=\key(w),$ $\key(v):=t,$ odstraň $w$\newline 
{\bf if} $f(t)<f(s)$ {\bf then UP$(v)$ else DOWN$(v)$ endif

DECREASE$(s,a)$}:\newline 
$v:=$vrchol reprezentující $s$\newline 
$f(s):=f(s)-a$, {\bf UP$(v)$

INCREASE$(s,a)$}:\newline 
$v:=$vrchol reprezentující $s$\newline 
$f(s):=f(s)+a$, {\bf DOWN$(v)$

MAKEHEAP$(S,f)$}:\newline 
$T:=d$-regulární strom s~$|S|$ vrcholy\newline 
zvol libovolnou reprezentaci $S$ vrcholy stromu $T$\newline 
$v:=$poslední vrchol, který není list\newline 
{\bf while} $v$ je vrchol $T$ {\bf do\newline 
\phantom{{\rm ---}}DOWN$(v)$\newline 
\phantom{{\rm ---}}$v:=$}vrchol předcházející 
vrcholu $v$\newline 
{\bf enddo
}
Ověříme korektnost algoritmů.  Je zřejmé, že 
pomocné operace jsou korektní -- skončí, když podmínku 
\thetag{usp} splňuje prvek $s$, který byl původně 
reprezentován vrcholem $v$. Korektnost operace {\bf MIN} plyne 
přímo z podmínky \thetag{usp}, protože kořen reprezentuje nejmenší 
prvek množiny $S$. U operace {\bf INSERT} je podmínka 
\thetag{usp} splněna pro všechny vrcholy s~výjimkou nově 
vytvořeného listu a operace {\bf UP} zajistí její splnění.  Při 
operaci {\bf DELETEMIN} je pod\-mín\-ka \thetag{usp} splněna pro 
všechny vrcholy s~výjimkou kořene a v tomto případě ope\-race {\bf DOWN} zajistí 
její splnění.  Po provedení operací {\bf DE\-LE\-TE$
(s)$}, {\bf DECREASE$(s,a)$ }
a {\bf INCREASE$(s,a)$} je pod\-mín\-ka \thetag{usp} splněna pro 
všechny vrcholy s~výjimkou vrcholu $v$ a její splnění 
opět zajistí operace {\bf UP }
resp. {\bf DOWN}.  Pro operaci {\bf MAKEHEAP }
budeme uvažovat duální formulaci podmínky \thetag{usp}:  
\begin{enumerate}
\item"{(d-usp)}"
když $s$ je prvek reprezentovaný vrcholem $v$, pak 
$f(s)\le f(t)$ pro všechny prvky reprezentované syny 
vrcholu $v$. 
\end{enumerate}
Pokud každý vrchol splňuje podmínku \thetag{d-usp}, pak 
splňuje i pod\-mínku \thetag{usp}. Zřejmě každý list splňuje 
podmínku \thetag{d-usp} a když ope\-race {\bf MAKEHEAP }
provede proceduru {\bf DOWN$(v)$}, pak je podmínka 
\thetag{d-usp} splněna pro všechny vrcholy s~čísly alespoň tak velkými jako je číslo $v$. 
Operace {\bf MAKEHEAP} končí provedením operace {\bf DOWN} na 
kořen a odtud plyne její korektnost.

\subsubsection{Složitost operací}

Vypočteme časovou složitost operací:  Jeden běh cyklu 
v operaci {\bf UP} vyžaduje čas $O(1)$ a v operaci {\bf DOWN }čas $
O(d)$.  
Proto operace {\bf UP} v nejhorším případě vyžaduje čas $
O(\log_d|S|)$ 
a operace {\bf DOWN }čas $O(d\log_d|S|)$.  
Operace {\bf MIN} vyžaduje čas $O(1)$,  {\bf INSERT} a {\bf DECREASE }
vyžadu\-jí čas $O(\log_d|S|)$ a  {\bf DELETEMIN}, {\bf DELETE} a 
{\bf INCREASE }čas $O(d\log_d|S|)$.

Haldu můžeme 
vytvořit iterací operace {\bf INSERT}, což 
vyžaduje čas $O(|S|\log_d(|S|))$.  Ukáže\-me, že složitost operace 
{\bf MAKEHEAP} je menší, ale pro malé haldy je výhodnější 
provádět opakovaně operaci {\bf INSERT}.  Operace {\bf DOWN$
(v)$} na vrchol 
ve výšce $h$ vyžaduje v nej\-horším případě čas $
O(hd)$.  
Vrcholů v hloubce $i$ je nejvýše $d^i$.  
Před\-pok\-lá\-dejme, že strom má výšku $k$, pak vrchol v 
hloubce $i$ má výšku nejvýše $k-i$.  Tedy operace {\bf MAKEHEAP }
vyžaduje čas $O(\sum_{i=0}^{k-1}d^i(k-i)d)=O(\sum_{i=0}^{k-
1}d^{i+1}(k-i))$.  Oz\-nač\-me 
$A=\sum_{i=0}^{k-1}d^{i+1}(k-i)$, pak 
\begin{align*} dA-A=&\sum_{i=0}^{k-1}d^{i+2}(k-i)-\sum_{i=0}^{k-1}d^{i+
1}(k-i)=\sum_{i=2}^{k+1}d^i(k-i+2)-\sum_{i=1}^kd^i(k-i+1)=\\
&d^{k+1}+\sum_{i=2}^kd^i(k-i+2-k+i-1)-dk=d^{k+1}+\sum_{i=2}^kd^i-
dk=\\
&d^{k+1}+d^2\frac {d^{k-1}-1}{d-1}-dk.\end{align*}
Tedy $A=\frac {d^{k+1}}{d-1}+\frac {d^{k+1}-d^2}{(d-1)^2}-\frac {
dk}{d-1}$. Protože 
$k=\lceil\log_d(|S|(d-1)+1)\rceil$, 
dostáváme, že $d^{k+1}\le d^2((d-1)|S|+1)$, a proto $A\le 
2d^2|S|$. Tedy 
{\bf MAKEHEAP} vyžaduje v nejhorším případě jen čas 
$O(d^2|S|)$. 

\subsubsection{Aplikace }

Třídění: prostou posloupnost 
čísel $x_1,x_2,\dots,x_n$ lze setřídit následujícím 
algoritmem použí\-vajícím haldu ($f$ bude v tomto případě 
identická funkce).

$d${\bf -HEAPSORT$(x_1,x_2,\dots,x_n)$}:\newline 
{\bf MAKEHEAP$(\{x_i\mid i=1,2,\dots,n\},f)$\newline 
$i=1$\newline 
while} $i\le n$ {\bf do\newline 
\phantom{{\rm ---}}$y_i:=$MIN}, {\bf DELETEMIN}, $i:=i+1$\newline 
{\bf enddo\newline 
Výstup}: $y_1,y_2,\dots,y_n$

Teoreticky lze ukázat, že použití $d$-regulárních hald v 
algoritmu {\bf HEAPSORT} pro $d=3$ a $d=4$ je výhodnější 
než $d=2$. Experimenty ukázaly, že optimální 
algoritmus pro posloupnosti délek do 1 000 000 by měl  
používat $d=6$ nebo $d=7$ (v experimentech byl měřen 
skutečně spotřebovaný čas, nikoli počet porovnání a 
výměn prvků). 
Pro delší posloupnosti se optimální 
hodnota $d$ může zmenšit.

Dalším příkladem je nalezení nejkratších cest v grafu z daného 
bodu. Řešme následující úlohu: \newline 
Vstup: orientovaný ohodnocený graf $(X,R,c)$, kde $c$ je funkce z $
R$ do množiny kladných 
reálných čísel, a vrchol $z\in X$.\newline 
Úkol: nalézt pro každý bod $x\in X$ délku 
nejkratší cestu ze $z$ do $x$, kde délka cesty je součet 
$c$-ohodnocení hran na cestě.

{\bf Dijkstrův algoritmus}:\newline 
$d(z):=0$, $U:=\{z\}$\newline 
{\bf for every} $x\in X\setminus \{z\}$ {\bf do} $d(x):=+\infty$ {\bf enddo\newline 
while} $U\ne\emptyset$ {\bf do\newline 
\phantom{{\rm ---}}}najdi vrchol $u\in U$ s~nejmenší hodnotou $
d(u)$\newline 
\phantom{---}odstraň $u$ z $U$\newline 
\phantom{---}{\bf for every} $(u,v)\in R$ {\bf do \newline 
\phantom{{\rm ------}}if} $d(u)+c(u,v)<d(v)$ {\bf then\newline 
\phantom{{\rm ---------}}if} $d(v)=+\infty$ {\bf then} vlož $v$ do $
U$ {\bf endif\newline 
\phantom{{\rm ---------}}$d(v):=d(u)+c(u,v)$\newline 
\phantom{{\rm ------}}endif\newline 
\phantom{{\rm ---}}enddo\newline 
enddo
}
Korektnost algoritmu je založena na kombinatorickém 
lemmatu, které říká, že když odstra\-ňuje\-me z $
U$ prvek $x$ s~nejmenší hodnotou $d(x)$, pak vzdálenost ze $z$ do $x$ je právě 
$d(x)$. Proto když $U=\emptyset$, pak $d(x)$ jsou délky nejkratších cest ze 
$z$ do $x$ pro všechna $x\in X$. Tedy práce s~množinou $U$ vyžaduje 
nejvýše $|X|$ operací {\bf INSERT}, {\bf MIN} a {\bf DELETEMIN} a $
|R|$ operací 
{\bf DECREASE} a vždy platí $|U|\le |X|$. Vypočteme časovou složitost 
{\bf Dijkstrova algoritmu} za předpokladu, že $U$ reprezentujeme jako $
d$-regulární 
haldu. Když $d=2$, pak dostáváme, že algoritmus vyžaduje čas 
$O(|X|\log(|X|)+|R|\log(|X|))$. Když $d=\max\{2,\lfloor\frac {
|R|}{|X|}\rfloor \}$, pak algoritmus 
vyžaduje čas $O(|R|\log_d|X|)$. V případě, že $
(X,R)$ je hustý graf, 
tj. $|R|>|X|^{1+\varepsilon}$ pro $\varepsilon >0$, pak $\log_d|X
|=O(1)$ a algoritmus 
je lineární (tj. vyžaduje čas $O(|R|)$).

 
\subsection{{Leftist haldy}}

Dalším typem hald, se kterými se seznámíme, jsou lefist 
haldy (neznáme vhodný český překlad, proto zůstáváme 
u anglického názvu). Je to velmi elegantní a jednoduchý typ 
hald. Všechny operace jsou stejně jako u regulárních hald 
založeny na 
dvou základních operacích, z nichž v tomto případě hlavní je {\bf MERGE} a  
druhou je {\bf DECREASE}. Použití {\bf MERGE }
při návrhu jiných operací je běžné i v dalších haldách. 
Operace {\bf MERGE} využívá speciálních vlastností leftist 
hald a idea operace {\bf DECREASE} je stejná jako ve 
Fibonacciho haldách. Nejprve formálně popíšeme strukturu 
leftist hald. 

Mějme binární kořenový strom $(T,r)$ (to znamená, že $
r$ je kořen, 
každý vrchol má nejvýše dva syny a u každého syna 
víme, zda je to pravý nebo levý syn). Pro vrchol $v$ 
označme $\npl(v)$ délku nejkratší cesty z $v$ do vrcholu, který má 
nejvýše jednoho syna, takže např. pro list $l$ platí $\npl
(l)=0$. 

Mějme $S\subseteq U$ a funkci $f:S\to\mathbb R$. Pak binární strom 
$(T,r)$ takový, že
\begin{enumerate}
\item
když vrchol $v$ má jen jednoho syna, pak je to levý syn,
\item
když vrchol $v$ má dva syny, pak 
$$\npl(\text{\rm pravý syn }v)\le\npl(\text{\rm levý syn }v),$$
\item
existuje jednoznačné přiřazení prvků $S$  
vrcholům $T$, které splňuje podmínku \thetag{usp} 
(toto přiřazení 
je reprezentováno funkcí $\key$, která vrcholu $v$ přiřadí prvek 
z množi\-ny $S$ reprezentovaný vrcholem $v$)
\end{enumerate}
je \emph{leftist} \emph{halda} 
reprezentující množinu $S$ a funkci $f$. 

Struktura vrcholu $v$ v leftist haldě:\newline 
S vrcholem $v$ jsou 
spojeny ukazatelé $\otec(v)$, $\levy(v)$ a $\pravy(v)$ na otce a 
na levého a pravého syna vrcholu $v$.  
Když ukazatel není definován, pak píšeme, že jeho hodnota je 
$NIL$.  Dále jsou s~vrcholem spojeny funkce\newline 
$\npl(v)$ -- proměnná s~hodnotou $\npl(v)$,\newline 
$\key(v)$ -- prvek reprezentovaný vrcholem $v$,\newline 
$f(v)$ -- proměnná obsahující hodnotu $f(\key(v))$.

Uvedeme základní vlastnost leftist haldy, která 
umožňuje efektivní implementace operací. 
Posloupnost vrcholů $v_0,v_1,\dots,v_k$ se nazývá 
\emph{pravá} \emph{cesta} z vrcholu $v$, když $v=v_0$, $v_{i
+1}$ 
je pravý syn $v_i$ pro každé $i=0,1,\dots,k-1$ a $v_k$ nemá 
pravého syna. Pak podstrom vrcholu $v$ do hloubky $k$ je 
úplný binární strom a má tedy  
alespoň $2^{k+1}-1$ vrcholů. Proto platí 

\begin{tvrzeni}V leftist haldě je 
délka pravé cesty z každého vrcholu $v$ nejvýše rovna 
$$\log(\text{\rm velikost podstromu určeného vrcholem }v).$$
\end{tvrzeni}

\subsubsection{Algoritmy a složitost operací}

Základní operací pro leftist haldy je {\bf MERGE}. Tato 
operace je definována rekurzivně a hloubka rekurze je omezena 
právě délkami pravých cest.

{\bf MERGE$(T_1,T_2)$}:\newline 
{\bf if} $T_1=\emptyset$ {\bf then Výstup$=T_2$} konec {\bf endif\newline 
if} $T_2=\emptyset$ {\bf then Výstup$=T_1$} konec {\bf endif\newline 
if} $\key(\text{\rm kořen }T_1)>\key(\text{\rm kořen }T_2)$ {\bf then\newline 
\phantom{{\rm ---}}}zaměň $T_1$ a $T_2$\newline 
{\bf endif\newline 
$T':=$MERGE$(\text{{{\rm podstrom pravého syna kořene }}}T_1
,T_2)$\newline 
$\pravy(\text{\rm{{\rm kořen }}}T_1):=\text{\rm{{\rm kořen }}}
T'$\newline 
$\otec(\text{\rm {\rm kořen }}T'):=\text{\rm {\rm kořen }}T_
1$\newline 
if} $\npl(\pravy(\text{\rm kořen }T_1))>\npl(\levy(\text{\rm kořen }
T_1))$ {\bf then\newline 
\phantom{{\rm ---}}}vyměň levého a pravého syna kořene $
T_1$\newline 
{\bf endif\newline 
$\npl(\text{{\rm {\rm kořen }}}T_1):=\npl(\pravy(\text{{\rm {\rm kořen }}}
T_1)+1$

INSERT$(x)$}:\newline 
Vytvoř haldu $T_1$ reprezentující $\{x\}$\newline 
$\bold M\bold E\bold R\bold G\bold E(T,T_1)$

{\bf MIN}:\newline 
{\bf Výstup}: $\key(\text{\rm kořen }T)$

{\bf DELETEMIN}:\newline 
$T_1:=$podstrom levého syna kořene $T$\newline 
$T_2:=$podstrom pravého syna kořene $T$\newline 
{\bf MERGE$(T_1,T_2)$

MAKEHEAP$(S,f)$}:\newline 
$Q:=$prázdná fronta\newline 
{\bf for every} $s\in S$ {\bf do\newline 
\phantom{{\rm ---}}}vlož leftist haldu $T_s$ reprezentující $
\{s\}$ do $Q$\newline 
{\bf enddo\newline 
while} $|Q|>1$ {\bf do\newline 
\phantom{{\rm ---}}}vezmi haldy $T_1$ a $T_2$ z vrcholu $Q$ 
(odstraň je)\newline 
\phantom{---}{\bf MERGE$(T_1,T_2)$} vlož do $Q$\newline 
{\bf enddo
}
Vypočteme časovou složitost předchozích 
algoritmů. Každý běh 
algoritmu {\bf MERGE} (bez rekurzivního volání) vyžaduje čas 
$O(1)$. Počet rekurzivních volání je součet délek pravých 
cest, proto algoritmus {\bf MERGE} vyžaduje čas $O(\log(|S_
1|+|S_2|))$, 
kde $S_i$ je množina reprezentovaná haldou $T_i$ pro $i=1,2$.
Odtud dále plyne, že čas algoritmů {\bf INSERT} a 
{\bf DELETE\-MIN} je v 
nejhorším případě $O(\log(|S|))$. Operace {\bf MIN} vyžaduje 
čas $O(1)$. Pro odhad složitosti {\bf MA\-KEHEAP} budeme 
uvažovat, že na začátku algoritmu je na vrcholu fronty 
speciální znak, který se jen přenese na konec fronty. 
Odhadneme čas, který spotřebují {\bf while-}cykly mezi dvě\-ma 
přeneseními speciálního znaku. Předpokládejme, že se 
spe\-ciál\-ní znak přenesl po $k$-té. V tomto okamžiku 
mají všechny haldy ve frontě až na jednu velikost $2^{
k-1}$. 
Proto ve frontě $Q$ je $\big\lceil \frac {|S|}{2^{k-1}}\big\rceil $ hald a jelikož jedna operace 
{\bf MERGE} vyžadu\-je $O(k)$ času, tak {\bf while}-cykly vyžadují 
čas $O(k\frac {|S|}{2^{k-1}})$. Můžeme tedy shrnout, že operace 
{\bf MAKEHEAP} potřebuje čas 
$$O(\sum_{k=1}^{\infty}k\frac {|S|}{2^{k-1}})=O(|S|\sum_{k=1}^{\infty}\frac 
k{2^{k-1}})=O(|S|).$$
Řada $\sum_{k=1}^{\infty}$$\frac k{2^{k-1}}$ konverguje např. podle podílového d'Alambertova 
kritéria a lze jednoduše spočítat (např. stejnou metodou 
jako pro regulární haldy), že součet je $4$.

Implementace operací {\bf DECREASE} a {\bf INCREASE} pomocí 
operací {\bf UP} a {\bf DOWN} jako v $d$-regulárních haldách není 
efektivní, protože délka cesty z kořene do listu v leftist haldě 
může být až $|S|$.  Proto navrhneme pro tyto operace 
efektivnější algoritmus založený na jiném principu.  Tento princip 
je pak použit i pro Fibonacciho haldy.  

Nejprve popíšeme pomocnou operaci {\bf Oprav$(T,v
)$}, 
která vy\-tvo\-ří lef\-tist haldu z binárního stromu $
T'$ vzniklého z 
leftist haldy $T$ odtržením podstromu s~kořenem ve vrcholu $
v$.

{\bf Oprav$(T,v)$}:\newline 
$t:=\otec(v)$, $\npl(t):=0$\newline 
{\bf if} $\pravy(t)\ne v$ {\bf then} $\levy(t):=\pravy(t)$ {\bf endif\newline 
$\pravy(t):=NIL$\newline 
while} se zmenšilo $\npl(t)$ a $t$ není kořen {\bf do\newline 
\phantom{{\rm ---}}$t:=\otec(t)$\newline 
\phantom{{\rm ---}}if} $\npl(\pravy(t))>\npl(\levy(t))$ {\bf then\newline 
\phantom{{\rm ------}}}vyměň $\levy(t)$ a $\pravy(t)$\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}$\npl(t):=\npl(\pravy(t))+1$\newline 
enddo
}
Po provedení operace {\bf Oprav} mají všechny vrcholy 
správné číslo $\npl$ a podmínky kladené na leftist 
haldu jsou splněny. Tedy po provedení {\bf Oprav }
je $T$ opět leftist halda. Když $t$ je poslední vrchol, u 
kterého se zmenšilo $\npl$, pak  všechny vrcholy, kde se zmenšilo 
$\npl$, tvoří pravou cestu z vrcholu $t$. To znamená, že 
{\bf while}-cyklus se prováděl nejvýše $\log(|S|)$-krát a každý 
běh {\bf while}-cyklu vyžadoval čas $O(1)$. Proto algoritmus 
{\bf Oprav} vyžaduje čas $O(\log(|S|))$.

Popíšeme ostatní algoritmy.

{\bf DECREASE$(s,a)$}:\newline 
$v:=$prvek reprezentující $s$\newline 
$T_1$$:=$podstrom $T$ určený vrcholem $v$, $f(v):=f(v)-a$\newline 
$T_2:=${\bf Oprav$(T,v)$}, $T:=${\bf MERGE$(T_1,T_2)$

INCREASE$(s,a)$}:\newline 
$v:=$prvek reprezentující $s$\newline 
$T_1:=$podstrom $T$ určený vrcholem $\levy(v)$\newline 
$T_2:=$podstrom $T$ určený  vrcholem $\pravy(v)$\newline 
$T_3:=$leftist halda reprezentující prvek $s$\newline 
$f(v):=f(v)+a$, $T_4:=${\bf Oprav$(T,v)$}, $T_1:=${\bf MERGE$(T_1
,T_3)$\newline 
$T_2:=$MERGE$(T_2,T_4)$}, $T:=${\bf MERGE$(T_1,T_2)$

DELETE$(s,a)$}:\newline 
$v:=$prvek reprezentující $s$\newline 
$T_1:=$podstrom $T$ určený vrcholem $\levy(v)$\newline 
$T_2:=$podstrom $T$ určený  vrcholem $\pravy(v)$\newline 
$T_3:=${\bf MERGE$(T_1,T_2)$}, $T_4:=${\bf Oprav$(T,v)$\newline 
$T:=$MERGE$(T_3,T_4)$
}
Protože algoritmy {\bf MERGE} a {\bf Oprav} vyžadují čas 
$O(\log(|S|)$ a protože zbylé části algoritmů pro operace 
{\bf DECREASE}, {\bf INCREASE} a {\bf DELETE} vyžadují $O(
1)$ času, 
můžeme shrnout výsledky:  

\begin{veta}V leftist haldách existuje implementace operace 
{\bf MIN}, která v nejhorším případě vyžaduje čas $
O(1)$, 
implementace ope\-rací {\bf INSERT}, {\bf DELETEMIN}, {\bf DELETE}, 
{\bf MER\-GE}, {\bf DECREA\-SE} a {\bf INCREA\-SE}, které vyžadují v nejhorším 
pří\-pa\-dě čas $O(\log(|S|))$, a implementace operace {\bf MAKE\-HEAP},
která vyžaduje čas $O(|S|)$, kde $S$ je reprezentovaná množina.
\end{veta}

\subsection{{Amortizovaná složitost}}

Popíšeme bankovní paradigma pro počítání s~amortizovanou složitostí. Předpokládejme, že máme funkci $
h$, 
která ohodnucuje konfigurace a kvantitativně vystihuje 
jejich vhodnost pro provedení operace $o$. 
Když na konfiguraci $D$ aplikujeme operaci $o$ 
a dostaneme konfiguraci $D'$, pak amortizovaná složitost 
$am(o)$ ope\-race $o$ má vystihovat nejen časovou náročnost 
operace, ale i to, jak se změnila vhodnost konfigurace pro 
tuto operaci. Proto ji defi\-nujme jako $am(o)=t(o)+h(D')-h(D)$, kde $
t(o)$ je 
čas potřebný pro provedení operace $o$. Předpokládejme, 
že chceme provést posloupnost operací $o_1,o_2,\dots,o_n$ na 
konfiguraci $D_0$. Znázorníme si to takto:
$$D_0\to^{o_1}D_1\to^{o_2}D_2\to^{o_3}\dots\to^{o_n}D_n.$$
Předpokládejme, že pro každé $i=1,2,\dots,n$ máme odhad 
$c(o_i)$ amortizované složitos\-ti operace $o_i$, tj. $am(o_
i)\le c(o_i)$ 
pro všechna $i=1,2,\dots,n$. Pak
$$\sum_{i=1}^nam(o_i)=\sum_{i=1}^n\big(t(o_i)+h(D_i)-h(D_{i-1})\big
)=h(D_n)-h(D_0)+\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i).$$
Z toho plyne, že 
$$\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i)-h(D_n)+h(D_0).$$

Obvykle je $h(D)\ge 0$ pro všechny konfigurace $D$ 
nebo naopak $h(D)\le 0$ 
pro všechny konfigurace $D$. Když $h(D)\ge 0$, pak 
$$\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i)+h(D_0),$$
když $h(D)\le 0$, pak 
$$\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i)-h(D_n).$$
To znamená, že odhad amortizované složitosti dává také odhad 
na časovou složitost posloupnosti operací, který bývá lepší než odhad složitosti v 
nejhorším případě.  Tato skutečnost vysvětluje řadu 
případů, kdy 
výsledky byly lepší než teoretický výpočet.  Ukazuje se, že 
složitost posloupnosti operací v nejhorším případě je často podstatně 
menší než součet složitostí v nejhorším případě pro 
jednotlivé operace.  

\subsection{{Binomiální haldy}}

Další typ hald je motivován sčítaním přirozených čísel.  
Binomiální halda reprezentující $n-$prvkovou množinu se 
totiž chová 
podobně jako číslo $n$.  Tento typ hald je také po zobecnění v jistém 
smyslu vzorem pro Fibonacciho haldy.  

Pro $i=0,1,\dots$ definujeme rekurentně binomiální 
stromy $H_i$.  Jsou to kořenové stromy takové, že $H_0$ je 
jednoprvkový strom a  strom $H_{i+1}$ vznikne ze dvou 
disjunktních stromů $H_i$, kde kořen jednoho stromu  
se stane dalším synem (nejlevějším nebo nejpravějším) kořene druhého stromu.  Viz 
Obrázek. 

\begin{figure}[h!]
  \centerline{
    \input fig10.tex
    }
  \caption{Binomiální haldy}
\end{figure}

Nejprve uvedeme základní vlastnosti těchto 
stromů.

\begin{tvrzeni}Pro každé přirozené číslo $
i=0,1,\dots$ 
platí:
\begin{enumerate}
\item
strom $H_i$ má $2^i$ vrcholů,
\item
kořen stromu $H_i$ má $i$ synů,
\item
délka nejdelší cesty z kořene do listu ve stromu $H_i$ je 
$i$ (tj. výška $H_i$ je $i$),
\item
podstromy určené syny kořene stromu $H_i$ jsou izomorf\-ní 
se stromy $H_0,H_1,\dots,H_{i-1}$.
\end{enumerate}
\end{tvrzeni}

\begin{proof}Tvrzení platí pro strom $H_0$ a 
jednoduchou indukcí se dokáže i pro další stromy. 
Skutečně, když $H_i$ má $2^i$ vrcholů, pak $H_{
i+1}$ má 
$2(2^i)=2^{i+1}$ vrcholů. Kořen stromu $H_{i+1}$ má o jednoho 
syna více než kořen stromu $H_i$ a nejdelší cesta do listu je o $
1$ 
delší. Protože podstrom syna, který přibyl kořeni stromu 
$H_{i+1}$, je izomorfní s~$H_i$ a jinak se nic neměnilo, je 
důkaz kompletní. \qed
\end{proof}

\emph{Binomiální} \emph{halda} $\mathcal H$ reprezentující 
množinu $S$ je soubor (seznam) stromů $\{T_1,T_2,\dots
,T_k\}$ 
takový, že 
\begin{enumerate}
\item"{}"
celkový počet vrcholů v těchto stromech je 
roven velikosti $S$ a 
existuje a je dáno jednoznačné přiřazení prvků 
z $S$ vrcholům stromů takové, že platí 
podmínka \thetag{usp} -- toto přiřazení je realizováno 
funkcí 
$\key,$ která vrcholu stromu přiřazuje prvek jím reprezentovaný;
\item"{}"
každý strom $T_i$ je izomorfní s~nějakým stromem $H_
j$;
\item"{}"
$T_i$ není izomorfní s~žádným $T_j$ pro $i\ne j$.
\end{enumerate}

Z binárního zápisu přirozených čísel plyne, že 
pro každé přiro\-ze\-né číslo $n>0$ existuje prostá 
posloupnost $i_1,i_2,\dots,i_k$ přiro\-ze\-ných čísel taková, že 
$n=\sum_{j=1}^k2^{i_j}$. Z toho plyne, že pro každou neprázd\-nou 
množinu $S$ existuje binomiální halda repre\-zentující $
S$.
Tato halda obsahuje strom izomorfní s~$H_i$, právě když v 
binárním zápise čísla $|S|$ je na $i$-tém místě zprava $
1$.

\subsubsection{Algoritmy a složitost operací}

Operace pro binomiální haldy jsou  
stejně jako pro leftist haldy založeny na ope\-raci {\bf MER\-GE}. Ope\-race 
{\bf MERGE} pro binomiální haldy je analogií sčítání 
přirozených čísel v binár\-ním zápise.

{\bf MERGE$(\mathcal H_1,\mathcal H_2)$}:\newline 
(komentář: $\mathcal H_i$ reprezentuje množinu $S_i$ pro $i=1
,2$ a $S_1\cap S_2=\emptyset$)\newline 
$i:=0$, $T:=$prázdný strom, $\mathcal H:=\emptyset$\newline 
{\bf while} $i<\log(|S_1|+|S_2|)$ {\bf do\newline 
\phantom{{\rm ---}}if} existuje $U\in \mathcal H_1$ izomorfní s~$
H_i$ {\bf then\newline 
\phantom{{\rm ------}}$U_1:=U$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}$U_1:=$}prázdný strom\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}if} existuje $U\in \mathcal H_2$ izomorfní s~$
H_i$ {\bf then\newline 
\phantom{{\rm ------}}$U_2:=U$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}$U_2:=$}prázdný strom\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}case\newline 
\phantom{{\rm ------}}}(existuje právě jeden neprázdný strom 
$V\in \{T,U_1,U_2\}$) {\bf do}:\newline 
\phantom{---------}vlož $V$ do $\mathcal H$, $T:=$prázdný strom\newline 
\phantom{------}(existují právě dva neprázdné stromy 
$V_1,V_2\in \{T,U_1,U_2\})$ {\bf do}:\newline 
\phantom{---------}$T:=${\bf spoj$(V_1,V_2)$\newline 
\phantom{{\rm ------}}}(všechny stromy $T$, $U_1$ a $U_2$ jsou neprázdné) {\bf do}:\newline 
\phantom{---------}vlož $T$ do $\mathcal H$, $T:=${\bf spoj$(U_1,U_
2)$\newline 
\phantom{{\rm ---}}endcase\newline 
\phantom{{\rm ---}}$i:=i+1$\newline 
enddo\newline 
if} $T\ne$prázdný strom {\bf then} vlož $T$ do $\mathcal H$ {\bf endif\newline 
Výstup}:$\mathcal H$

{\bf spoj$(T_1,T_2)$}:\newline 
{\bf if} $f(\text{\rm kořen }T_1)>f(\text{\rm kořen }T_2)$ {\bf then\newline 
\phantom{{\rm ---}}}vyměň stromy $T_1$ a $T_2$\newline 
{\bf endif\newline }
vytvoř nového  syna $v$ kořene $T_1$\newline 
$v:=$kořen $T_2$

Je vidět, že když oba stromy $T_1$ a $T_2$ jsou izomorfní 
s $H_i$, pak výsledný strom operace {\bf spoj} je izomorfní 
s $H_{i+1}$. Korektnost ope\-race {\bf MERGE} plyne z tohoto 
pozorování a z faktu, že $\mathcal H_j$ obsahuje strom izomorfní s~$H_i$, právě když v binárním zápise čísla $
|S_j|$ je na $i$-tém 
místě zprava $1$, a že $T$ je neprázdný strom, když se 
provádí posun řádu při sčítání. Protože každý běh 
cyklu vyžaduje čas $O(1)$, algoritmus {\bf MER\-GE} vyžaduje čas 
$O(\log(|S_1|+|S_2|))$. Implementace dalších algoritmů 
je podobná jako pro leftist haldy. 

{\bf INSERT$(x)$}:\newline 
Vytvoř haldu $\mathcal H_1$ reprezentující $\{x\}$\newline 
$\bold M\bold E\bold R\bold G\bold E(\mathcal H,\mathcal H_1)$

{\bf MIN}:\newline 
Prohledej prvky reprezentované kořeny všech stromů 
v $\mathcal H$\newline 
{\bf Výstup}: nejmenší z těchto prvků  

{\bf DELETEMIN}:\newline 
Prohledej prvky reprezentované kořeny všech stromů 
v $\mathcal H$\newline 
$T:=$ strom, jehož kořen reprezentuje nejmenší prvek\newline 
$\mathcal H_1:=\mathcal H\setminus \{T\}$\newline 
$\mathcal H_2:=$ halda tvořená podstromy $T$ určenými syny kořene $
T$\newline 
{\bf MERGE$(\mathcal H_1,\mathcal H_2)$
}
Z podmínky \thetag{usp} je zřejmé, že 
nejmenší prvek v $S$ je reprezentován v kořeni nějakého  
stromu haldy. Tím je dána korekt\-nost operace {\bf MIN}.
Z úvodního tvrzení plyne, že $\mathcal H_2$ v operaci {\bf DELE\-TE\-MIN} je 
binomiální halda, a odtud plyne korekt\-nost ope\-race 
{\bf DE\-LE\-TEMIN}. Operace {\bf DECREASE} se implementuje pomocí 
ope\-race {\bf UP} a ope\-race {\bf INCREASE} pomocí 
operace {\bf DOWN} stejně jako v regulárních haldách. 
Struktura binomiální haldy nepodporuje přímo operaci 
{\bf DELETE} -- ta se dá realizovat jedině jako posloupnost 
operací {\bf DECREASE$(s,\infty )$} a {\bf DELETEMIN}.  
Operace {\bf MAKEHEAP} se provádí opakováním operace {\bf INSERT}.

Výpočet časové složitosti operací pro binomiální haldy 
využívá několik známých faktů.  Ope\-race {\bf MERGE }
simuluje sčítání přirozených čísel v binárním zápise a má 
tedy stejnou složitost.  Odhad složitosti vytváření haldy využívá 
známého faktu, že amortizovaná složitost přičítání $
1$  
k binárnímu číslu je $O(1)$.  
Odhad složitosti operací {\bf MIN} a {\bf DELETEMIN} je založen na 
pozorování, že binomiální halda reprezentující množinu $
S$ má 
tolik stromů, kolik je jedniček v binárním zápise $
|S|$, a 
to je nejvýše $\log(|S|)$.  

Z tvrzení také plyne, že výška všech stromů v 
binomiální haldě je $\le\log(|S|)$ a počet synů 
kořene každého stromu je 
také $\le\log(|S|)$, přičemž tento odhad se nedá zlepšit. Odtud 
dostáváme složitost operací {\bf DECREASE} a {\bf INCREASE} v nejhorším 
případě. Můžeme tedy shrnout:

\begin{veta}Pro binomiální haldy algoritmy operací 
{\bf IN\-SERT}, {\bf MIN}, {\bf DELETEMIN}, {\bf DECREASE} a {\bf MERGE  }
vy\-ža\-dují čas $O(\log(|S|))$, algoritmus operace {\bf INCRE\-ASE }
vy\-ža\-duje čas $O(\log^2(|S|))$ a algoritmus operace {\bf MAKEHEAP }čas $O(|S|)$.
\end{veta}

Z těchto výsledků je vidět, že předchozí 
typy hald mají efektivnější chování než binomiální haldy. 
Význam binomiálních hald tak spo\-čí\-vá především v 
tom, že se dají dále zobecnit (tímto zobecněním jsou Fibonacciho 
haldy) a že na nich lze krásně 
ilustrovat princip, že s~řadou úprav je výhodné počkat 
a neprovádět je okamžitě.

\subsubsection{Líná implentace operací}

Následující algoritmy jsou založeny na ideji, že 
`vyvažování' stačí provádět jen při operacích {\bf MIN} a 
{\bf DELETEMIN}, kdy je stejně zapotřebí prohledat všechny 
stromy. Z tohoto důvodu zeslabíme podmínky na 
binomiální haldy.

\emph{Líná} \emph{binomiální} \emph{halda} $\mathcal H$ 
reprezentující množinu $S$ je seznam stromů 
$\{T_1,T_2,\dots,T_k\}$ takový, že  
\begin{enumerate}
\item"{}"
celkový počet vrcholů v těchto stromech je 
roven velikosti $S$ a 
existuje jednoznačné přiřazení prvků množiny 
$S$ vrcholům stromů, které splňuje 
podmínku \thetag{usp} -- toto přiřazení je jako obvykle 
realizováno funkcí $\key$;
\item"{}"
každý strom $T_i$ je izomorfní s~nějakým stromem $H_
j$.
\end{enumerate}

V líné binomiální haldě je vynechán předpoklad 
neizo\-morf\-nosti stromů tvořících haldu. Tento fakt se 
projeví ve velmi jednoduchém algoritmu pro operaci 
{\bf MERGE}.

{\bf MERGE$(\mathcal H_1,\mathcal H_2)$}:\newline 
Proveď konkatenaci seznamů $\mathcal H_1$ a $\mathcal H_2$

Samotný algoritmus pro operaci {\bf INSERT} se nezmění, jen 
provede tuto implementaci ope\-race {\bf MER\-GE}.  Ope\-race 
{\bf MIN} a {\bf DELETE\-MIN} použijí následující pomocnou 
proceduru {\bf vyvaz}.  Jejím vstu\-pem je soubor 
seznamů $\{O_i\mid i=0,1,\dots,k\}$, kde seznam $O_i$ 
obsahuje jen stromy izomorfní se stromem $H_i$.  
Procedura {\bf vyvaz} pak z těchto stromů vytvoří 
klasickou binomiální hal\-du. 

{\bf vyvaz$(\{O_i\mid i=0,1,\dots,k\})$}:\newline 
$i:=0$, $\mathcal H:=\emptyset$\newline 
{\bf while} existuje $O_i\ne\emptyset$ {\bf do\newline 
\phantom{{\rm ---}}while} $|O_i|>1$ {\bf do\newline 
\phantom{{\rm ------}}}vezmi dva různé stromy $T_1$ a $
T_2$ z 
$O_i$\newline 
\phantom{------}odstraň je z $O_i$\newline 
\phantom{------}{\bf spoj$(T_1,T_2)$} vlož do $O_{i+1}$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}if} $O_i\ne\emptyset$ {\bf then\newline 
\phantom{{\rm ------}}}strom $T\in O_i$ odstraň z $O_i$ a vlož do $
\mathcal H$\newline 
\phantom{---}{\bf endif},\newline 
\phantom{---}$i:=i+1$\newline 
{\bf enddo\newline 
Výstup}: $\mathcal H$

{\bf MIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů  
v $\mathcal H$\newline 
{\bf Výstup}: nejmenší z těchto prvků\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\mathcal H$ izomorfní s~$H_i\}$\newline 
{\bf vyvaz$(\{O_i\mid i=0,1,\dots,\lfloor\log(|S|)\rfloor \})$

DELETEMIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů v $\mathcal H$\newline 
$T:=$ strom, jehož kořen repre\-zentuje nejmenší 
prvek\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\mathcal H$ izomorfní s~$H_i$ různé od $T\}\cup \{$podstrom $
T$ určený nějakým synem kořene $T$ 
izomorfní s~$H_i\}$\newline 
{\bf vyvaz$(\{O_i\mid i=0,1,\dots,\lfloor\log(|S|)\rfloor \})$
}Časová složitost operací {\bf INSERT} a {\bf MER\-GE} při líné 
implementaci je $O(1)$, ale časová složitost operací {\bf MIN} a 
{\bf DELETEMIN} je v nejhorším případě $O(|S|)$. Tento odhad je 
velmi špatný, ale ukážeme, že amortizovaná složitost má rozumné 
hodnoty. 
Připomínáme, že amortizovaná složi\-tost je čas operace plus 
ohodnocení výsledné struktury minus ohodnocení 
počáteční struktury. 
Konfiguraci ohodnotíme počtem stromů v 
haldě. 
Protože ope\-race {\bf MERGE} nemění počet stromů a 
protože operace {\bf INSERT} přidá jen jeden strom, je 
amortizovaná složitost operací {\bf MERGE} a {\bf INSERT} stále $
O(1)$.
Ukážeme, že amortizovaná složitost operací {\bf MIN} a {\bf DELETEMIN }
při líné implementaci binomiálních hald je $O(\log
(|S|)$. 
Protože každý běh 
vnitřního {\bf while}-cyklu v operaci {\bf vyvaz} vyžaduje čas $
O(1)$ 
a zmenší počet stromů v seznamech $O_i$ o $1$, 
ope\-ra\-ce {\bf vyvaz} vyžaduje čas $O(k+\sum_{i=0}^k|O_i|
)$. Ope\-ra\-ce {\bf MIN}
bez podprocedury {\bf vyvaz} vyžaduje čas $O(|\mathcal H|)$ a operace 
{\bf DELETEMIN} bez podprocedury {\bf vyvaz }čas $O(\mathcal H+i)$ pro 
takové $i$, že $T$ je izomorfní s~$H_i$. Podle tvrzení je $
i\le\log(|S|)$, a 
tedy ope\-ra\-ce {\bf MIN} vyžaduje čas $O(|\mathcal H|)$ a ope\-race 
{\bf DELETEMIN }čas $O(|\mathcal H|+\log(|S|))$. Protože  
ohodnocení klasické binomiální haldy je nejvýše $\log
(|S|)$ 
(obsahuje tolik stromů, kolik je $1$ v binárním zápise 
čísla $|S|$), dostáváme, že amortizovaná složitost ope\-race {\bf MIN} je 
$O(|\mathcal H|-|\mathcal H|+\log(|S|))=O(\log(|S|))$ a amortizovaná složitost 
operace {\bf DELETEMIN} je $O(|\mathcal H|+\log(|S|)-|\mathcal H|+\log(|S
|))=O(\log(|S|))$.

Protože si funkci ohodnocení volíme, 
můžeme použít takové multiplikativní 
koeficienty, aby jednotka času odpovídala jednotce v 
amortizované složitosti. Proto lze $|\mathcal H|$ od sebe odečíst.

\subsection{{Fibonacciho haldy}}

Význam Fibonacciho hald určuje fakt, že amortizovaná 
složitost operací {\bf INSERT} a {\bf DECREASE} v těchto haldách je 
$O(1)$ a amortizovaná složitost operace {\bf DELETEMIN} je $
O(\log(|S|)$. 
Proto se hodně používají v grafových algoritmech, 
kde umožňují v mnoha případech dosáhnout asymptoticky téměř lineární 
složitosti. Neznáme však žádné  
expe\-rimentální výsledky, které by porovnávaly použití Fibonacciho 
hald a např. $d$-regulárních hald v těchto grafových 
algoritmech v praxi. Takže neznáme podmínky, za 
kterých jsou Fibonacciho 
haldy lepší než třeba $d$-regulární haldy, 
ani nevíme, do jaké míry je to jen teoretický 
výsledek a do jaké míry jsou opravdu prakticky použitelné. 

Neformálně řečeno, je Fibonacciho halda množina 
stromů, jejichž některé vrcholy různé od 
kořenů jsou označeny, a kde existuje 
jednoznačná korepondence mezi prvky $S$ a vrcholy 
stromů (realizována funkcí $\key$), která splňuje 
podmínku \thetag{usp}.  Toto je však jen přibliž\-né 
vyjádření.  Existují totiž struktury, na které se tento 
popis hodí, ale 
nevznikly z prázd\-né Fibonacciho haldy aplikací 
posloupnosti haldových  
operací.  Přitom důkaz efekti\-vity Fibonacciho hald se 
dosti výrazně opírá o fakt, že halda vznikla z prázdné 
haldy aplikací algoritmů pro Fibonacciho 
haldy. Proto nejprve popíšeme algoritmy pro tyto 
ope\-race, a pak budeme
definovat \emph{Fibonacciho} \emph{haldy} jako struktury 
vzniklé z prázdné haldy aplikací posloupnosti 
těchto algoritmů.

\subsubsection{Algoritmy}

V algoritmech předpokládáme, že Fibonacciho halda je 
seznam stromů, kde některé vrcholy různé od 
kořenů jsou označeny.  Vrchol je označen, právě když není 
kořen a když mu byl někdy dříve odtržen některý jeho syn. Toto se 
nezaznamenává pro kořeny stromů. Proto když se 
vrchol stane kořenem (odtržením podstromu určeného 
tímto vrcholem),  
zapomene  se tento údaj a začne se znovu zaznamenávat, 
až když vrchol přestane 
být kořenem. Řekneme, že strom má \emph{rank} $i$, když 
jeho kořen 
má $i$ synů. Tento fakt nahrazuje test používaný 
v binomiálních 
haldách, že strom je izomorfní se stromem $H_i$. 

Algoritmy pro operace {\bf MERGE}, {\bf INSERT}, {\bf MIN} a 
{\bf DELE\-TEMIN} jsou založeny na stejných idejích jako algoritmy pro línou implementaci 
v binomiálních haldách, pouze poža\-da\-vek, aby strom byl 
izomorfní s~$H_i$, je nahrazen požadavkem, že má rank $
i$. 
Algoritmy pro ope\-race {\bf DECREASE}, {\bf INCREASE} a {\bf DELETE }
vycházejí z algoritmů pro tyto operace v leftist 
haldách. V algoritmech předpokládáme, že $c=\log^{-1}
(\frac 32)$.

{\bf MERGE$(\mathcal H_1,\mathcal H_2)$}:\newline 
Proveď konkatenaci seznamů $\mathcal H_1$ a $\mathcal H_2$

{\bf INSERT$(x)$}:\newline 
Vytvoř haldu $\mathcal H_1$ reprezentující $\{x\}$\newline 
$\bold M\bold E\bold R\bold G\bold E(\mathcal H,\mathcal H_1)$

{\bf MIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů v $\mathcal H$\newline 
{\bf Výstup}: nejmenší z těchto prvků\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\mathcal H$ s~rankem $i\}$\newline 
{\bf vyvaz1$(\{O_i\mid i=0,1,\dots,\lfloor c\log(\sqrt 5|S|+1)\rfloor 
\})$

DELETEMIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů v $\mathcal H$\newline 
$T:=$ strom, jehož kořen reprezentuje nejmenší 
prvek\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\mathcal H$ s~rankem $i$ různé od $T\}\cup \{$podstrom $T$ určený 
některým synem kořene $T$ s~rankem $i$$\}$\newline 
{\bf vyvaz1$(\{O_i\mid i=0,1,\dots,\lfloor c\log(\sqrt 5|S|+1)\rfloor 
\})$

vyvaz1$(\{O_i\mid i=0,1,\dots,k\})$}:\newline 
$i:=0$, $\mathcal H:=\emptyset$\newline 
{\bf while} existuje $O_i\ne\emptyset$ {\bf do\newline 
\phantom{{\rm ---}}while} $|O_i|>1$ {\bf do\newline 
\phantom{{\rm ------}}}vezmi dva různé stromy $T_1$ a $
T_2$ z 
$O_i$\newline 
\phantom{------}odstraň je z $O_i$\newline 
\phantom{------}{\bf spoj$(T_1,T_2)$} vlož do $O_{i+1}$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}if} $O_i\ne\emptyset$ {\bf then\newline 
\phantom{{\rm ------}}}strom $T\in O_i$ odstraň z $O_i$ a vlož ho do $
\mathcal H$\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}$i:=i+1$\newline 
enddo\newline 
Výstup}: $\mathcal H$

{\bf spoj$(T_1,T_2)$}:\newline 
{\bf if} $f(\text{\rm kořen }T_1)>f(\text{\rm kořen }T_2)$ {\bf then\newline 
\phantom{{\rm{\rm ---}}}}vyměň stromy $T_1$ a $T_2$\newline 
{\bf endif\newline }
vytvoř nového syna $v$ kořene $T_1$\newline 
$v:=$kořen $T_2$

{\bf DECREASE$(s,a)$}:\newline 
$T:=$strom v $\mathcal H$, který obsahuje vrchol reprezentující $
s$\newline 
$v:=$vrchol stromu $T$ reprezentující $s$\newline 
{\bf if} $v$ není kořen {\bf then \newline 
\phantom{{\rm ---}}}odtrhni podstrom $T'$ určený vrcholem $v$\newline 
\phantom{---}{\bf vyvaz2$(T,v)$\newline 
\phantom{{\rm ---}}if} $v$ byl označen {\bf then} zruš označení $
v$ {\bf endif\newline 
\phantom{{\rm ---}}}vlož $T'$ do $\mathcal H$\newline 
{\bf endif\newline 
$f(v):=f(v)-a$

INCREASE$(s,a)$}:\newline 
$T:=$strom v $\mathcal H$, který obsahuje vrchol reprezentující $
s$\newline 
$v:=$vrchol stromu $T$ reprezentující $s$\newline 
{\bf if} $v$ není list {\bf then \newline 
\phantom{{\rm ---}}}odtrhni podstrom $T'$ určený vrcholem $v$\newline 
\phantom{---}{\bf if} $v$ není kořen {\bf then vyvaz2$(T,v
)$ endif\newline 
\phantom{{\rm ---}}if} $v$ byl označen {\bf then} zruš označení $
v$ {\bf endif\newline 
\phantom{{\rm ---}}}zruš označení všech synů vrcholu $
v$\newline 
\phantom{---}odtrhni podstromy $T'$ určené všemi syny $v$ 
a vlož je do $\mathcal H$\newline 
\phantom{{\bf ---}}do $\mathcal H$ vlož strom mající jen vrchol $
v$\newline 
{\bf endif\newline 
$f(v):=f(v)+a$

DELETE$(s)$}:\newline 
$T:=$strom v $\mathcal H$, který obsahuje vrchol reprezentující $
s$\newline 
$v:=$vrchol stromu $T$ reprezentující $s$\newline 
{\bf if} $v$ není list {\bf then\newline 
\phantom{{\rm ---}}}zruš označení synů vrcholu $
v$\newline 
\phantom{---}odtrhni podstromy určené všemi syny 
vrcholu $v$ a vlož je do $\mathcal H$\newline 
{\bf endif\newline 
if} $v$ není kořen {\bf then vyvaz2$(T,v)$ endif\newline }
zruš vrchol $v$

{\bf vyvaz2$(T,v)$}:\newline 
$u:=\otec v$\newline 
{\bf while} $u$ je označen {\bf do\newline 
\phantom{{\rm ---}}$u':=\otec(u)$}, zruš označení $u$\newline 
\phantom{---}odtrhni podstrom $T'$ určený vrcholem $u$\newline 
\phantom{---}vlož $T'$ do $\mathcal H$, $u:=u'$\newline 
{\bf enddo\newline 
if} $u$ není kořen $T$ {\bf then} označ $u$ {\bf endif
}
Všimněme si, že když stromy $T_1$ a $T_2$ mají rank 
$i$, pak procedura {\bf spoj$(T_1,T_2)$} vytvoří strom s~rankem 
$i+1$.  Aby algoritmy pro operace {\bf MIN} a {\bf DELETEMIN} byly 
korektní, musíme ukázat, že všechny stromy ve 
Fibonacciho haldě $\mathcal H$ reprezentující množinu $
S$ mají rank 
nejvýše $c\log(\sqrt 5|S|+1)$. Jen tak zajistíme, aby výsledná 
halda reprezentovala $S$, res\-pektive 
$S\setminus \{\text{\rm prvek s~nejmenší hodnotou }f\}$.  Operace {\bf vyvaz1 }
zajišťuje, že od každého vrcholu stromu různého 
od kořene byl v tomto stromě odtržen podstrom nejvýše 
jednoho syna -- v tom případě je tento prvek označen a 
když se mu odtrhává podstrom dalšího syna, bude odtržen 
i celý podstrom tohoto vrcholu (tím se tento vrchol stane kořenem 
stromu).  Když se později stane tento vrchol zase 
vrcholem různým od kořene, celý proces se 
opakuje. 

\subsubsection{Složitost operací}

Naším cílem bude odhadnout amortizovanou složitost těchto 
operací, protože složitost v nejhorším případě není 
použitelný výsledek.  Abychom to mohli udělat, spočítáme parametry 
složitosti jednotlivých operací:  

{\bf MERGE} -- časová složitost $O(1)$, nevzniká žádný 
nový strom, 
ozna\-če\-né vrcholy se nemění;\newline 
{\bf INSERT} -- časová složitost $O(1)$, přibyl jeden strom, 
označené vrcholy se nemění;\newline 
{\bf MIN} -- časová složitost $O(|\mathcal H|)$, po provedení operace 
různé stro\-my v haldě mají různé 
ranky, označené vrcholy se nemění;\newline 
{\bf DELETEMIN} -- časová složitost $O(|\mathcal H|+\text{\rm počet synů }
v)$,
kde $v$ reprezentoval prvek s~nej\-menší hodnotou $f$. Po 
provedení ope\-ra\-ce různé stromy v haldě mají 
různé ranky, žádný nový vrchol nebyl 
označen, některé označené vrcholy přestaly být označené;\newline 
{\bf DECREASE} -- časová složitost $O(1+c)$, kde $c$ je počet 
vrcholů, které přestaly být označené. 
Bylo přidáno $1+c$ nových stromů a byl označen 
nejvýše jeden vrchol;\newline 
{\bf INCREASE} -- časová složitost $O(1+c+d)$, kde $c$ je počet 
vrcholů, které přestaly být označené, $d$ je 
počet synů vrcholu $v$ reprezentujícího prvek, 
jehož hodnota se zvyšuje. Bylo přidáno nejvýše $1
+c+d$ 
nových stromů a byl označen nejvýše jeden 
vrchol;\newline 
{\bf DELETE} -- časová složitost $O(1+c+d)$, kde $c$ je počet 
vrcholů, které přestaly být označené, $d$ je 
počet synů vrcholu $v$ reprezentujícího prvek, 
který se má odstranit. Bylo přidáno nejvýše $c+d$ 
nových stromů a byl označen nejvýše jeden 
vrchol.

Pro výpočet amortizované složitosti 
musíme nejprve navrhnout funkci ohodnocující 
konfigurace.  Při vyšetřování líné implementace binomiálních 
hald se ukázalo, že vhodným ohodnocením je počet stromů 
v haldě. Když si ale prohlédneme algoritmus pro operaci 
{\bf DECREASE}, vidíme, že zde je vhodné brát do ohodnocení i 
počet označených vrcholů, a to dokonce tak, aby 
se pokryl 
nejen čas, ale i přírůstek stromů. To vede k 
následujícímu ohodnocení konfigurace: ohodnocení je počet 
stromů v konfiguraci plus dvojnásobek počtu 
označených vrcholů.

Nechť $\rho (n)$ je maximální 
počet synů vrcholu ve Fibonacciho haldě 
reprezentující $n$-prvkovou množinu.  Pak amortizovaná 
složitost operací {\bf MERGE}, {\bf INSERT} a {\bf DECREASE} je $
O(1)$ a 
operací {\bf MIN}, {\bf DELETEMIN}, {\bf INCREASE} a {\bf DELETE} je $
O(\rho (n))$.

Abychom spočítali odhad $\rho (n)$, využijeme toho, že 
Fibonacciho halda vznikla z prázdné haldy pomocí 
popsaných algoritmů. Nejprve uvedeme jedno technické 
lemma.

\begin{lemma}Nechť $v$ je vrchol stromu ve 
Fibonacciho haldě a nechť $u$ je $i$-tý nejstarší syn 
vrcholu $v$. Pak $u$ má aspoň $i-2$ synů.
\end{lemma}

\begin{proof}V momentě, kdy se $u$ stával synem $v$, se 
aplikovala operace {\bf spoj}, $u$ a $v$ byly kořeny 
stromů a měly stejný počet synů. 
Podle předpokladů měl vrchol $v$ alespoň $i-1$ 
synů (jinak by $u$ nebyl $i$-tý nejstarší syn), a 
protože se od $u$ mohl odtrhnout jen jeden syn, 
dostáváme, že $u$ musí mít alespoň $i-2$ synů. \qed
\end{proof}

\begin{tvrzeni}Nechť $v$ je vrchol stromu ve 
Fibonacciho haldě, kte\-rý má právě $i$ synů. Pak 
podstrom určený vrcholem $v$ má aspoň $F_{i+2}$ 
vrcholů.
\end{tvrzeni}

\begin{proof}Tvrzení dokážeme indukcí 
podle maximální délky cesty z vrcholu $v$ do některého 
listu.  Tato délka je $0$, právě když $v$ je list.  V tom 
případě $v$ nemá syna a podstrom určený vrcholem $
v$ má 
jediný vrchol.  Protože $1=F_2=F_{0+2}$, tvrzení platí.  
Mějme nyní vrchol $v$, který má $k$ 
synů, a nechť maximální délka cesty z vrcholu $
v$ do 
listů je $j$. Předpokládej\-me, že tvrzení platí pro 
všechny vrcholy, pro něž tato délka  
je menší než $j$,  tedy platí i pro 
všechny syny vrcholu $v$.  Pak pro $i>1$ má $i$-tý nejstarší 
syn vrcholu $v$ podle předchozího lemmatu alespoň $i-2$ 
synů a podle indukčního předpokladu podstrom určený 
tímto synem má alespoň $F_i$ vrcholů.  Odtud 
dostáváme, že podstrom určený vrcholem $v$ má alespoň 
$$1+F_2+\sum_{i=2}^kF_i=1+\sum_{i=1}^kF_i$$
vrcholů, protože $F_1=F_2$ (na levé straně první $
1$ 
je za vrchol $v$ a 
první $F_2$ je za nejstarší vrchol). Indukcí pak dostaneme, že 
$$1+\sum_{i=1}^nF_i=F_{n+2}$$
pro všechna $n\ge 0$. Skutečně, pro $n=0$ platí 
$$1+\sum_{i=1}^0F_i=1=F_2=F_{0+2},$$
pro $n=1$ máme 
$$1+\sum_{i=1}^1F_i=1+F_1=2=F_3=F_{1+2}$$
a z indukčního předpokladu a z vlastností Fibonacciho 
čísel plyne, že 
$$1+\sum_{i=1}^nF_i=1+\sum_{i=1}^{n-1}F_i+F_n=F_{n+1}+F_n=F_{n+2}
.$$
Když shrneme tato fakta, dostáváme, že podstrom 
určený vrcholem $v$ má alespoň $F_{i+2}$ vrcholů, a 
tvrzení je dokázáno. \qed
\end{proof}

Vezměme nyní nejmenší $i$ takové, že $
n<F_i$. Protože 
posloupnost $\{F_i\}_{i=1}^{\infty}$ je rostoucí, plyne z předchozího 
tvrzení, že každý vrchol ve Fibonacciho haldě 
reprezentující $n-$prvkovou množinu má méně než $
i-2$ 
synů (když vrchol $v$ Fibonacciho haldy má $i-2$ 
synů, pak podstrom vrcholu $v$ reprezentuje 
množinu alespoň s~$F_i$ prvky). Proto $\rho (n)<i-2$. K odhadu 
velikosti $i$ použijeme explicitní vzorec 
pro $i$-té Fibonacciho číslo: 
$$F_i=\frac {\big(\frac {1+\sqrt 5}2\big)^i-\big(\frac {1-\sqrt 5}
2\big)^i}{\sqrt 5}=\frac 1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i
-\frac 1{\sqrt 5}\big(\frac {1-\sqrt 5}2\big)^i.$$
Protože $0>\frac {1-\sqrt 5}2>-\frac 34$ a protože $\sqrt 5
>2$, dostáváme, že $|\frac 1{\sqrt 5}\big(\frac {1-\sqrt 5}
2\big)^i|<\frac 38$ pro všechna 
$i=1,2,\dots$, a tedy 
$$\frac 1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i-\frac 38<F_i<\frac 
1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i+\frac 38.$$
Odtud plyne, že když $i$ splňuje 
$$n\le\frac 1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i-\frac 38,$$
pak $n<F_i$. 
Převedením $\frac 38$ na druhou stranu výrazu, jeho 
vynásobením $\sqrt 5$ a zlogaritmováním dostaneme následující 
ekvivalenci: 
$$\log_2(\sqrt 5n+\frac {3\sqrt 5}8)\le i\log_2\big(\frac {1+\sqrt 
5}2\big)\quad\Leftrightarrow\quad n\le\frac 1{\sqrt 5}\big(\frac {
1+\sqrt 5}2\big)^i-\frac 38.$$
Z $\frac {3\sqrt 5}8<1$ a z $\frac 32<\frac {1+\sqrt 5}2$ plyne, že 
$$\frac {\log_2(\sqrt 5n+\frac {3\sqrt 5}8)}{\log_2\frac {1+\sqrt 
5}2}<\frac {\log_2(\sqrt 5n+1)}{\log_2\frac 32}.$$
Tedy platí následující implikace
$$\frac {\log_2(\sqrt 5n+1)}{\log_2\frac 32}<i\quad\implies\frac {\log_
2(\sqrt 5n+\frac {3\sqrt 5}8)}{\log_2\big(\frac {1+\sqrt 5}2\big)}
<i.$$
Proto když $\frac {\log_2(\sqrt 5n+1)}{\log_23-1}<i$, pak $n<F_
i$, a tedy $\rho (n)<i-2$.

Výsledky shrneme do následující věty: 

\begin{veta}Ve Fibonacciho haldě, která   
reprezentuje $n$-prvkovou množinu, má každý vrchol 
stu\-peň menší než 
$$\frac {\log_2(\sqrt 5n+1)}{(\log_23)-1}-2.$$
Amortizovaná složitost operací {\bf INSERT}, {\bf MERGE} a {\bf DECREASE }
je $O(1)$ a amortizovaná složitost operací {\bf MIN}, 
{\bf DE\-LE\-TE\-MIN}, {\bf INCREASE} a {\bf DELETE} je $O(\log n
)$. Operace {\bf MIN }
a {\bf DELETEMIN} jsou korektní.
\end{veta}

Pro úplnost dokážeme, že $F_i=\frac {\big(\frac {
1+\sqrt 5}2\big)^i-\big(\frac {1-\sqrt 5}2\big)^i}{\sqrt 5}$ .\newline 
Pro $i=1$ platí 
$$\frac {\big(\frac {1+\sqrt 5}2\big)^1-\big(\frac {1-\sqrt 5}2\big
)^1}{\sqrt 5}=\frac {1+\sqrt 5-1+\sqrt 5}{2\sqrt 5}=\frac {2\sqrt 
5}{2\sqrt 5}=1=F_1.$$
Pro $i=2$ platí 
$$\frac {\big(\frac {1+\sqrt 5}2\big)^2-\big(\frac {1-\sqrt 5}2\big
)^2}{\sqrt 5}=\frac {1+2\sqrt 5+5-1+2\sqrt 5-5}{4\sqrt 5}=\frac {
4\sqrt 5}{4\sqrt 5}=1=F_2.$$
Indukční krok:
\begin{align*}&\frac {\big(\frac {1+\sqrt 5}2\big)^i-\big(\frac {1-\sqrt 
5}2\big)^i}{\sqrt 5}=\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}\big
(\frac {1+\sqrt 5}2\big)^2-\big(\frac {1-\sqrt 5}2\big)^{i-2}\big
(\frac {1-\sqrt 5}2\big)^2}{\sqrt 5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}\big(\frac {3+\sqrt 5}2\big
)-\big(\frac {1-\sqrt 5}2\big)^{i-2}\big(\frac {3-\sqrt 5}2\big)}{\sqrt 
5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}\big(1+\frac {1+\sqrt 5}
2\big)-\big(\frac {1-\sqrt 5}2\big)^{i-2}\big(1+\frac {1-\sqrt 5}
2\big)}{\sqrt 5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}+\big(\frac {1+\sqrt 5}
2\big)^{i-1}-\big(\frac {1-\sqrt 5}2\big)^{i-2}-\big(\frac {1-\sqrt 
5}2\big)^{i-1}}{\sqrt 5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}-\big(\frac {1-\sqrt 5}
2\big)^{i-2}}{\sqrt 5}+\frac {\big(\frac {1+\sqrt 5}2\big)^{i-1}-\big
(\frac {1-\sqrt 5}2\big)^{i-1}}{\sqrt 5}=F_{i-2}+F_{i-1}=F_i.\end{align*}
Tedy indukcí dostáváme požadovaný vztah.

\subsubsection{Aplikace }

Vrátíme se k Dijkstrově algoritmu.  
Množinu $U$ bude\-me reprezentovat pomocí Fibonacciho haldy.  
Protože ohodnocení je nezáporné a ohodnocení počáteční haldy 
je $0$, dává odhad amortizované složitosti také odhad časové 
složitosti (viz odstavec IV.).  Proto Dijkstrův 
algoritmus s~použitím 
Fibonacciho haldy vyžaduje v nejhorším případě čas 
$O(|X|(1+\log|X|)+|R|)=O(|R|+|X|\log|X|)$.  Stejný výsledek 
dostane\-me i pro konstrukci nejmenší napnuté kostry grafu.  

Otázka je, kdy v Dijkstrově algoritmu nebo v 
algoritmu konstruují\-cím nejmenší napnutou kostru použít Fibonacciho haldu a kdy 
např.  $d$-regu\-lár\-ní haldy. Lze 
říci, že Fibonacciho halda by měla být výrazně lepší pro 
větší, ale řídké grafy (tj. grafy s~malým počtem hran). 
Dá se předpokládat, že $d$-regulární haldy budou lepší 
(díky svým jednodušším algoritmům) pro husté 
grafy (tj. grafy, kde počet hran je $|X|^{1+\varepsilon}$ pro vhodné 
$\varepsilon >0$). Problém je, pro které hodnoty nastává zlom. 
Nevím o žádných experimentálních ani teoretických 
výsledcích tohoto typu.

\subsubsection{Historický přehled}

Binární neboli $2$-regulární haldy 
zavedl Williams 1964.  Jejich zobecnění na $d$-regulární haldy 
pochází od Johnsona 1975.  Leftist haldy definoval Crane 1972 a 
detailně popsal Knuth 1975.  Binomiální haldy navrhnl Vuillemin 
1978, Brown 1978 je implementoval a prokázal jejich praktickou 
použitelnost.  Fibonacciho haldy byly zavedeny Fredmanem a 
Tarjanem 1987.  

\section{{Třídicí algoritmy}}

Jednou z nejčastěji řešených úloh při práci s~daty je setřídění 
posloupnosti prvků nějakého typu. Proto velká pozornost byla a je věnována 
třídicím algoritmům řešícím tuto úlohu, která 
svým charakterem a svými 
požadavky na algoritmy je řazena do datových 
struktur. Byla navržena řada algoritmů, které se 
stále ještě analyzují a optimalizují. Analýzy jsou velmi detailní a algoritmy se 
studují za různých vstupních předpokladů. 
Kromě toho třídění je jedna z mála úloh, pro kterou 
alespoň za jistých 
předpokladů umíme spočítat dolní odhad složitosti.

Formulace úlohy:\newline 
Nechť $U$ je totálně uspořádané univerzum.\newline 
Vstup: Prostá posloupnost $\{a_1,a_2,\dots,a_n\}$ prvků z 
univerza $U$.\newline 
Výstup: Rostoucí posloupnost $\{b_1,b_2,\dots,b_n\}$ taková, že 
$\{a_i\mid i=1,2,\dots,n\}=\{b_i\mid i=1,2,\dots,n\}$.\newline 
Tento problém se nazývá \emph{třídění}. 
V praxi se setkáváme s~řadou jeho modifikací, a nichž 
asi nejběžnější je vynechání předpokladu, že 
vstupem je prostá posloupnost. Pak jsou dvě varianty 
řešení -- buď se ve výstupní posloupnosti odstraní 
duplicity nebo výstupní posloupnost zachová četnost prvků ze 
vstupní posloupnosti.

Základní algoritmy, které  řeší třídicí 
problém, jsou {\bf QUICKSORT}, {\bf MERGESORT} a {\bf HEAP\-SORT}. 

\subsubsection{HEAPSORT}

S algoritmem {\bf HEAPSORT} jsme se seznámili při 
aplikacích hald.  Byl to první algoritmus používající haldy 
(binární regulár\-ní haldy byly definovány právě při návrhu 
{\bf HEAP\-SORTU}).  Podíváme se detailněji na jednu z jeho 
implementací, která třídí takzvaně na místě. 

Třídicí algoritmy se často používají jako 
podprocedura při řešení jiných úloh. V takovém případě je 
obvykle vstupní posloupnost uložena v poli v pracovní 
paměti programu a poža\-dav\-kem  je setřídit ji 
bez použití další 
paměti pouze s~výjimkou omezeného (malého) počtu pomocných 
proměnných. Pro řešení tohoto problému se hodí 
{\bf HEAPSORT}. Zvolíme implementaci {\bf HEAPSORTU} pomocí 
$d$-regulárních hald, které jsou reprezentovány  
polem, v němž je uložena vstupní posloupnost (viz odstavec 
Aplikace v kapitole o $d$-regulárních haldách). Použijeme 
algoritmus s~jedinou změnou -- budeme požadovat duální 
podmínku na uspořádání (to znamená, že prvek reprezentovaný 
vrcholem bude menší než prvek reprezentovaný jeho 
otcem) a nahradíme operace {\bf MIN} a {\bf DELETEMIN }
operacemi {\bf MAX} a {\bf DELETEMAX}. V algoritmu vždy umístíme 
odebrané maximum na místo prvku v posled\-ním listu 
haldy (tj. prvku, který ho při operaci {\bf DELETEMAX }
nahradil) místo toho, abychom ho vložili 
do výstupní posloupnosti. Musíme si ale 
pamatovat, kde v poli končí reprezentovaná halda. Každá 
aplikace operace {\bf DELETEMAX} zkrátí počáteční úsek pole 
reprezentujícího haldu o jedno místo 
a zároveň o toto místo zvětší druhou část, ve které je uložena již 
setříděná část posloupnosti. 

{\bf HEAPSORTU} je stále věnována velká pozornost a 
bylo navrže\-no několik jeho modifikací, snažících se 
např. minimalizovat počet porovnání prvků apod.

\subsubsection{MERGESORT}

Nejstarší z uvedených algoritmů je 
{\bf MERGESORT}, který je starší než je počítačová éra, 
neboť některé jeho 
verze se používaly už při mecha\-nickém třídění. Popíšeme 
jednu jeho iterační verzi, tzv. přirozený {\bf MERGESORT}. 

{\bf MERGESORT$(a_1,a_2,\dots,a_n)$}:\newline 
$Q$ je prázdná fronta, $i=1$\newline 
{\bf while} $i\le n$ {\bf do\newline 
\phantom{{\rm ---}}$j:=i$\newline 
\phantom{{\rm ---}}while} $i<n$ a $a_{i+1}>a_i$ {\bf do} $i:=i+1$ {\bf enddo\newline 
\phantom{{\rm ---}}}posloupnost $P=(a_j,a_{j+1},\dots,a_i)$ vlož do $
Q$\newline 
\phantom{---}$i:=i+1$\newline 
{\bf enddo\newline 
while} $|Q|>1$ {\bf do\newline 
\phantom{{\rm ---}}$ $}vezmi $P_1$ a $P_2$ dvě posloupnosti z vrcholu $
Q$\newline 
\phantom{---}odstraň $P_1$ a $P_2$ z $Q$\newline 
\phantom{---}{\bf MERGE$(P_1,P_2)$} vlož na konec $Q$\newline 
{\bf enddo\newline 
Výstup}: posloupnost z $Q$

{\bf MERGE$(P_1=(a_1,a_2,\dots,a_n),P_2=(b_1,b_2,\dots,b_m))$}:\newline 
$P:=$ je prázdná posloupnost, $i:=1$, $j:=1$, $k:=1$\newline 
{\bf while} $i\le n$ a $j\le m$ {\bf do\newline 
\phantom{{\rm ---}}if} $a_i<b_j$ {\bf then\newline 
\phantom{{\rm ------}}$c_k:=a_i$}, $i:=i+1$, $k:=k+1$\newline 
\phantom{---}{\bf else\newline 
\phantom{{\rm ------}}$c_k:=b_j$}, $j:=j+1$, $k:=k+1$\newline 
\phantom{---}{\bf endif\newline 
enddo\newline 
while} $i\le n$ {\bf do\newline 
\phantom{{\rm ---}}$c_k:=a_i$}, $i:=i+1$, $k:=k+1$\newline 
{\bf enddo\newline 
while} $j\le m$ {\bf do\newline 
\phantom{{\rm ---}}$c_k:=b_j$}, $j:=j+1$, $k:=k+1$\newline 
{\bf enddo\newline 
Výstup:} $P=(c_1,c_2,\dots,c_{n+m})$

Všimněme si, že všechny posloupnosti v $Q$ jsou 
rostoucí a že sjednocením všech jejich prvků  
je vždy na začátku běhu cyklu {\bf while 
$|Q|>1$ do} množina $\{a_i\mid i=1,2,\dots,n\}$. 
Protože počet 
posloupností ve frontě $Q$ je nejvýše roven délce vstupní 
posloupnosti a každý průběh tohoto 
cyklu zmenší jejich počet o $1$, je algoritmus {\bf MERGE\-SORT} korektní.

Spočítáme časovou složitost {\bf MERGESORTU}. 
Nejprve vyšetříme slo\-ži\-tost podprocedury {\bf MER\-GE}. Protože 
určení prvku $c_k$ vyža\-du\-je čas $O(1)$ (provede se 
nejvýše jedno porovnání) a 
protože maximální hodnota $k$ je $n+m$, dostáváme, že 
podprocedura {\bf MERGE} vyžaduje čas $O(n+m)$ (nejvýše $
n+m$ 
porovnání), kde $n$ a $m$ jsou délky vstupních posloupností.

Nyní vypočteme složitost hlavní procedury. 
Zřejmě první cyklus vyžaduje lineární čas. Vyšetříme 
druhý cyklus probíhající přes frontu $Q$. Předpokládejme, že před prvním během 
tohoto cyklu je na vrcholu $Q$ speciální znak $\natural$, který se vždy 
pouze přenese z vrcholu $Q$ na její konec. Protože mezi dvěma 
přenosy $\natural$ projde každý prvek vstupní posloupnosti 
podprocedurou {\bf MERGE} právě jednou, vyžadují jednotlivé běhy cyklu 
čas $O(n)$, kde 
$n$ je délka vstupní posloupnosti (a zároveň součet všech délek 
posloupností v $Q$). Všech\-ny posloupnosti v $Q$ mají  
na počátku délku $\ge 1$. Odtud jednoduchou indukcí 
dostaneme, že po $i$-tém přenosu znaku $\natural$ mají 
délku $\ge 2^{i-1}$. Proto počet přenosů je 
nejvýše $\lceil\log_2n\rceil$, a tedy algoritmus {\bf MERGESORT }
vyžaduje čas $O(n\log n)$ (provede se nejvýše $n\log n$ 
porovnání).

Vzhledem k 
počtu porovnání je {\bf MERGESORT} optimální třídicí algoritmus. 
Navíc v této verzi je adaptivní na předtříděné 
posloupnosti, které mají jen malý počet dlouhých 
setříděných úseků (běhů). Při 
konstantním počtu běhů má složitost $O(n)$. Jiná 
jeho verze, která začíná slévání vždy od 
jednoprvkových posloupností (tzv. přímý {\bf MERGESORT}) 
tuto vlastnost nemá. 

\subsubsection{QUICKSORT}

Nyní popíšeme patrně vůbec 
nejpoužívanější třídicí algoritmus, kterým je {\bf QUICKSORT}. 
Důvodem je, že pro obecnou posloupnost je 
nejrychlejší, při rovnoměrném rozložení vstupních 
polsoupností má nejmenší očekávaný čas. 

{\bf Quick$(a_i,a_{i+1},\dots,a_j)$}:\newline 
{\bf if} $i=j$ {\bf then\newline 
\phantom{{\rm ---}}Výstup}: $(a_i)$\newline 
{\bf else\newline 
\phantom{{\rm ---}}}zvol $k$ takové, že $i\le k\le j$, $a:=a_k$, 
vyměň $a_i$ a $a_k$, $l:=i+1$, $q:=j$\newline 
\phantom{---}{\bf while} true {\bf do\newline 
\phantom{{\rm ------}}while} $a_l<a$ {\bf do} $l:=l+1$ {\bf enddo\newline 
\phantom{{\rm ------}}while} $a_q>a$ {\bf do} $q:=q-1$ {\bf enddo\newline 
\phantom{{\rm ------}}if} $l\ge q$ {\bf then\newline 
\phantom{{\rm ---------}}}exit\newline 
\phantom{------}{\bf else\newline 
\phantom{{\rm ---------}}}vyměň $a_l$ a $a_q$, $l:=l+1$, $q
:=q-1$\newline 
\phantom{{\rm------}}{\bf endif\newline 
\phantom{{\rm ---}}enddo\newline 
\phantom{{\rm---}}if} $i+1=l$ {\bf then\newline 
\phantom{{\rm ------}}Výstup$(a,$Quick$(a_{q+1},a_{q+2},\dots,a_
j))$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}if} $j=q$ {\bf then\newline 
\phantom{{\rm ---------}}Výstup$($Quick$(a_{i+1},a_{i+2},\dots,
a_{l-1}),a)$\newline 
\phantom{{\rm ------}}else\newline 
\phantom{{\rm ---------}}Výstup$($Quick$(a_{i+1},a_{i+2},\dots,
a_{l-1}),a,$Quick$(a_{q+1},\dots,a_j))$\newline 
\phantom{{\rm ------}}endif\newline 
\phantom{{\rm ---}}endif\newline 
endif

QUICKSORT$(a_1,a_2,\dots,a_n)$}:\newline 
{\bf Výstup$($Quick$(a_1,a_2,\dots,a_n))$
}
Algoritmus {\bf Quick} setřídí posloupnost 
$(a_i,a_{i+1},\dots,a_j)$ tak, že pro prvek $a=a_k$ vytvoří posloupnost 
$(a_i,a_{i+1},\dots,a_{l-1})$ všech prvků menších než $
a$ 
a posloupnost
$(a_{q+1},\dots,a_j)$ všech prvků 
větších než $a$. Na tyto posloupnosti pak 
zavolá sám sebe a do výsledné posloupnosti uloží 
nejprve setříděnou první posloupnost, pak prvek $a$ a nakonec 
setříděnou druhou posloupnost. Korektnost procedury 
{\bf Quick}  i algoritmu {\bf QUICKSORT} je tedy zřejmá, protože 
$l\le j$ a $i\le q$. 

Procedura {\bf Quick} bez rekurzivního volání 
vyžaduje čas $O(j-i)$. Tedy kdyby $a_k$ byl medián (tj. 
prostřední prvek) posloupnosti $(a_i,a_{i+1},\dots,a_j)$, pak 
by algoritmus {\bf QUICKSORT} v nejhorším případě vy\-žadoval čas $
O(n\log n)$. Jak 
uvidíme později, medián lze sice nalézt v lineár\-ním čase, ale 
použití jakékoli procedury pro jeho nalezení má za 
následek, že algoritmy {\bf MERGESORT} a {\bf HEAPSORT }
budou rychlejší (nikoliv asymptoticky, ale 
multiplikativní konstanta bude v tomto případě vysoká). Proto je třeba 
vybrat prvek $a_k$ (tzv. pivot) co 
nejrychleji. Původně se bral první nebo 
poslední prvek posloupnosti. Při této volbě a při 
rovnoměrném rozdělení vstupů je 
očekávaný čas {\bf QUICKSORTU} $O(n\log n)$ a algoritmus je 
obvykle rychlejší než {\bf MERGESORT} a 
{\bf HEAPSORT}. Avšak čas v nejhorším případě je 
kvadratický a dokonce pro určitá rozdělení vstupních dat 
je i očekávaný čas kvadratický. 
Proto tuto volbu pivota není vhodné používat pro úlohy, kdy 
neznáme rozdělení vstupních dat (mohlo by se stát, že je 
nevhodné). Jednoduše to lze napravit tak, že budeme volit $
k$ náhodně. Bohužel 
použití pseudonáhodného generátoru také vyžaduje jistý čas, a pak 
už by algoritmus zase nemusel být rychlejší než algoritmy 
{\bf MERGESORT} a {\bf HEAPSORT} (navíc takto náhodně zvolený 
prvek není skutečně náhodný, ale to v tomto případě 
nevadí). Důsledkem je návrh vybírat pivota jako 
medián ze tří nebo pěti pevně zvolených prvků 
posloupnosti. Praxe ukázala, že tento výběr pivota je 
nej\-praktičtější, dá se provést rychle a zajišťuje 
dostatečnou ná\-hod\-nost.

Protože při každém volání má {\bf Quick} jako 
argument kratší 
vstupní posloupnost, lze ukázat, že:
\begin{enumerate}
\item{}při každé volbě 
pivota je nejhorší čas algoritmu {\bf QUICKSORT} $O(n^2
)$,
\item{}pokud je pivot vybrán jedno\-du\-chým a rychlým 
způsobem (to platí, i když se volí náhodně), pak 
exi\-stují vstupní posloupnosti, které vyžadují čas $
O(n^2)$,
\item{}očekávaný čas je $O(n\log n)$.
\end{enumerate}

Následná analý\-za očekávaného případu  
je pro ná\-hod\-ně zvoleného pivota (bez dalšího před\-pokladu na 
vstupní data) nebo pro případ, kdy pivot je pevně zvolen a data jsou 
rovno\-měrně rozdě\-lena.

Ukážeme dva způsoby výpočty očekávaného času.  Jeden 
je založen na několika jednoduchých pozorováních a není v 
něm mnoho počítání, druhý na rekurzivním výpočtu. Ten 
je početně náročnější, ale postup je standardní. Hlavní idea v obou 
případech spočívá v tom, že  
očekávaný čas algoritmu {\bf QUICKSORT} je úměrný 
očekávanému počtu porovnání v algoritmu {\bf QUICKSORT}.
Tento fakt plyne přímo z popisu algoritmu.  Budeme 
tedy počítat  
očeká\-vaný počet porovnání pro algoritmus {\bf QUICKSORT}.  

První způsob výpočtu:\newline 
Každé dva prvky $a_i$ a $a_j$ algoritmus {\bf QUICKSORT} porovná 
při třídění posloupnosti $(a_1,a_2,\dots,a_n)$ nejvýše jednou, 
přičemž když porovnává $a_i$ a $a_j$, 
pak pro nějaký běh podprocedury {\bf Quick} je $a_i$ nebo $
a_j$ 
pivot, ale v předchozích bězích {\bf Quick} $a_i$ ani $
a_j$ 
nebyl pivotem (protože pivot je vždy vyřazen z následujících 
volání této podprocedury).

Nechť $(b_1,b_2,\dots,b_n)$ je výsledná posloupnost.  
Označme $X_{i,j}$ boolskou proměnou, která má hodnotu $
1$, 
když {\bf QUICKSORT} provedl porovnání mezi prvky $b_i$ a $
b_j$, a 
jinak má hodnotu $0$.  Předpokládejme, že je to náhodná 
veličina. Když $p_{i,j}$ je prav\-dě\-podobnost, že $
X_{i,j}=1$, 
pak očekávaná hodnota $X_{i,j}$ je 
$$\bold E(X_{i,j})=0(1-p_{i,j})+1p_{i,j}=p_{i,j}.$$
Protože počet porovnání  při běhu algoritmu {\bf QUICKSORT} je
$$\sum_{i=1}^n\sum_{j=i+1}^nX_{i,j}$$
a protože očekávaná hodnota součtu náhodných 
proměnných je součtem očekávaných hodnot, dostáváme, že 
očekávaný počet porovnání v algoritmu {\bf QUICKSORT} je
$$\sum_{i=1}^n\sum_{j=i+1}^n\bold E(X_{i,j})=\sum_{i=1}^n\sum_{j=
i+1}^np_{i,j}.$$

Abychom spočítali $p_{i,j}$, popíšeme chování algoritmu 
{\bf QUICKSORT} pomocí modifikace stromu výpočtu. Bude to binární 
strom, v němž každý vrchol odpovídá jednomu 
běhu podprocedury {\bf Quick}. Vrchol $v$ bude vnitřním 
vrcholem, 
když odpovída\-jí\-cí podprocedura volila pivota, a tento 
pivot bude ohodnocením $v$. V podstromu levého syna vrcholu $
v$
budou právě všechna následující rekurzivní volání podprocedury 
{\bf Quick} nad částí posloupnosti, která předchází pivotu. 
Analogicky v podstromu 
pravého syna vrcholu $v$ budou právě všechna následující 
rekurzivní volání procedury {\bf Quick} nad částí 
posloupnosti, která následuje po pivotu. 
Listy stromu odpovídají volání procedury {\bf Quick} nad 
jednoprvkovými posloupnost\-mi a každý takový jednotlivý 
prvek ohodnocuje příslušný  
list. Když vrchol $v$ odpovídá volání {\bf Quick} nad posloupností 
$(a_i,a_{i+1},\dots,a_j)$, pak vrcholy v podstromu levého syna $
v$ jsou 
ohodnoceny prvky z posloupnosti $(a_i,a_{i+1},\dots,a_{l-1})$ a vrcholy v 
podstromu pravého syna vrcholu $v$ jsou ohodnoceny prvky z posloupnosti 
$(a_{q+1},\dots,a_j)$ (po přerovnání).
Dále platí $\{a_l\mid i\le l\le j\}=\{b_l\mid i\le l\le j\}$.

Očíslujeme vrcholy tohoto stromu prohledáváním do 
šířky za předpokladu, že levý syn vrcholu předchází 
pravému synu. Nechť $(c_1,c_2,\dots,c_n)$ je posloupnost 
prvků $\{a_i\mid 1\le i\le n\}$ v pořadí daném tímto 
očíslováním. Pak platí, že $X_{i,j}=1$, právě když první 
prvek v posloupnosti $(c_1,c_2,\dots,c_n)$ z množi\-ny 
$\{b_l\mid i\le l\le j\}$ je buď $b_i$ nebo $b_j$. Pravděpodobnost tohoto 
jevu je $\frac 2{j-i+1}$, tedy $p_{i,j}=\frac 2{j-i+1}$ pro $1\le 
i<j\le n$. Odtud 
očekávaný počet porovnání v algoritmu {\bf QUICKSORT} je
$$\sum_{i=1}^n\sum_{j=i+1}^np_{i,j}=\sum_{i=1}^n\sum_{j=i+1}^n\frac 
2{j-i+1}=\sum_{i=1}^n\sum_{k=2}^{n-i+1}\frac 2k\le 2n(\sum_{k=2}^
n\frac 1k)\le 2n\int_1^n\frac 1xdx=2n\ln n.$$

Druhý způsob výpočtu:\newline 
Označme $QS(n)$ očekávaný počet 
porovnání provedených algoritmem {\bf QUICKSORT} při 
třídění $n$-členné posloupnosti. Pak platí
\begin{gather*} QS(0)=QS(1)=0\text{\rm\ a }\\
QS(n)=\frac 1n\big(\sum_{k=0}^{n-1}n-1+QS(k)+QS(n-k-1)\big)=n-1+\frac 
2n(\sum_{k=0}^{n-1}QS(k)).\end{gather*}
Z toho dostáváme, že 
$$nQS(n)=n(n-1)+2\sum_{k=0}^{n-1}QS(k).$$
Přepíšeme ještě jednou tuto rovnici s~$n+1$ místo $
n$:
$$(n+1)QS(n+1)=(n+1)n+2\sum_{k=0}^nQS(k).$$
Od této rovnice odečteme rovnici předchozí a po 
jednoduché úpravě získáme rekurentní vztah
$$QS(n+1)=\frac {2n}{n+1}+\frac {n+2}{n+1}QS(n).$$
Postupným dosazováním dostaneme řešení 
\begin{align*} QS(n)=&\sum_{i=2}^n\frac {n+1}{i+1}\frac {2(i-1)}i\le 2(
n+1)\big(\sum_{i=2}^n\frac 1{i+1}\big)=2(n+1)\big(\sum_{i=3}^{n+1}\frac 
1i\big)=\\
&2(n+1)\big(\sum_{i=2}^{n+1}\frac 1i-\frac 12\big)\le 2(n+1)\big(
(\int_{i=1}^{n+1}\frac 1xdx)-\frac 12\big)=\\
&2n\ln(n+1)+2\ln(n+1)-n-1.\end{align*}
Pro dostatečně velká $n$ tedy platí 
$$2n\ln(n+1)+2\ln(n+1)-n\le 2n\ln n.$$

\subsubsection{Porovnání třídicích algoritmů}

Nyní porovnáme složitost algoritmů 
{\bf HEAPSORT}, {\bf MERGE\-SORT}, {\bf QUICKSORT}, {\bf A-sort} (byl popsán 
v kapitole o $(a,b)-$stromech), 
{\bf SELECTIONSORT} a {\bf INSERTIONSORT}.  Připomeňme si, že 
{\bf SELECTIONSORT} tří\-dí posloupnost tak, že jedním
průcho\-dem nalezne její nej\-menší prvek, 
který vyřadí a vloží do výsledné 
posloupnosti (ve verzi, která třídí na místě, ho vymění 
s levým krajním prvkem pole). 
Tento proces pak opakuje se zbytkem 
původní posloupnosti. Tato idea byla 
zákla\-dem algoritmu {\bf HEAPSORT}.  {\bf INSERTIONSORT} třídí 
tak, že do již setříděného začátku  
posloupnosti vkládá další prvek, který pomocí výměn 
zařadí na správné místo, a tento proces (začíná druhým 
prvkem zleva) opakuje.  

{\bf QUICKSORT} v nejhorším případě vyžaduje čas 
$\Theta (n^2)$, oče\-kávaný čas je $9n\log n$, v 
nej\-horším případě provádí $\frac {n^2}2$ porov\-nání,  
očekávaný počet porov\-nání je $1.44n\log n$. 
Potřebuje $n+\log n+konst$ paměti, používá přímý 
přístup k paměti a není adaptivní na předtříděné 
posloupnosti.\newline 
{\bf HEAPSORT} v nejhorším případě vyžaduje čas $
20n\log n$, 
oče\-kávaný čas je $\le 20n\log n$, v nejhorším i v 
očekávaném případě provádí $2n\log n$ porovnání. 
Potřebuje $n+konst$ paměti, používá přímý přístup k paměti a 
není adaptivní na předtříděné posloupnosti.\newline 
{\bf MERGESORT} v nejhorším případě vyžaduje čas 
$12n\log n$, očekávaný čas je $\le 12n\log n$, v nejhorším 
i v očekáva\-ném případě provádí $n\log n$ 
porovnání (nejmenší možný počet). Potřebuje $
2n+konst$ 
paměti, používá 
sekvenční přístup k paměti a má verzi, která je 
adaptivní na předtříděné posloupnosti s~malým počtem 
běhů.\newline 
{\bf A-sort} v nejhorším případě i v očekáném případě vyžaduje čas 
$O(n\log\frac Fn)$, kde $F$ je počet inverzí ve vstupní 
posloupnosti,  v nejhorším i v očekávaném 
případě provádí $O(n\log\frac Fn)$ porovnání. Potřebuje  
$5n+konst$ paměti, používá přímý přístup k paměti 
a je adaptivní na předtříděné posloupnosti s~malým 
počtem inverzí.\newline 
{\bf SELECTIONSORT} v nejhorším i v očekávaném případě 
vyžaduje čas $2n^2$, počet porov\-nání v nejhorším 
i v očekávaném případě je $\frac {n^2}2$. Potřebuje 
$n+konst$ paměti, používá přímý přístup k paměti a 
není adaptivní na předtříděné posloupnosti.\newline 
{\bf INSERTIONSORT} v nejhorším i v očekávaném případě  
vy\-žaduje čas $O(n^2)$, počet porov\-nání v nejhorším 
případě je $\frac {n^2}2$, v oče\-ká\-vaném případě 
$\frac {n^2}4$. Potřebuje $n+konst$ paměti, použí\-vá 
sekvenční přístup k paměti a má verzi, která je 
adaptivní na předtříděné posloupnosti s~malým počtem 
inverzí.

Prezentované  výsledky byly spočítány 
pro model RAM (viz Mehlhorn 1984).

Očekávaný čas pro {\bf HEAPSORT} je prakticky stejný jako 
jeho nej\-horší čas.  Byly navrženy verze, které optimalizují 
počet porov\-nání, ale většinou mají větší nároky na 
čas, a proto až na výjimky ne\-jsou pro praktické 
použití vhodné.  
Situace pro {\bf MERGESORT} je komplikovanější, hod\-ně závisí 
na konkrétní verzi algoritmu.  Algoritmus 
{\bf MER\-GE\-SORT} je nejvhodnější pro externí paměti se  
sekvenčním přístupem k datům, pro interní 
paměť kvůli velké prostorové náročnosti 
není doporučován (je např. dvojnásobná proti {\bf HEAPSORTU }
a téměř dvojnásobná proti {\bf QUICKSORTU}). Také se hodí pro 
návrh pa\-ra\-lelních algoritmů. Pro třídění 
krátkých posloupností je doporučováno místo {\bf QUICKSORTU }
pro posloupnosti délky $\le 22$ použít {\bf SELECTIONSORT} a pro 
posloupnosti délky $\,\le 15$  {\bf INSERTIONSORT.}
To vede k návrhu optimalizovanéh {\bf QUICKSORTU}, 
který{\bf ,}  když 
volá rekurzivně sám sebe na krátkou posloupnost, pak 
použije {\bf SELECTIONSORT} ne\-bo {\bf INSERTIONSORT}. V algoritmu {\bf A-sort }
se doporu\-ču\-je použít $(2,3)$-strom.  
Poměr časů spotřebovaných  
algoritmy {\bf QUICKSORT},  {\bf MERGESORT} a {\bf HEAPSORT} na 
klasických počítačích uvádí Mehlhorn (1984) jako  
$1$ : $1.33$ : $2.22$. To 
však nemusí  být pravda pro současné procesory, 
paměti a operační systémy. 

\subsubsection{Slévání nestejně dlouhých posloupností}

V algoritmu {\bf MERGESORT} jsme použili frontu, která 
řídila proces slučování rostoucích posloupností.  Tato metoda je uspokojující a 
dává optimální výsledek (ve smyslu časové náročnosti){\bf ,} pokud posloupnosti ve frontě jsou 
stejně dlouhé.  Pokud se ale jejich délky hodně liší, 
nedosáhneme tímto způsobem  
optimálního výsledku.  Přitom různé verze tohoto 
problému se vyskytují v mnoha úlohách. Jednou z prvních úloh, 
kde jsme se s~ním setkali, je konstrukce 
Huffmanova kódu -- to je minimální redundantní kód, který byl 
nalezen v roce 1952. K optimálnímu řešení vede např. 
postup, který je kombinací `mergeování' a 
optimalizace a používá metody dynamického programování.  
Nejprve formálně popíšeme abstraktní verzi tohoto problému.  

Vstup: Množina rostoucích navzájem 
disjunktních posloupností.\newline 
Úkol:  Pomocí operace {\bf MERGE} co nejrychleji spojit 
všechny tyto posloupnosti do jediné rostoucí posloupnosti.  

Předpokládejme, že máme postup, který z 
daných rostoucích posloupností vytvoří 
jedinou rostoucí po\-sloupnost. Tento postup určuje úplný 
binární strom $T$, jehož listy jsou ohodnoceny vstupními 
posloupnostmi a každý vnitřní vr\-chol je ohodnocen 
posloupností, která je sloučením vstupních posloupností 
ohodnocujících listy v podstromu určeném tímto 
vr\-cholem. Tedy kořen je ohodnocen výstupní posloupností. 
Formálně pro každý vnitřní vr\-chol  $v$ platí:
\begin{enumerate}
\item"{}"
když  $v_1$ a $v_2$ jsou synové $v$ a $P(v)$ je posloupnost 
ohodnocující vrchol $v$,  pak\newline 
$P(v)=${\bf MERGE$(P(v_1),P(v_2))$}.
\end{enumerate}
Označme $l(P)$ délku posloupnosti $P$. Pak součet 
časů, které v tomto procesu vyžaduje 
podprocedura {\bf MERGE},
je $O(\sum \{l(P(v))\mid v\text{\rm \ je vnitřní vrchol stromu }
T\})$. Indukcí 
lehce dostaneme, že 
$$\sum \{l(P(v))\mid v\text{\rm \ vnitřní vrchol stromu }T
\}=\sum_{\{t\text{\rm \ je list }T\}}d(t)l(P(t)),$$
kde $d(t)$ je hloubka listu $t$.

Když tedy $T$ je úplný binární strom, jehož listy
jsou ohodnoceny navzájem disjunktními rostoucími  
posloupnostmi, pak následující algoritmus {\bf Slevani} spojí tyto  
posloupnosti do jediné rostoucí posloupnosti a procedury 
{\bf MERGE} budou vyžadovat celkový čas 
$$O(\sum_{\{t\text{\rm \ je list }T\}}d(t)l(P(t))).$$

{\bf Slevani$(T,\{P(l)\mid l\text{\rm \ je list }T\})$\newline 
while} $P(\text{\rm kořen }T)$ není definováno {\bf do\newline 
\phantom{{\rm---}}}$v:=$ vrchol $T$ takový, že $P(v)$ není 
definováno a\newline 
\phantom{---}pro oba syny $v_1$ a $v_2$ vrcholu $v$ jsou $P(v_1)$ a $
P(v_2)$ definovány\newline 
\phantom{---}$P(v):=${\bf MERGE$(P(v_1),P(v_2))$\newline 
enddo
}
Nyní můžeme přeformulovat původní 
problém:\newline 
Vstup: $n$ čísel $x_1,x_2,\dots,x_n$\newline 
Výstup: úplný binární strom $T$ s~$n$ listy a bijekce $
\phi$ z 
množiny $\{1,2,\dots,n\}$ do listů $T$ taková, že 
$\sum_{i=1}^nd(\phi (i))x_i$ je minimální (kde $d(\phi (i))$ je hloubka 
listu $\phi (i)$).\newline 
Řekneme, že dvojice $(T,\phi )$ je \emph{optimální} 
\emph{strom} vzhledem k $x_1,x_2,\dots,x_n$. 

V přeformulováné úloze už nepracujeme s~posloupnostmi, ale jen s~jejich délkami. 
To znamená, že když pro původní úlohu 
byly vstupem posloupnosti $P_1,P_2,\dots,
P_n$, pak pro 
přeformulovanou úlohu jsou vstupem jen délky  
$l(P_1),l(P_2),\dots,l(P_n)$. Strom vytvořený pro 
přeformulovanou úlohu  
je použit v algoritmu {\bf Slevani}  
tak, že  posloupnost $P_i$ ohodnocuje list, který byl v 
přeformulované úloze ohodnocen délkou $l(P_i)$, a hledaná posloupnost 
v původní úloze ohodnocuje kořen stromu. 

Mějme množinu $\{x_i\mid i=1,2,\dots,n\}$.  Pro úplný binární 
strom $T$ s~$n$ listy a bijekci $\phi$ z množiny $\{1,2,\dots,
n\}$ do 
listů stromu $T$ definujme 
$$\Cont(T,\phi )=\sum_{i=1}^nd(\phi (i))x_i,$$
kde $d(\phi (i))$ je hloubka listu $\phi (i)$, tj.  délka cesty z 
kořene do listu $\phi (i)$  pro $i=1,2,\dots,n$.  
Chceme zkonstruovat úplný binární strom s~$n$ listy, 
který minimalizuje hodnotu $\Cont$. K řešení 
použijeme následující algoritmus, který je upravenou verzí 
hladového algoritmu pro náš problém.

{\bf Optim$(x_1,x_2,\dots x_n)$}:\newline 
$V$ je množina $n$ jednoprvkových stromů\newline 
$\phi$ je bijekce mezi $\{1,2,\dots,n\}$ a množinou $V$\newline 
{\bf for every} $v\in V$ {\bf do} $c(v):=x_{\phi^{-1}(v)}$ {\bf enddo\newline 
while} $|V|>1$ {\bf do\newline 
\phantom{{\rm---}}}vezmi z $V$ dva stromy $v_1$ a $v_2$ s~nejmenším ohodnocením\newline 
\phantom{---}odstraň je z $V$\newline 
\phantom{---}vytvoř nový strom $v$ spojením stromů $
v_1$ a $v_2$\newline 
\phantom{---}$c(v):=c(v_1)+c(v_2)$, strom $v$ vlož do $V$\newline 
{\bf enddo\newline 
Výstup}: $(T,\phi )$, kde $T$ je strom v množině $V$

Vytvoření nového stromu $v$ spojením stromů 
$v_1$ a $v_2$ znamená vytvoření nového vrcholu, který bude 
kořenem stromu $v$ a jehož synové budou kořeny stromů 
$v_1$ a $v_2$. To je analogické proceduře {\bf spoj}.

\begin{veta}Pro danou posloupnost čísel 
$(x_1,x_2,\dots,x_n)$ algoritmus {\bf Optim} nalezne optimální strom 
pro množinu $x_1,x_2,\dots,x_n$ a pokud je posloupnost 
$(x_1,x_2,\dots,x_n)$ neklesající, pak vyža\-du\-je čase 
$O(n)$.  
\end{veta}

\begin{proof}Důkaz má dvě části. V 
první dokážeme korektnost algoritmu a ve druhé popíšeme 
reprezentaci množiny $V$ a vypočteme časovou složitost.

Nejprve připomeňme, že $\phi (i)$ je list $T$ 
pro každé $i\in \{1,2,\dots,n\}$.  Protože na začátku $
V$ 
obsahuje jen 
jednoprvko\-vé stromy, tak tvrzení platí.  Každý běh cyklu 
{\bf while do} zmenší počet stromů $V$ o jeden, ale nezmění 
množinu listů.  Proto $T$ je strom s~$n$ listy, $\phi$ je 
bijekce z $\{1,2,\dots,n\}$ do množiny listů $T$ a algoritmus 
vždy končí.  Dokážeme indukcí podle $n$, že zkonstruovaná 
dvojice $(T,\phi )$ je optimální strom vzhledem k $(x_1,x_2
,\dots,x_n)$.  
Když $n=2$, tvrzení zřejmě platí.  Předpokládejme, že 
platí pro každou posloupnost čísel $(y_1,y_2,\dots,$$
y_{n-1})$, a 
nechť $x_1\le x_2\le\dots\le x_n$ je neklesající posloupnost čísel.  Bez újmy na 
obecnosti můžeme předpokládat, že v prvním kroku 
algoritmus {\bf Optim} zvolil stromy $\phi (1)$ a $\phi (2)$.  Uvažujme množinu 
$(y_1,y_2,\dots,y_{n-1})$, kde $y_i=x_{i+2}$ pro $i=1,2,\dots,n-2$, 
$y_{n-1}=x_1+x_2$.  Nechť $T'$ je strom získaný ze stromu $
T$  
odstraněním listů $\phi (1)$ a $\phi (2)$ a nechť $
\psi$ je bijekce z 
množiny $\{1,2,\dots,n-1\}$ taková, že $\psi (i)=\phi (i+
2)$ pro 
$i=1,2,\dots,n-2$ a $\psi (n-1)$ je otec listu $\phi (1)$.  Pak 
můžeme předpokládat, že algoritmus 
{\bf Optim$(y_1,y_2,\dots,y_{n-1})$} zkonstruoval strom $(T',\psi 
)$, a podle indukčního 
předpokladu je to optimální strom pro $(y_1,y_2,\dots,y_{
n-1})$.  Nechť 
$(U,\theta )$ je optimální strom vzhledem k $(x_1,x_2,\dots
,x_n)$.  Zvolme 
vnitřní vrchol $u$ stromu $U$ takový, že délka cesty z kořene 
do vrcholu $u$ je nej\-větší mezi všemi vnitřními vrcholy 
stromu $U$.  Nechť $u_1$ a $u_2$ jsou synové $u$, pak nutně $
u_1$ 
a $u_2$ jsou listy stromu $U$.  Nechť $i,j\in \{1,2,\dots,n\}$ takové, že 
$\theta (i)=u_1$, $\theta (j)=u_2$.  Po eventuálním přejmenování můžeme 
předpokládat, že když $i,j\in \{1,2\}$, pak $i=1$ a 
$j=2$.  Definujme $\eta$ z $\{1,2,\dots,n\}$ do listů $U$ tak, že 
$\eta (1)=u_1$, $\eta (2)=u_2$, $\eta (i)=\theta (1)$, $\eta (j)=
\theta (2)$ a $\eta (k)=\theta (k)$ pro 
všechna $k\in \{3,4,\dots,n\}\setminus \{i,j\}$.  Pak $\eta$ je bijekce a 
$$\Cont(U,\eta )-\Cont(U,\theta )=(d(u_1)-d(\theta (1))(x_1-x_i)+
(d(u_2)-d(\theta (2))(x_2-x_j).$$
Z volby $u$ plyne, že $d(u_1)\ge d(\theta (1))$, $d(u_2)\ge d(
\theta (2))$, 
$x_1\le x_i$ a $x_2\le x_j$. Odtud  
$$(d(u_1)-d(\theta (1))(x_1-x_i)+(d(u_2)-d(\theta (2))(x_2-x_j)\le 
0$$
a protože $(U,\theta )$ je optimální strom pro $(x_1,x_2
,\dots,x_n)$, 
dostá\-vá\-me, že $(U,\eta )$ je také optimální strom pro 
$(x_1,x_2,\dots,x_n)$.  Od\-straněním listů $u_1$ a $
u_2$ ze stromu 
$U$ dostaneme strom $U'$.  Definujme $\tau$ z $\{1,2,\dots,n-1\}$ 
předpisem $\tau (i)=\eta (i+2)$ pro $i=1,2,\dots,n-2$ a $\tau 
(n-1)=u$.  Pak 
$\tau$ je bijekce z $\{1,2,\dots,n-1\}$ do množiny listů $
U'$ a 
protože $(T',\psi )$ je optimální strom pro $(y_1,y_2,\dots
,y_{n-1})$, 
platí, že 
$$\Cont(T',\psi )\le\Cont(U',\tau ).$$
Protože  
\begin{gather*}\Cont(T,\phi )=\Cont(T,\psi )+x_1+x_2\text{\rm \ , }\\
\Cont(U,\eta )=\Cont(U',\tau )+x_1+x_2\end{gather*}
pak závěr je, že $(T,\phi )$ je optimální strom pro 
$(x_1,x_2,\dots,x_n)$.

Předpokládejme opět, že $x_1\le x_2\le\dots\le 
x_n$ a že v daném 
okamžiku jsou $v_1,v_2,\dots,v_k$ postupně vytvořené víceprvkové stromy
(tj. strom $v_i$ byl vytvořen před stromem $v_j$, když $
i<j$). V 
tomto okamžiku je množina $V$ sjednocením množiny $\{
v_1,v_2,\dots,v_k\}$ 
a množiny jednoprvkových stromů, které nebyly ještě 
zpracovány. Nyní vytvoříme strom $w$ spojením 
stromů $t_1$ a $t_2$ s~nejmenším ohodnocením. Z popisu algoritmu plyne, že když 
strom $v_i$ pro $i=1,2,\dots,k$ vznikl spojením stromů $
u_1$ 
a $u_2$, pak $\max\{c(u_1),c(u_2)\}\le\min\{c(t_1),c(t_2)\}$, a proto $
c(w)\ge c(v_i)$ 
pro každé $i=1,2,\dots,k$. Pak indukcí 
okamžitě dostáváme, že $c(v_1)\le c(v_2)\le\dots\le 
c(v_k)$.  Tedy stačí, 
abychom měli rostoucí posloupnost listů a v ní 
ukazatel na nej\-menší list, který je ještě 
nezpracovaným jednoprvkovým stro\-mem (tj. před ukazatelem jsou 
listy, které už nejsou stromy v množině $V$, 
za ukazatelem jsou listy, které jsou ještě jednoprvkové 
stro\-my v množině $V$) a frontu víceprvkových 
stromů (z níž stromy ke zpracování odebíráme 
zpředu a nově vytvořené  
ukládáme na konec).  Udržovat tyto struktury vyža\-duje čas 
$O(1)$ stejně jako nalezení dvou stromů s~nej\-menším 
ohodnocením. Můžeme tedy shrnout, že algoritmus 
{\bf Optim} konstruuje optimální stromy v čase $O(n)$, kde $
n$ je počet 
zadaných čísel $x_i$. \qed
\end{proof}

Pro aplikaci na naši původní úlohu je 
třeba  
ještě setřídit vstupní posloupnost délek pro přeformu\-lo\-vanou úlohu.
Tato posloupnost je tvořena přirozenými čísly a 
k jejímu setřídění  
můžeme použít algoritmus {\bf BUCKETSORT} (bude 
popsán dále v textu), který 
vyžaduje čas $O(n+m)$, kde $n$ je počet posloupností a $
m$ je 
maximální délka posloupnosti.

\begin{veta}Uvedený algoritmus množinu 
disjunktních rostoucích 
posloupností $P_1,P_2,\dots,P_n$ o délkách $l(P_1),l(P_2)
,\dots,l(P_n)$ spojí 
do jediné rostoucí posloupnosti v čase 
$O(\sum_{i=1}^nl(P_i))$.
\end{veta}

\subsection{{Rozhodovací stromy}}

Většina obecných třídicích algoritmů 
používá jedinou primitivní operaci mezi prvky vstupní 
posloupnosti, a to jejich vzá\-jemné porov\-nání.  
To znamená, že práci 
takového algoritmu lze po\-psat 
binárním stro\-mem, jehož vnitřní vrcholy jsou ohodnoceny 
porovnáními dvojic prvků vstupní posloupnosti 
(např. $a_i<a_j$). Bez újmy na obecnosti předpokládejme, že 
vstupní posloupnost je permutace $\pi$
množiny $\{1,2,\dots,n\}$. Tato permutace prochází 
stromem takto:
\begin{enumerate}
\item"{}"
Začíná v kořeni stromu. Když je ve vnitřním vrcholu $
v$ 
ohodnoceném porovnáním $a_i\le a_j$, pak když $\pi (i)
<\pi (j)$, 
pokračuje v levém synu vrcholu $v$, a když $\pi (j)<\pi (
i)$, 
pokračuje v pravém synu vrcholu $v$. Proces 
třídění končí, když se dostane do listu.
\end{enumerate}
Aby byl algoritmus korektní, musí platit, že dvě 
různé permutace skončí v různých 
listech.  Tedy strom popisující korektní algoritmus 
pro setřídění $n$-prvkovývh posloupností musí mít 
alespoň $n!$ listů.  Délka cesty z kořene do listu, 
kde skončila permutace $\pi$, reprezentuje počet porovnání, které potřebuje 
daný algoritmus k setřídění dané posloupnosti $
\pi$. Protože porovnání 
vyžaduje alespoň jednotku času, dostáváme tím i dolní odhad na 
čas potřebný k setřídění této posloupnosti  algoritmem 
odpovídajícím danému stromu. Dolní odhad  počtu 
porovnání i času pro daný algoritmus a všechny  
$n$-prvkové posloupnosti je pak délka nejdelší cesty z kořene 
do listu v odpovídajícím stromu. To nám umožňuje 
získat obecně platný dolní odhad času potřebného k setřídění 
$n-$prvkové posloupnosti, kterým je  
minimum přes všechny binární stromy s~alespoň $n!$ 
listy z jejich maximálních délek cest z kořene do listu. 
Korekt\-nost těchto úvah plyne z pozorování, 
že když porovnání je jediná primi\-tivní operace, pak 
algoritmus není závislý na konkrétních prvcích vstup\-ní 
posloupnosti, ale jen na jejich vzájemném vzta\-hu. 
Proto stačí uvažovat pouze permutace $n$-prvkové množiny, 
protože za\-chycují všechny možné vztahy v $n$-prvkové 
posloupnosti. Dá\-le je třeba si uvědomit, že vztah mezi 
stromem pro $n$-prvkové posloupnosti a stromem pro 
$(n+1)$-prvkové posloupnosti je dán konkrétním algoritmem a 
nedá se popsat obecně. 

V nevhodném algoritmu se může stát, že 
v některém listu neskončí žádná permutace. To  
nastane, když strom pro $n$-prvkové posloupnosti má více 
než $n!$ listů, nebo, jinak řečeno, když 
porovnání dvou stejných prvků se na nějaké cestě 
vyskytne alespoň dvakrát. 

Následující obrázek ilustruje naše úvahy na 
{\bf SELECTIONSORTU} pro $3$-prvkové posloupnosti. Listy jsou 
ohodnoceny permutacemi vstupní množiny 
$\{a_1,a_2,a_3\}$, které v nich 
skončí, nebo jsou prázdné. 

\begin{figure}[h!]
  \centerline{
    \input fig11.tex
    }
  \caption{SELECTIONSORT - postup}
\end{figure}

\begin{definice}Mějme třídicí algoritmus {\bf A}, který 
jako jedinou pri\-mitivní operaci s~prvky vstupní 
posloupnosti používá jejich porov\-nání. Řekneme, že binární 
strom $T$, jehož vnitřní vrcholy jsou ohodnoceny 
porovnáními  $a_i\le a_j$ pro $i,j=1,2,\dots,n$, $i\ne j$, je 
\emph{rozhodovacím} \emph{stromem} algoritmu {\bf A} pro 
$n$-prvkové posloupnosti, když pro každou permutaci $\pi$
$n$-prvkové množiny platí 
\begin{enumerate}
\item"{}"
posloupnost porovnání při třídění permutace $
\pi$ 
algoritmem {\bf A} je stejná jako po\-sloupnost porovnání při 
průchodu permutace $\pi$ stromem $T$.
\end{enumerate}
\end{definice}

Pak korektnost algoritmu zajišťuje, že dvě různé 
permutace množiny $\{1,2,\dots,n\}$ skončí v 
různých listech stromu $T$ a dol\-ním odhadem pro 
čas algoritmu {\bf A} v nej\-horším případě je délka nejdelší 
cesty z kořene do listu.  
Při rovnoměrném 
rozdělení vstupních po\-sloupností je očekávaný čas 
algoritmu {\bf A} roven průměrné délce cesty z kořene do 
listu.  

Definujme\newline 
$S(n)$ jako minimum přes všechny stromy $T$ s~alespoň $n
!$ listy z 
délek nejdelších cest z kořene 
do listu v $T$, \newline 
$A(n)$ jako minimum přes všechny stromy $T$ s~alespoň $n
!$ listy z
průměrných délek cest z kořene do listu v $T$.\newline 
Naším cílem je spočítat dolní odhady těchto veličin.

Když nejdelší cesta z kořene do listu v 
binárním stromě $T$ má délku $k$, pak $T$ má nejvýše $
2^k$ 
listů. Proto $n!\le 2^{S(n)}$. Odtud plyne, že $S(n)\ge\log_
2n!$.
Připomeňme si Stirlingův vzorec pro faktoriál: 
$$n!=\sqrt {2\pi n}\big(\frac ne\big)^n(1+\frac 1{12n}+O(\frac 1{
n^2})).$$
Protože pro $n\ge 1$ je $\frac 1{12n},\frac 1{n^2}\ge 0$, můžeme 
předpokládat, že $(1+\frac 1{12n}+O(\frac 1{n^2}))\ge 1$ pro všechna $
n\ge 1$. Po 
zlogaritmování vzorce dostáváme 
$$\log_2n!\ge\frac 12\log_2n+n(\log_2n-\log_2e)+\log_2\sqrt {2\pi}
\ge (n+\frac 12)\log_2n-n\log_2e.$$
Protože  
$$e^1=e=2^{\log_2e}=(e^{\ln2})^{\log_2e}=e^{\ln2\log_2e},$$
platí, že $\frac 1{\ln2}=\log_2e$, a tedy  
$$S(n)\ge\log_2n!\ge (n+\frac 12)\log_2n-\frac n{\ln2}.$$

Dále pro binární strom $T$ označme $B(T)$ součet všech 
délek cest z kořene do listů a položme 
$$B(k)=\min\{B(T)\mid T\text{\rm\ je binární strom s~$k$ listy}
\}.$$
Když ukážeme, že $B(k)\ge k\log_2k$, pak bude 
$$A(n)\ge\frac {B(n!)}{n!}\ge\frac {n!\log_2n!}{n!}=\log_2n!\ge (
n+\frac 12)\log_2n-\frac n{\ln2}.$$
Dokažme tedy, že $B(T)\ge k\log_2k$ pro každý binární 
strom $T$ s~$k$ listy. Když ve stromě $T$ vynecháme každý 
vrchol, který má jen jednoho syna, a tohoto syna spojíme 
s jeho předchůdcem, dostaneme úplný binární 
strom $T'$ s~$k$ listy tako\-vý, že $B(T')\le B(T)$. Proto se stačí  
omezit na úplné binární stromy. Když $T$ je úplný 
binární strom s~jedním listem, pak $B(T)=0=1\log_21$, 
když $T$ je úplný binární strom se dvěma listy, pak 
$B(T)=2=2\log_22$. Tedy platí $B(1)\ge 1\log_21$ a $B(2)\ge 2\log_
22$. 
Předpokládejme, že $B(i)\ge i\log_2i$ pro $i<k$, a nechť $
T$ je 
úplný binární strom s~$k$ listy. Nechť $T_1$ a $T_2$ jsou 
podstromy určené syny kořene a nechť $T_i$ má $k_i$ 
listů, kde $i=1,2$. Pak $1\le k_1,k_2$ a $k_1+k_2=k$, tedy 
$k_1,k_2<k$ a podle indukčního předpokladu $B(k_i)\ge k_
i\log_2k_i$. 
Odtud 
$$B(T)=k_1+B(T_1)+k_2+B(T_2)\ge k+B(k_1)+B(k_2)\ge k+k_1\log_2k_1
+k_2\log_2k_2.$$

Tedy stačí ukázat, že 
$$k+k_1\log_2k_1+k_2\log_2k_2\ge k\log_2k$$
pro všechna $k_1,k_2>0$ taková, že $k=k_1+k_2$. To je 
ekvivalentní s~tvrzením, že pro $k>0$ platí 
$$f(x)=x\log_2x+(k-x)\log_2(k-x)+k-k\log_2k\ge 0,$$
kde $x\in (0,k)$. 
Abychom to dokázali, všimněme si, že $f(\frac k2)=0$ a  
počí\-tejme derivaci $f$.
$$f'(x)=\log_2x+\log_2e-\log_2(k-x)-\log_2e=\log_2\frac x{k-x}.$$
Nyní když $x\in (0,\frac k2)$, pak $f'(x)<0$ a $f$ je na tomto intervalu 
klesající, když $x\in (\frac k2,k)$, pak $f'(x)>0$ a $
f$ je na tomto 
intervalu rostoucí. Odtud plyne, že $f(x)\ge 0$ pro $x\in 
(0,k)$.
Tím jsme dokázali, že $A(n)\ge (n+\frac 12)\log_2n-\frac 
n{\ln2}$. Shrneme 
naše výsledky.

\begin{veta}Každý třídicí algoritmus, jehož jedinou 
primitivní ope\-rací s~prvky vstupní posloupnosti je 
porovnání, vyžaduje v nejhorším i v očekávaném případě 
alespoň $cn\log n$ času pro nějakou konstantu $c>0$.  V 
nejhorším případě použije alespoň $\lceil 
(n+\frac 12)\log_2n-\frac n{\ln2}\rceil$ 
porovnání a očekávaný počet porovnání při rovnoměrném 
rozdělení vstupních posloupností je alespoň 
$(n+\frac 12)\log_2n-\frac n{\ln2}$.  
\end{veta}

Tato věta 
platí i pro širší třídu primitivních operací, proto v ní 
lze oslabit předpklady. 
Dolní odhad (v nejhorším i průměrném případě) 
bude platit i za 
před\-pokladu, že třídicí algoritmus nepoužívá nepřímé 
adreso\-vání a celo\-číselné dělení. 
(Na druhé straně následující klasický algoritmus 
{\bf BUCKETSORT} ukazuje, že před\-poklady
ve větě nelze zcela vynechat.) 
Tato metoda pro 
nalezení dolního odhadu se používá i pro vyčíslování 
algebraických funkcí a při algoritmickém řešení 
geometrických úloh.

\subsection{{Přihrádkové třídění}}

V následujících algoritmech 
před\-po\-klá\-dáme, že $Q_i$ jsou spojové seznamy, nový 
prvek se vkládá na konec seznamu a konkatenace 
seznamů závisí na jejich pořadí. V 
seznamech máme okamžitý přístup k prvnímu a poslednímu 
prvku (pomocí ukazatelů na tyto prvky). 
Algoritmus {\bf BUCKETSORT} třídí posloupnost přirozených 
čísel $a_1,a_2,\dots,a_n$ z intervalu $<0,m>$.

{\bf BUCKETSORT$(a_1,a_2,\dots,a_n,m)$}:\newline 
{\bf for every} $i=0,1,\dots,m$ {\bf do} $Q_i=\emptyset$ {\bf enddo\newline 
for every} $i=1,2,\dots,n$ {\bf do\newline 
\phantom{{\rm ---}}$a_i$} vlož na konec seznamu $Q_{a_i}$\newline 
{\bf enddo\newline 
$i:=0$}, $P:=\emptyset$\newline 
{\bf while} $i\le m$ {\bf do\newline 
\phantom{{\rm ---}}$P:=$}konkatenace $P$ a $Q_i$, $i:=i+1$\newline 
{\bf enddo\newline 
Výstup: $P$} je neklesající posloupnost prvků 
$a_1,a_2,\dots,a_n$

Algoritmus nevyžaduje, aby prvky ve 
vstupní posloupnosti by\-ly různé. Ve výstupní 
posloupnosti se daný prvek opakuje tolikrát, kolikrát se 
opakoval ve vstupní posloupnosti, se zachováním pořadí 
(tj. třídění je stabilní). 
Konkatenace dvou seznamů a vložení prvku do seznamu 
vyžadují čas $O(1)$. Proto první a třetí cyklus vyžadují 
čas $O(m)$ a druhý cyklus čas $O(n)$. Celkem 
algoritmus vyžaduje $O(n+m)$ času a paměti. Zřejmě když  
$m=O(n)$, tak pro tento algoritmus neplatí tvrzení věty z 
předchozího odstavce. 
Důvodem je, 
že nejsou splněny předpoklady, protože druhý cyklus 
používá nepřímé adresování.

Nyní uvedeme dvě sofistikovanější verze tohoto 
algoritmu. V první předpokládáme, že 
$a_1,a_2,\dots,a_n$ je posloupnost navzájem různých reálných 
čísel z intervalu $<0,1>$ a $\alpha$ je pevně zvolené kladné 
reálné číslo.

{\bf HYBRIDSORT$(a_1,a_2,\dots,a_n)$}:\newline 
$k:=\alpha n$\newline 
{\bf for every} $i=0,1,\dots,k$ {\bf do} $Q_i=\emptyset$ {\bf enddo\newline 
for every} $i=1,2,\dots,n$ {\bf do\newline 
\phantom{{\rm ---}}$a_i$} vlož na konec seznamu $Q_{\lceil ka_
i\rceil}$\newline 
{\bf enddo\newline 
$i:=0$}, $P:=\emptyset$\newline 
{\bf while} $i\le k$ {\bf do\newline 
\phantom{{\rm ---}}HEAPSORT$(Q_i)$
$P:=$}konkatenace $P$ a $Q_i$, $i:=i+1$\newline 
{\bf enddo\newline 
Výstup: $P$} je rostoucí posloupnost prvků 
$a_1,a_2,\dots,a_n$

\begin{veta}Algoritmus {\bf HYBRIDSORT} setřídí 
posloupnost reál\-ných čísel z intervalu $<0,1>$ v 
nejhorším případě v čase $O(n\log n)$. Když prvky $
a_i$ 
mají rovnoměrné rozložení a jsou na sobě nezá\-vislé, 
pak očekávaný čas je $O(n)$.
\end{veta}

\begin{proof}První dva cykly v algoritmu 
vyžadují čas $O(n)$, $i$-tý běh třetího cyklu vyžaduje 
nejvýše čas $O(1+|Q_i|\log|Q_i|)$. Proto čas celého třetího cyklu je 
$$O(\sum_{i=0}^k(1+|Q_i|\log|Q_i|)=O(\sum_{i=0}^k(1+|Q_i|\log n)=
O(k+(\sum_{i=0}^k|Q_i|)\log n)=O(n\log n)$$
a celkový čas {\bf HYBRIDSORTU} v nejhorším případě je nejvýše $
O(n\log n)$.

Nyní odhadneme očekávaný čas. Položme 
$X_i=|Q_i|$. Pak 
$X_i$ je ná\-hodná proměnná a 
protože pravděpodobnost, že $x\in Q_i$, je $\frac 1k$, dostá\-váme, že 
$$\Prob(X_i=q)=\binom nq(\frac 1k)^q(1-\frac 1k)^{n-q}.$$
Očekávaný čas vyžadovaný třetím cyklem se pak rovná 
$$E(\sum_{i=0}^k1+X_i\log X_i)\le k+k\sum_{q=2}^nq^2\binom nq(\frac 
1k)^q(1-\frac 1k)^{n-q}=k+k(\frac {n(n-1)}{k^2}+\frac nk)=O(n),$$
protože $k=\alpha n$ a 
$$q^2\binom nq=(q(q-1)+q)\binom nq=n(n-1)\binom {n-2}{q-2}+n\binom {
n-1}{q-1}.$$
(Jedná se vlastně o známý výpočet 2. momentu 
binomického rozdělení). \qed
\end{proof}

Poznámka: V důkazu jsme použili odhad 
$q\log q\le q^2$ a důsledkem toho je, že jsme 
dokázali, že očekávaná složitost {\bf HYBRIDSORTU }
zůstane lineární, i kdybychom v něm místo 
{\bf HEAPSORTU} použili nějaký třídicí algoritmus s~kvadratickou složitostí, např. {\bf INSERTIONSORT}.

Nyní použijeme modifikaci {\bf BUCKETSORTU} pro 
třídění slov.  Máme totálně 
uspořádanou abecedu a chceme lexikograficky setřídit slova 
$a_1,a_2,\dots,a_n$ nad touto abecedou. Připo\-meň\-me, že když 
$a=x_1x_2\dots x_n$ a $b=y_1y_2\dots y_m$ jsou dvě slova nad totálně 
uspořá\-danou abecedou $\Sigma$, pak $a<b$ v lexikografickém 
uspořádání, právě když existuje $i=0,1,\dots,\min
\{n,m\}$ takové, že 
$x_j=y_j$  pro každé $j=1,2,\dots,i$ a buď $n=i<m$ nebo $
i<\min\{n,m\}$ 
a $x_{i+1}<y_{i+1}$. Předpokládejme, že $a_i=a_i^1a_i^2\dots 
a_i^{l(i)}$, kde 
$a_i^j\in\Sigma$ a $l(i)$ je délka $i$-tého slova $a_i$.

{\bf WORDSORT$(a_1,a_2,\dots,a_n)$}:\newline 
{\bf for every} $i=1,2,\dots,n$ {\bf do} $l(i):=$délka slova $a_
i$ {\bf enddo\newline 
$l=\max\{l(i)\mid i=1,2,\dots,n\}$\newline 
for every} $i=1,2,\dots,l$ {\bf do} $L_i=\emptyset$ {\bf enddo\newline 
for every} $i=1,2,\dots,n$ {\bf do\newline 
\phantom{{\rm---}}$a_i$} vlož do $L_{l(i)}$\newline 
{\bf enddo\newline}
Komentář: Pro každé $i$ obsahuje $L_i$ všechna slova z množiny 
$\{a_1,a_2,\dots,a_n\}$ délky $i$.\newline 
$P_{}:=\{(j,a_i^j)\mid 1\le i\le n,\,1\le j\le l(i)\}$\newline 
$P_1:=${\bf BUCKETSORT$(P)$} podle druhé komponenty\newline 
$P_2:=${\bf BUCKETSORT$(P_1)$} podle první komponenty\newline 
{\bf for every} $i=1,2,\dots,l$ {\bf do} $S_i=\emptyset$ {\bf enddo\newline 
$(i,x):=$}první prvek $P_2$\newline 
{\bf while} $(i,x)\ne NIL$ {\bf do\newline 
\phantom{{\rm---}}$(i,x)$} vlož do $S_i$\newline 
\phantom{---}{\bf while}$(i,x)=$následník $(i,x)$ v $P_2$ {\bf do}\newline
\phantom{{\rm------}}$(i,x):=$následník $(i,x)$ v $P_2$\newline 
\phantom{{\rm---}}{\bf enddo}\newline
\phantom{---}$(i,x):=$následník $(i,x)$ v $P_2$\newline 
{\bf enddo}\newline
Komentář: V $S_i$ jsou všechny dvojice $(i,x)$ takové, že $
x$ 
je $i$-tým písmenem některého vstupního slova a když $
x<y$, pak 
$(i,x)$ je před $(i,y)$.\newline 
{\bf for every} $s\in\Sigma$ {\bf do} $T_s:=\emptyset$ {\bf enddo\newline 
$T:=\emptyset$}, $i:=l$\newline 
{\bf while} $i>0$ {\bf do\newline 
\phantom{{\rm---}}$T:=$} konkatenace $L_i$ a $T$, $a:=$první slovo v $
T$\newline 
\phantom{---}{\bf while} $a\ne NIL$ {\bf do\newline 
\phantom{{\rm------}}$s:=i$}-té písmeno $a$, vlož $a$ do $
T_s$\newline 
\phantom{------}$a:=$následník $a$ v $T$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}$(i,x):=$}první prvek v $S_i$, $T:=\emptyset$\newline 
\phantom{---}{\bf while} $(i,x)\ne NIL$ {\bf do\newline 
\phantom{{\rm------}}$T:=$} konkatenace $T$ a $T_x$, $T_x:=\emptyset$\newline 
\phantom{------}$(i,x):=$následník $(i,x)$ v $S_i$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}$i:=i-1$\newline 
enddo\newline 
Výstup: $T$} je setříděná posloupnost slov $a_1,a_2
,\dots,a_n$

Uvažujme jeden běh posledního cyklu algortimu 
pro určité $i$. Po 
jeho skončení jsou v $T$ všechna slova z množiny 
$a_1,a_2,\dots,a_n$, která mají délku alespoň $i$, a když slovo 
$a_r$ je před $a_q$ v seznamu $T$, pak existuje $j=i-1,i,\dots
,l$
takové, že $a^k_r=a^k_q$ pro každé $k=i,i+1,\dots,j$ a buď 
$l(r)=j\le l(q)$ nebo $j<\min\{l(r),l(q)\}$ a $a_r^{j+1}<a_q^{j+1}$. To plyne z 
vlastností algoritmu {\bf BUCKETSORT} indukcí podle $i$. Jediný a 
hlavní rozdíl proti {\bf BUCKETSORTU} je, že neprocházíme 
všechny přihrádky $T_x$, ale pouze neprázdné. 
To nám zajišťuje množina $S_i$ (viz Komentář). 

Označme $L=\sum_{i=1}^nl(i)$ a připomeňme, že 
$l=\max\{l(i)\mid i=1,2,\dots,n\}$. Pak první cyklus (výpočet  
délek slov) vy\-žaduje čas $O(L)$. Druhý cyklus (inicializace 
seznamů $L_i$) vyžaduje 
čas $O(l)=O(L)$ a třetí cyklus (zařazení slov do $
L_i$ podle 
délek) čas $O(n)=O(L)$. Vytvoření 
seznamu $P_{}$ vyžaduje čas $O(L)$ a jeho setřídění podle obou 
komponent  
čas $O(L+l)=O(L)$, protože $P_{}$ i $P_1$ mají nejvýše $
L$ 
prvků. Další cyklus (založení seznamů 
$S_i$) vyžaduje čas $O(l)$ a následující cyklus vytvářející 
seznamy $S_i$ čas $O(L)$. Cyklus zakládající 
seznamy $T_x$ vyžaduje čas $O(|\Sigma |)$. Běhy dalšího cyklu jsou 
indexovány $i=1,2,\dots,l$. Pro každé $i$ označme $m_i$ počet slov z 
množiny $\{a_1,a_2,\dots,a_n\}$, která mají délku alespoň $
i$. Pak 
$L=\sum_{i=1}^lm_i$ a první vnitřní cyklus v $i$-tém běhu vnějšího 
cyklu vyžaduje čas $O(m_i)$ a druhý vnitřní cyklus 
čas $O(|S_i|)=O(m_i)$. Tedy 
celkový čas algoritmu je $O(L+m)$, kde $m=|\Sigma |$ a $L$ 
je součet délek všech slov z množiny $a_1,a_2,\dots,a_
n$.

\subsection{Pořádkové statistiky}

Na závěr popíšeme dva algoritmy pro hledání $
k$-tého 
nejmenší\-ho prvku v dané podmnožině totálně 
uspořádané\-ho univerza. Prv\-ní z nich využívá  
stejný princip jako {\bf QUICKSORT}. Nejprve zadáme 
přesné zně\-ní naší úlohy (úloha i algoritmy se dají 
snadno přeformulovat pro případ, kdy hledáme $k-$tý 
největší prvek).

Pracujeme s~totálně uspořádaným univerzem $
U$.\newline 
Vstup: množina prvků $M=\{a_1,a_2,\dots,a_n\}\subseteq 
U$ a číslo $i$ takové, 
že $1\le i\le n$.\newline 
Výstup: prvek $a_k$ takový, že 
$|\{j\mid 1\le j\le n,\,a_j\le a_k\}|=i$.\newline 
Když $i=\frac n2$, pak $a_k$ se nazývá \emph{medián}.

{\bf FIND$(M=(a_1,a_2,\dots,a_n),i)$}:\newline 
zvol $a\in M$\newline
$M_1:=\{b\in M\mid b<a\}$, 
$M_2:=\{b\in M\mid b>a\}$\newline 
{\bf if} $|M_1|>i-1$ {\bf then\newline 
\phantom{{\rm ---}}FIND$(M_1,i)$\newline 
else\newline 
\phantom{{\rm ---}}if} $|M_1|<i-1$ {\bf then\newline 
\phantom{{\rm ------}}FIND$(M_2,i-|M_1|-1)$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm------}}Výstup: $a$} je hledaný prvek\newline 
\phantom{---}{\bf endif\newline 
endif}

Důkaz korektnosti algoritmu je založen na následujícím 
jednoduchém pozorování: mějme množinu $M$ a prvek $
x$ a 
položme $M_1=\{m\in M\mid m<x\}$. Když $k\le |M_1|$, pak $k$-tý 
nejmenší 
prvek v $M_1$ je stejný jako $k$-tý nejmenší prvek v $
M$. Když 
$k>|M_1|$, pak $(k-|M_1|)$-tý nejmenší prvek v $M\setminus 
M_1$ je $k$-tý 
nejmenší prvek v $M$.  
Zbývá vyšetřit složitost.

V nejhorším případě 
voláme {\bf FIND} $n$-krát a jedno volání vyžaduje čas $
O(|M|)$.  
Tedy časová složitost algoritmu 
{\bf FIND} v nejhorším případě je $O(n^2)$.  Dobré volby 
prvku $a$ mohou algoritmus značně zrychlit.  V tomto 
případě platí stejná 
diskuse jako pro {\bf QUICKSORT}.  Spočítáme očekávaný čas 
za předpokladu, že  
pr\-vek $a$ byl vybrán náhodně.  Pak pravděpodobnost, že je 
$k$-tým nejmenším prvkem, je $\frac 1n$, kde $n=|M|$.  Označme $
T(n,i)$ 
očekávaný čas algoritmu {\bf FIND} pro nalezení $i$-tého nejmenšího 
prvku v $n$-prvkové množině $M$.  Platí 
$$T(n,i)=n+\frac 1n(\sum_{k=1}^{i-1}T(n-k,i-k)+\sum_{k=i+1}^nT(k,
i)),$$
protože procedura {\bf FIND} bez rekurzivního volání sebe sama 
vyžaduje čas $O(n)$. Předpoklá\-dej\-me, že $T(m,i)
\le 4m$ 
pro každé $m<n$ a každé $i$ takové, že $1\le i\le 
m$. Pak 
\begin{align*} T(n,i)=&n+\frac 1n(\sum_{k=1}^{i-1}T(n-k,i-k)+\sum_{k=i+
1}^nT(k,i))\le n+\frac 1n(\sum_{k=1}^{i-1}4(n-k)+\sum_{k=i+1}^n4k
)=\\
&n+\frac 4n(\frac {(2n-i)(i-1)}2+\frac {(n+i+1)(n-i)}2)=n+\frac 4
n(\frac {n^2+2ni-n-2i^2}2).\end{align*}
Výraz v čitateli zlomku nabývá svého maxima pro 
$i=\frac n2$ a jeho maximalní hodnota je 
$\frac 32n^2-n=\frac {3n^2-2n}2$. Tedy
$$T(n,i)\le n+\frac 4n(\frac {3n^2-2n}4)=n+3n-2=4n-2<4n.$$
Protože tento odhad platí také pro $n=1$ a $n=2$, dokázali 
jsme indukcí, že $T(n,i)\le 4n$ pro všechna $n$ a všechna $
i$ 
taková, že $1\le i\le n$. Platí tedy 

\begin{veta}Algoritmus {\bf FIND} nalezne $i$-tý nejmenší 
prvek v $n$ prv\-kové totálně uspořádané mno\-ži\-ně a v nejhorším 
případě vyža\-du\-je čas $O(n^2)$. Když se pivot volí 
náhodně nebo když všechny vstupní množiny mají stejnou 
pravděpodobnost, pak očekávaný čas je $O(n)$.
\end{veta}

Pro velmi malá $i$ nebo pro $i$ velmi blízká $n$ 
pracuje rychleji přímý přirozený algoritmus (udržuje si 
posloupnost $i$ nejmen\-ších nebo $n-i$ největších prvků 
a k ní přidává další tak, že ten prvek, který pře\-kročil 
danou hranici, je 
zapomenut). Tento algoritmus však není 
efektivní pro obecná $i$. 

Následující algoritmus nalezne $i$-tý nejmenší 
prvek v lineárním čase i v nejhorším případě.  Vstupem 
je opět podmnožina $M$ totálně 
uspořádaného univerza $U$ a přirozené číslo $i$ takové, že 
$1\le i\le |M|$.  

{\bf SELECT$(M,i)$}:\newline 
$n:=|M|$\newline 
{\bf if} $n\le 100$ {\bf then\newline 
\phantom{{\rm---}}}setřiď množinu $M$, $m:=$ $i$-tý nejmenší 
prvek $M$\newline 
{\bf else\newline 
\phantom{{\rm---}}}rozděl $M$ do navzájem disjunktních 
pětiprvkových podmnožin $A_1,A_2,\dots,A_{\lceil\frac n5\rceil}$\newline 
\phantom{---}(poslední z podmnožin může mít méně než 5 prvků).\newline 
\phantom{---}{\bf for every} $j=1,2,\dots,\lceil\frac n5\rceil$ {\bf do\newline 
\phantom{{\rm------}}}najdi medián $m_j$ množiny $A_j$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}$\bar {m}:=$SELECT$(\{m_j\mid j=1,2,\dots,\lceil\frac 
n5\rceil \},\lceil\frac n{10}\rceil )$\newline 
\phantom{{\rm ---}}$M_1:=\{m\in M\mid m<\bar {m}\}$}, $M_2:=\{m\in 
M\mid\bar {m}<m\}$\newline 
\phantom{---}{\bf if} $|M_1|>i-1$ {\bf then\newline 
\phantom{{\rm ------}}$m:=$SELECT$(M_1,i)$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm------}}if} $|M_1|<i-1$ {\bf then\newline 
\phantom{{\rm ---------}}$m:=$SELECT$(M_2,i-|M_1|-1)$\newline 
\phantom{{\rm ------}}else\newline 
\phantom{{\rm ---------}}$m:=\bar {m}$\newline 
\phantom{{\rm ------}}endif\newline 
\phantom{{\rm ---}}endif\newline 
\phantom{{\rm ---}}Výstup}: $m$\newline 
{\bf endif
}
Důkaz korektnosti algoritmu je stejný 
jako u algoritmu {\bf FIND}. 
Zbývá vyšetřit složitost. Nej\-prve dokážeme následující 
lemma.

\begin{lemma}Když $n\ge 100$, pak $|M_1|,|M_2|\le\frac {8n}{
11}$.
\end{lemma}

\begin{proof} Pro $j\le\lfloor\frac n5\rfloor$ platí, že když $
m_j<\bar {m}$, pak 
$|A_j\cap M_1|\ge 3$, když $m_j>\bar {m}$, pak $|A_j\cap M_2|\ge 
3$, když $m_j=\bar {m}$, 
pak $|A_j\cap M_1|=|A_j\cap M_2|=2$.  Protože 
$|\{j=0,1,\dots,\lfloor\frac n5\rfloor\mid m_j<\bar {m}\}|,|\{j=0
,1,\dots,\lfloor\frac n5\rfloor\mid m_j>\bar {m}\}|\ge\lfloor\frac 
n{10}\rfloor$, 
dostáváme, že $|M_1|,|M_2|\ge\lfloor\frac {3n}{10}\rfloor 
-1$.  Dále platí $M_1\cap M_2=\emptyset$, 
$M_1\cup M_2=M\setminus \{\bar {m}\}$ a protože $\frac {8n}{11}
+\lfloor\frac {3n}{10}\rfloor -1\ge\frac {113n}{110}-2\ge n$ 
když $n>100$, dostáváme požadovaný odhad. \qed
\end{proof}

Maximální čas vyžadovaný algoritmem  
{\bf SELECT$(M,i)$} pro $|M|=n$ označme $T(n)$.  Když $n\le 
100$, pak zřejmě 
exis\-tuje konstanta $a$ taková, že $T(n)\le an$.  Když $
n>100$, 
pak $\lceil\frac n5\rceil\le\frac {21n}{100}$, a protože {\bf SELECT$
(M,i)$} pro $|M|>100$ bez 
rekurentních volání vyžaduje čas $O(|M|)$, platí, že $
T(n)\le T(\frac {21n}{100})+T(\frac {8n}{11})+bn$ pro nějakou konstantu 
$b$.  Zvolme $c\ge\max\{a,\frac {1100b}{69}\}$. Ukážeme, že $
T(n)\le cn$ pro 
všechna $n$.  
Když $n\le 100$, tak tvrzení zřejmě platí, protože $
a\le c$.  Když 
$n>100$, pak $\lceil\frac {21n}{100}\rceil ,\lceil\frac {8n}{11}\rceil 
<n$, a protože z volby $c$ plyne 
$b\le\frac {69}{1100}c$, 
dostáváme 
$$T(n)\le c\frac {21n}{100}+c\frac {8n}{11}+bn=(\frac {1031c}{110
0}+b)n\le cn.$$
Tedy

\begin{veta}Algoritmus {\bf SELECT} nalezne $i$-tý nejmenší 
prvek v lineárním čase.
\end{veta}

Algoritmus {\bf FIND} je ve velké většině 
případů 
rychlejší než algoritmus {\bf SELECT}, proto je v praxi 
doporučován, i když existují 
případy (velmi řídké), kdy potřebuje kvadratický čas.
Je známo, že medián $n$-prvkové množiny lze nalézt s~méně než $3n$ porovnáními a že každý algoritmus hledající 
medián a používající porovnání jako jedinou primitivní 
operaci mezi prvky množiny vyžaduje více než $2n$ 
porovnání.

\subsubsection{Historický přehled}

Algoritmus {\bf HEAPSORT }
navrhl v roce 1964 Williams a vylepšil Floyd (rovněž 1964).  Návrh 
na použití $d$-regulár\-ních hald je folklor stejně tak jako  
algoritmus {\bf MER\-GESORT}.  Algoritmy {\bf QUICKSORT} a {\bf FIND }
zavedl Hoare (1962).  Analýza ope\-race {\bf MERGE} a 
hledání optimálního stro\-mu pochází od Huffmana 
(1952) a lineární implementaci algoritmu navrhl van 
Leeuwen (1976).  Analýza rozhodovacích stromů je 
folklor. Algoritmus {\bf HYBRIDSORT} navrhli Meijer a Akl (1980), 
vylepše\-ná verze {\bf BUCKETSORTU} (nazvaná {\bf WORDSORT}) 
pochází od Aho, Hopcrofta a Ullmana (1974). Algoritmus {\bf SELECT} byl 
navržen Blumem, Floydem, Prattem, Rivestem a 
Tarjanem (1972).

\end{document}
