\documentclass[a4paper,12pt]{article}
 \usepackage{amsmath}
 \usepackage{amsthm}
 \usepackage{amsfonts}
 
 
 \usepackage[utf8]{inputenc}
 \usepackage[czech]{babel}
 \usepackage{hyperref}
 \usepackage{graphicx} 
 \usepackage{caption} 
 
 
 \setlength{\hoffset}{-3cm} 
 \setlength{\voffset}{-3cm}
 \setlength{\textheight}{26.0cm} 
 \setlength{\textwidth}{19cm}
 \setlength{\parindent}{0in}
 \setlength{\parskip}{0.1in}
 
 \def \emph#1{\underbar{#1}}
 
 

 
 \DeclareMathOperator*{\Prob}{Prob}
 \DeclareMathOperator*{\countop}{count}
 \DeclareMathOperator*{\NIL}{NIL}
 \DeclareMathOperator*{\otec}{otec}
 \DeclareMathOperator*{\listop}{list}
 \DeclareMathOperator*{\Prv}{Prv}
 \DeclareMathOperator*{\Nasl}{Nasl}
 \DeclareMathOperator*{\levy}{levy}
 \DeclareMathOperator*{\pravy}{pravy}
 \DeclareMathOperator*{\key}{key}
 \DeclareMathOperator*{\Prst}{Prst}
 \DeclareMathOperator*{\hloubka}{hloubka}
 \DeclareMathOperator*{\bratr}{bratr}
 \DeclareMathOperator*{\npl}{npl}
 \DeclareMathOperator*{\Cont}{Cont}
 
 \input lhead
 
 
 \begin{document}
     

\newtheorem*{dusledek}{Důsledek}
\newtheorem*{lemma}{Lemma}

%tohle je mozna nesmyslne komplikovane
\newtheorem{counter}{Counter}
\newtheorem{lemma_counting}[counter]{Lemma}
\newtheorem{dusledek_counting}[counter]{Důsledek}

\newtheorem*{pozorovani}{Pozorování}

\newtheorem*{veta}{Věta}
\newtheorem*{tvrzeni}{Tvrzení}
\newtheorem*{definice}{Definice}

\def \emph#1{\underbar{#1}}
\def \Prob{\operatorname{Prob}}
\def \var{\operatorname{var}}

\title{Datové struktury - stromy}
\date{}
\maketitle

\tableofcontents

\section{Uspořádaný slovníkový problém}

Jedná se o rozšíření základního slovníkového problému. Je 
dáno totálně uspořádané univerzum $U$ (tj. pro každé dva 
různé prvky $u,v\in U$ platí buď $u<v$ nebo $v<
u$). Cílem 
je reprezentovat 
množinu $S\subseteq U$ a navrhnout algoritmy pro tyto operace:\newline 
{\bf MEMBER}, {\bf INSERT}, {\bf DELETE\newline 
MIN} -- nalezne nejmenší prvek v $S$,\newline 
{\bf MAX} -- nalezne největší prvek v $S$,\newline 
$\bold S\bold P\bold L\bold I\bold T(x)$ -- zkonstruuje reprezentace dvou množin 
$S_1=\{s\in S\mid s<x\}$ a $S_2=\{s\in S\mid s>x\}$ a oznámí, zda 
$x\in S$,\newline 
{\bf JOIN} -- používají se dvě verze této operace:\newline 
$\bold J\bold O\bold I\bold N\bold 2(S_1,S_2)$ -- jsou dány reprezentace množin $
S_1$ a $S_2$, které 
splňují $\max S_1<\min S_2$, vytvoří se reprezentace množiny 
$S=S_1\cup S_2$,\newline 
$\bold J\bold O\bold I\bold N\bold 3(S_1,x,S_2)$ -- jsou dány reprezentace množin $
S_1$ a $S_2$ a 
prvek $x\in U$ tak, že je splněno $\max S_1<x<\min S_2$, vytvoří 
se reprezentace množiny $S=S_1\cup \{x\}\cup S_2$.

Je vidět, že operace {\bf JOIN2} a {\bf JOIN3} lze pomocí ope\-rací 
{\bf INSERT} a {\bf DELETE} převést jednu na druhou. Proto často budeme 
popisovat pro danou strukturu jen jednu z nich. 
Občas se také používá operace\newline 
$\bold o\bold r\bold d(k)$ -- předpokádáme, že $k\le |S
|$, a operace nalezne $k$-tý 
nejmenší prvek v $S$.\newline 
Zřejmě operace {\bf MIN} a {\bf MAX} jsou speciálním případem 
ope\-race {\bf ord$(k)$}, 
přesně {\bf MIN} je operace $\bold o\bold r\bold d(1)$ a {\bf MAX} je operace $
\bold o\bold r\bold d(|S|)$.

\section{$(a,b)$-stromy}

Důležitou datovou strukturou vhodnou pro 
řešení uspořá\-dané\-ho slovní\-ko\-vé\-ho problému jsou 
$(a,b)$-stromy. Tuto datovou strukturu lze použít pro interní i 
pro externí paměť. Je to struktura založená na stromech. 
Nejobecnější grafová defini\-ce $(a,b)$-stromu je:\newline 
Nechť $1\le a<b$ jsou kladná přirozená čísla. Pak kořenový 
strom $(T,t)$ se nazývá $(a,b)$-\emph{strom}, když 
\begin{enumerate}
\item
když $v$ je vnitřní vrchol stromu $T$ různý od 
kořene $t$, pak má alespoň $a$ a nejvýše $b$ synů;
\item
všechny cesty z kořene do libovolného listu mají 
stejnou délku.
\end{enumerate}
Tato definice je příliš obecná a pro datové struktury se 
nehodí. Proto používáme její speciální případ. Datová 
struktura $(a,b)$-strom je definována jen na těchto stromech: 
Nechť $a$ a $b$ jsou přirozená čísla taková, že $
2\le a$ a 
$2a-1\le b$. Pak kořenový 
strom $(T,t)$ nazveme $(a,b)$-\emph{strom}, když platí 
\begin{enumerate}
\item
každý vnitřní vrchol $v$ stromu $T$ různý od 
kořene $t$ má alespoň $a$ a nejvýše $b$ synů;
\item
kořen je buď list nebo má alespoň dva syny a nejvýše $
b$ 
synů;
\item
všechny cesty z kořene do libovolného listu mají 
stejnou délku.
\end{enumerate}

Výhody našich $(a,b)$-stromů:\newline 
Když má $(a,b)$-strom \emph{výšku} $h>0$ (tj. délka každé 
cesty z kořene do libovolného listu je $h$), pak 
strom má alespoň $2a^{h-1}$ listů a nejvýše $b^
h$ 
listů.

\begin{tvrzeni}Mějme přirozená čísla $a$ a $
b$ taková, 
že $a\ge 2$ a $b\ge 2a-1$. Pak pro každé kladné přirozené 
číslo $n$ existuje $(a,b)$-strom, který má přesně $
n$ 
listů. Když $(a,b)$-strom má přesně $n$ 
listů, pak výška stromu je nejvýše $1+\log_a(\frac 
n2)$ a 
je alespoň $\log_bn$. Tedy výška stromu je $O(\log n)$.
\end{tvrzeni}

Mějme kořenový strom $(T,t)$ takový, že pro každý 
vnitřní vrchol $v$ platí:\newline 
když $v$ má $\rho (v)$ synů, pak jsou očíslovány od $
1$ do 
$\rho (v)$. Řekne\-me, že vrchol $v$ je v \emph{hloubce} $h$, když 
cesta z kořene $t$ do $v$ má délku $h$. Množina všech 
vrcholů v hloubce $h$ se nazývá $h$-\emph{tá} 
\emph{hladina}. \emph{Lexikografické} \emph{uspořádání} 
na $h$-té hladině je definováno rekurzivně:\newline 
\newline 
$v\le w$, právě když buď $\otec(v)<\otec(w)$ nebo 
$\otec(v)=\otec(w)$ a když $v$ je $i$-tý syn $\otec(v)$ a $w$ je 
$j$-tý syn $\otec(v),$ pak $i\le j$.  

Předpokládáme, že v $(a,b)$-stromu  
synové každého vnitřního vrcholu jsou uspořádány. Listy 
tvoří hladinu $h$, kde $h$ je hloub\-ka $(a,b)$-stromu, a je na nich 
definováno lexikografické uspořá\-dá\-ní.

Mějme lineárně uspořádané univerzum $U$ a 
množinu $S\subseteq U$.  Pak $(a,b)$-strom $(T,t)$ 
\emph{reprezentuje} množinu $S$, když má přesně $|S
|$ 
listů a je dán izomorfismus mezi lexikografickým uspořá\-dá\-ním 
listů stromu $T$ a uspořádanou množinou $S$ 
(tj.  bijekce $\key:\listop(T)\to S$, která pro $s,t\in S$ 
splňuje $s\le t$ v $U$, právě když $\key^{-1}(s)\le\key^{
-1}(t)$ v 
lexikografickém uspořádání na množině listů 
stromu $T$).  

Struktura vnitřních vrcholů 
$(a,b)$-stromu $(T,t)$ reprezentující\-ho množinu 
$S\subseteq U$:\newline 
$\rho (v)$ -- počet synů vrcholu $v$,\newline 
$S_v(1..\rho (v))$ -- pole ukazatelů na syny vrcholu $v$ takové, 
že $S_v(i)$ je $i$-tý syn vrcholu $v$ pro 
$i=1,2\dots,\rho (v)$,\newline 
$H_v(1..\rho (v)-1)$ -- pole prvků z $U$ takové, že $
H_v(i)$ 
je největší prvek z $S$ reprezentovaný v podstromu 
$i$-tého syna vrcholu $v$ (alternativa: $H_v(i)$ je prvek z $U$ 
takový, že největší prvek reprezentovaný v podstromu $
i$-tého 
syna vrcholu $v$ je menší nebo roven $H_v(i)$ a to je menší  
než nejmenší prvek reprezentovaný v podstromu $(i+1)$-ního 
syna vrcholu $v$).

Struktura listů:\newline 
listu $v$ je přiřazen prvek $\key(v)\in S$.

Někdy je ve struktuře každého vrcholu $v$ 
$(a,b)$-stromu různého od kořene ještě ukazatel 
$\otec(v)$ na otce vrcholu $v$.

Když $H_v(i)$ jsou prvky z reprezentované 
množiny, pak pro každý prvek $s\in S$ kromě největšího 
existuje právě jeden vnitř\-ní vrchol $v$ $(a,b)$-stromu 
a jedno $i$, že $H_v(i)=s$, a největší prvek v $S$ není prvek 
$H_v$ pro žádný vrchol $v$. Tento fakt se používá při 
implementaci, kde se vynechávají listy. Prvky z $S$ jsou 
reprezentovány v polích $H_v$ vnitř\-ních vrcholů 
stromu 
a největší prvek je uložen zvlášť nebo je k množině $S$ přidán 
formální největší prvek (a ten je pak "uložen" zvlášť). Je to prostorově 
efektivnější reprezentace množiny $S$, ale je technicky 
nepřehledná. Proto při práci s $(a,b)$-stromy používám 
verzi s listy.

Nyní uvedeme algoritmy pro $(a,b)$-stromy.

\subsection{Algoritmy}

Pomocný algoritmus

{\bf Vyhledej$(x)$\newline 
$t:=$}kořen stromu $T$, $w:=NIL$\newline 
{\bf while} $t$ není list {\bf do}\newline 
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $H_t(i)<x$ a $i<\rho (t)$ {\bf do} $i:=i+1$ {\bf enddo}\newline 
\phantom{---}{\bf if} $H_t(i)=x$ {\bf then} $w:=t$ {\bf endif}\newline 
$t:=S_t(i)$ {\bf enddo Výstup}: $t$ a $w$.

{\bf MEMBER$(x)$\newline 
Vyhledej$(x)$\newline 
if} $\key(t)=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $x\notin S$ {\bf endif

INSERT$(x)$\newline
Vyhledej$(x)$\newline 
if} $\key(t)\ne x$ {\bf then}\newline 
\phantom{---}vytvoř nový list $t'$, $\key(t'):=x$, $u:=\otec(t)$\newline 
\phantom{---}{\bf if} $\key(t)<x$ {\bf then}\newline 
(komentář: $x>\max S$)\newline 
\phantom{------}$S_u(\rho (u)+1):=t'$, $H_u(\rho (u)):=\key(t)$, $\rho (u):=\rho 
(u)+1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}najdi $i$, že $S_u(i)=t$\newline 
\phantom{------}$S_u(\rho (u)+1):=S(\rho (u))$, $j:=\rho (u)-1$\newline 
\phantom{------}{\bf while} $j\ge i$ {\bf do\newline 
\phantom{---------}$S_u(j+1):=S_u(j)$}, $H_u(j+1):=H_u(j)$, $j:=j-1$\newline 
\phantom{------}{\bf enddo\newline 
\phantom{------}$S_u(i):=t'$}, $H_u(i):=x$, $\rho (u):=\rho (u)+1$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$t:=u$\newline 
\phantom{---}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo\newline 
endif}

{\bf Štěpení$(t)$\newline 
if} $t$ je kořen stromu {\bf then}\newline 
\phantom{---}vytvoř nový kořen $u$ s jediným synem $t$\newline 
{\bf endif}\newline 
$u:=\otec(t)$, najdi $i$, že $S_u(i)=t$,\newline 
vytvoř nový vnitřní vrchol $t'$, $j:=1$\newline 
{\bf while} $j<\lfloor\frac {b+1}2\rfloor$ {\bf do}\newline 
\phantom{---}$S_{t'}(j):=S_t(j+\lceil\frac {b+1}2\rceil )$, $H_{t'}(j):=H_t(j+\lceil\frac {b+1}2\rceil)$, $j:=j+1$\newline 
{\bf enddo\newline 
$S_{t'}(\lfloor\frac {b+1}2\rfloor ):=S_t(b+1)$}, $\rho (t):=\lceil\frac {
b+1}2\rceil$, $\rho (t'):=\lfloor\frac {b+1}2\rfloor$,\newline 
{\bf if} $i<\rho (u)$ {\bf then} $S_u(\rho (u)+1):=S_u(\rho (u))$ {\bf endif\newline}
$j:=\rho (u)-1$, $\rho (u):=\rho (u)+1$,\newline 
{\bf while} $j>i$ {\bf do}\newline 
\phantom{---}$S_u(j+1):=S_u(j)$, $H_u(j+1):=H_u(j)$, $j:=j-1$\newline 
{\bf enddo\newline 
$S_u(i+1):=t'$}, $H_u(i+1):=H_u(i)$, $H_u(i):=H_t(\rho (t))$, 
$t:=u$

{\bf DELETE$(x)$\newline 
Vyhledej$(x)$\newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}$u:=\otec(t)$, najdi $i$, že $S_u(i)=t$, a $j$, že $H_w(j)=x$, $k:=i$\newline 
\phantom{---}{\bf if} $w\ne u$ a $w\ne NIL$ {\bf then} $H_w(j):=H_u(\rho (u)-1)$ {\bf endif}\newline 
\phantom{---}{\bf while} $k<\rho (u)-1$ {\bf do}\newline 
\phantom{------}$H_u(k):=H_u(k+1)$, $S_u(k):=S_u(k+1)$, $k:=k+1$ \newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}{\bf if} $i\ne\rho(u)$ {\bf then} $S_u(\rho (u)-1):=S_u(\rho (u))$ {\bf endif}\newline
\phantom{---}$\rho (u):=\rho (u)-1$, odstraň $t$, $t:=u$ \newline 
\phantom{---}{\bf while} $\rho (t)<a$ a $t$ není kořen {\bf do}\newline 
\phantom{------}$y$ je bezprostřední bratr $t$\newline 
\phantom{------}{\bf if} $\rho (y)=a$ {\bf then Spojení$(t,y)$ else Přesun$
(t,y)$ endif}\newline 
\phantom{---}{\bf enddo\newline 
endif}

{\bf Spojení$(t,y)$\newline 
$u:=\otec(t)$}, najdi $i$, že $S_u(i)=t$, $j:=1$\newline 
{\bf if} $S_u(i-1)=y$ {\bf then} vyměň $t$ a $y$, $i:=i-1$ {\bf endif\newline 
while} $j<\rho (y)$ {\bf do}\newline 
\phantom{---}$S_t(\rho (t)+j):=S_y(j)$, $H_t(\rho (t)+j):=H_y(j)$, $j:=j+1$\newline 
{\bf enddo}\newline 
$H_t(\rho (t)):=H_u(i)$, $S_t(\rho (t)+\rho (y)):=S_y(\rho (y))$, $
\rho (t):=\rho (t)+\rho (y)$, odstraň $y$\newline 
{\bf while} $i<\rho (u)-1$ {\bf do}\newline 
\phantom{---}$S_u(i+1):=S_u(i+2)$, $H_u(i):=H_u(i+1)$, $i:=i+1$\newline 
{\bf enddo}\newline 
$\rho (u):=\rho (u)-1$\newline 
{\bf if} $u$ je kořen a $\rho (u)=1$ {\bf then}\newline 
\phantom{---}odstraň $u$\newline 
{\bf else}\newline 
\phantom{---}$t:=u$\newline 
{\bf endif}

{\bf Přesun$(t,y)$\newline 
$u:=\otec(t)$}, najdi $i$ takové, že $S_u(i)=t$\newline 
{\bf if} $S_u(i+1)=y$ {\bf then}\newline 
\phantom{---}$S_t(\rho (t)+1):=S_y(1)$, $H_t(\rho (t)):=H_u(i)$,\newline 
\phantom{---}$H_u(i):=H_y(1)$, $j:=1$\newline 
\phantom{---}{\bf while} $j<\rho (y)-1$ {\bf do}\newline 
\phantom{------}$S_y(j):=S_y(j+1)$, $H_y(j):=H_y(j+1)$, $j:=j+1$\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}$S_y(\rho (y)-1):=S_y(\rho (y))$, $\rho (t):=\rho (t)+1$, $\rho 
(y):=\rho (y)-1$\newline 
{\bf else}\newline
\phantom{---}$S_t(\rho (t)+1):=S_t(\rho (t))$, $j:=\rho (t)-1$\newline 
\phantom{---}{\bf while} $j>0$ {\bf do}\newline 
\phantom{------}$S_t(j+1):=S_t(j)$, $H_t(j+1):=H_t(j)$, $j:=j-1$\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}$\rho (t):=\rho (t)+1$, $S_t(1):=S_y(\rho (y))$, $H_t(1):=H_u(i-
1)$,\newline 
\phantom{---}$H_u(i-1):=H_y(\rho (y)-1)$, $\rho (y):=\rho (y)-1$\newline 
{\bf endif}

{\bf MIN\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list {\bf do} $t:=S_t(1)$ {\bf enddo}\newline 
$\key(t)$ je nejmenší prvek $S$

{\bf MAX\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list {\bf do} $t:=S_t(\rho (t))$ {\bf enddo}\newline 
$\key(t)$ je největší prvek $S$

{\bf JOIN2$(T_1,T_2)$}\newline
Předpoklad $T_i$ je $(a,b)$-strom reprezentující 
množinu $S_i$ pro $i=1,2$, které splňují $\max S_1<\min 
S_2$ 
(tento předpoklad je silnější než požadavek, že $
S_1$ a 
$S_2$ jsou disjunktní, ale algoritmus nekontroluje jeho splnění)\newline 
{\bf if} výška $T_1$ je větší nebo rovna výšce $T_2$ {\bf then}\newline 
\phantom{---}$t:=$kořen $T_1$, $k:=v(T_1)-v(T_2)$\newline 
\phantom{---}{\bf while} $k>0$ {\bf do} $t:=S_t(\rho (t))$, $k:=k-1$ {\bf enddo}\newline \phantom{---}{\bf Spojení$(t,$}kořen $T_2)$, $t:=\otec(t)$\newline 
\phantom{---}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo\newline 
else}\newline 
\phantom{---}$t:=$kořen $T_2$, $k:=v(T_2)-v(T_1)$ \newline 
\phantom{---}{\bf while} $k>0$ {\bf do} $t:=S_t(1)$, $k:=k-1$ {\bf enddo}\newline \phantom{---}{\bf Spojení$(t,$}kořen $T_1)$, $t:=\otec(t)$\newline 
\phantom{---}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo\newline 
endif}

{\bf SPLIT$(T,x)$\newline 
$Z_1$}, $Z_2$ prázdné zásobníky, $t:=$kořen $T$\newline 
{\bf while} $t$ není list {\bf do}\newline
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $H_t(i)<x$ a $i<\rho (t)$ {\bf do} $i:=i+1$ {\bf enddo}\newline \phantom{---}$t:=S_t(i)$\newline 
\phantom{---}{\bf if} $i=2$ {\bf then} vlož podstrom vrcholu $S_t(1)$ do $Z_1$ 
{\bf endif}\newline 
\phantom{---}{\bf if} $i>2$ {\bf then}\newline 
\phantom{------}vytvoř nový vrchol $t_1$, $\rho (t_1)=i-1$,\newline 
\phantom{------}{\bf for every} $j=1,2,\dots,i-2$ {\bf do}\newline 
\phantom{---------}$S_{t_1}(j):=S_t(j)$, $H_{t_1}(j):=H_t(j)$\newline 
\phantom{------}{\bf enddo}\newline 
\phantom{------}$S_{t_1}(i-1):=S_t(i-1)$, vlož podstrom vrcholu $t_1$ do $Z_1$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}{\bf if} $i=\rho (t)-1$ {\bf then}\newline 
\phantom{------}vlož podstrom $S_t(\rho (t))$ do $Z_2$ 
\phantom{---}{\bf endif}\newline 
\phantom{---}{\bf if} $i<\rho (t)-1$ {\bf then}\newline 
\phantom{------}vytvoř nový vrchol $t_2$, $\rho (t_2):=\rho (t)-i$\newline 
\phantom{------}{\bf for every} $j=1,2,\dots,\rho (t)-i-1$ {\bf do}\newline 
\phantom{---------}$S_{t_2}(j):=S_t(i+j)$, $H_{t_2}(j):=H_t(i+j)$\newline 
\phantom{------}{\bf enddo}\newline 
\phantom{------}$S_{t_2}(\rho (t)-i):=S_t(\rho (t))$, vlož podstrom $t_2$ do $Z_2$ \newline 
\phantom{---}{\bf endif\newline 
enddo\newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$\newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x\notin S$\newline 
\phantom{---}{\bf if} $\key(t)<x$ {\bf then}\newline 
\phantom{------}vlož podstrom vrcholu $t$ do $Z_1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}vlož podstrom vrcholu $t$ do $Z_2$\newline 
\phantom{---}{\bf endif\newline 
endif}\newline 
$T_1:=\text{ vrchol }Z_1$, odstraň $T_1$ ze $Z_1$\newline 
{\bf while} $Z_1\ne\emptyset$ {\bf do}\newline 
\phantom{---}$T':=$vrchol $Z_1$, odstraň $T'$ ze $Z_1$, $T_1:=${\bf JOIN}$(T',T_1)$\newline enddo\newline 
$T_2:=\text{ vrchol }Z_2$, odstraň $T_2$ ze $Z_2$\newline 
{\bf while} $Z_2\ne\emptyset$ {\bf do}\newline 
$T':=\text{ vrchol }Z_2$, odstraň $T'$ ze $Z_2$, $T_2:=${\bf JOIN$(T_2,T')$\newline 
enddo}

Poznámky k algoritmům. \newline 
Odkaz na otce vrcholu: buď je v každém vrcholu $v$ 
stromu $T$ přímo odkaz na $\otec(v)$, nebo se v proceduře 
{\bf Vyhledej} vkláda\-jí vrcholy do zásobníku a $\otec
(v)$ 
je vrchol v zásobníku před vrcholem $v$.

Při operaci {\bf SPLIT} se zásobníky používají 
jednoprůchodově -- nejprve se naplní a v této části 
algoritmu se nepoužije operace {\bf pop}, pak se vyprázdní a v této 
fázi se nepoužívá operace {\bf push}. V okamžiku, když jsou 
zásobníky naplněné, platí:
\begin{itemize}
\item
v zásobnících jsou uloženy $(a,b)$-stromy reprezentující 
podmnožiny $S$;
\item 
když $(a,b)$-stromy $T_i$ a $T_{i+1}$ reprezentují množiny $S_
i$ a $S_{i+1}$ a jsou v zá\-sobníku $Z_1$ (nebo $Z_2$) a strom $T_{i+1}$ následuje 
po stromu $T_{i}$, pak platí $\max S_i<\min S_{i+1}<x$ (nebo 
$\min S_i>\max S_{i+1}>x$) a výška $T_i$ je větší nebo 
rovna výšce $T_{i+1}$;
\item
když $T_i$ a $T_{i+1}$ jsou dva po sobě následující $
(a,b)$-stromy v 
zásobníku $Z_j$ pro $j=1,2$, které mají stejnou výšku, pak 
následující strom v zásobníku $Z_j$ má ostře menší výšku.
\end{itemize}

Toto plyne z první fáze algoritmu operace {\bf SPLIT} a zajišťuje 
korektnost druhé fáze algoritmu. 

Dále si všimněme, že podprocedury {\bf Štěpení}, {\bf Spojení} a {\bf Pře\-sun }
vyžadují čas $O(1)$, a proto algoritmy pro operace {\bf MEMBER}, 
{\bf INSERT}, {\bf DELETE}, {\bf MIN}, {\bf MAX}, {\bf JOIN2} a pro první fázi algoritmu 
{\bf SPLIT} vyžadují čas $O(1)$ pro práci v dané hladině.  Protože 
hladin je nejvýše $\log_a|S|$, můžeme shrnout: 

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, 
{\bf DE\-LETE}, {\bf MIN}, {\bf MAX}, {\bf JOIN2} a {\bf SPLIT} v $
(a,b)$-stromech vy\-žadují 
v nejhorším případě čas $O(\log_a|S|)$, kde $
S$ je 
re\-pre\-zen\-tovaná množina.  
\end{veta}

Je třeba ještě odhadnout spotřebovaný čas ve druhé fázi 
algoritmu pro operaci {\bf SPLIT}. Nejprve si všimněme, že 
algoritmus {\bf JOIN2$(T_1,T_2)$} vyžaduje ve skutečnosti jen čas 
rovný 
$O(\text{\rm rozdíl výšek stromů }T_1\text{\rm \ a }
T_2)$. Když po naplnění 
zásobník $Z_j$ pro $j=1,2$ obsahuje stromy $U_1,U_2,\dots,U_
k$ v tomto 
pořadí, pak $k\le 2\log_a|S|$ a vyprázdnění zásobníku $
Z_j$ 
vyžaduje 
čas $O(\sum_{i=1}^{k-1}(u_i-u_{i+1}+1)=O(u_1+k)$, kde $u_i$ je výška stromu $
U_i$ pro 
$i=1,2,\dots,k$. Protože výška stromu $U_1$ je nejvýše rovna výšce 
stromu $T$, dostáváme, že druhá fáze algoritmu {\bf SPLIT} vyžaduje 
čas $O(\log_a|S|)$ a důkaz je kompletní. 

Nyní popíšeme algoritmus pro operaci {\bf ord$
(k)$}. Tato 
operace se často nazývá $k$-tá pořádko\-vá statistika
Tato operace není podporována navrženou 
strukturou, pro její efektivní implementaci musíme 
rozšířit strukturu vnitřního vrcholu $v$ o pole\newline 
$P_v(1..\rho (v)-1)$, kde $P_v(i)$ je počet prvků $S$ reprezentovaných 
v podstromu $i$-tého syna vrcholu $v$.

 

Udržovat pole $P_v$ v aktuálním stavu znamená při úspěšném 
pro\-vedení aktualizační operace projít cestu z vrcholu do koře\-ne 
a aktualizovat pole $P$. Uvedeme algoritmus pro 
naleze\-ní $k$-té pořádkové statistiky.

{\bf ord$(k)$\newline 
if} $k>|S|$ {\bf then} neexistuje $k$-tý nejmenší prvek, konec 
{\bf endif\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list {\bf do}\newline 
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $k>P_t(i)$ a $i<\rho (t)$ {\bf do}\newline 
\phantom{------}$k:=k-P_t(i)$, $i:=i+1$\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}$t:=S_t(i)$\newline 
{\bf enddo}\newline 
$\key(t)$ je hledaný $k$-tý nejmenší prvek

Invariant algoritmu: V každém okamžiku platí, 
že původní $k$ se rovná aktuální $k+$počet prvků z 
$S$, které jsou v podstromech vrcholů stromu, které v 
lexikografickém uspořádání předcházejí $i$-tému synu 
vrcholu $t$. Korektnost algoritmu plyne z tohoto 
invariantu.

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, 
{\bf DE\-LETE}, {\bf MIN}, {\bf MAX}, {\bf SPLIT}, {\bf JOIN2} a {\bf ord$
(k)$} pro všechna $k$ v 
rozšířené struktuře $(a,b)$-stromu vy\-ža\-dují v 
nejhorším pří\-pa\-dě čas $O(\log|S|)$, kde $S$ je reprezentovaná 
množina.  
\end{veta}

$(a,b)$-stromy se používají jak v interní tak v 
externí paměti. Jaké hodnoty $a$ a $b$ je vhodné 
používat?\newline 
Pro interní paměť jsou doporučené hodnoty $a=2$, $
b=4$ 
nebo $a=3$ a $b=6$.\newline 
Pro externí paměť jsou doporučené hodnoty $a\approx 
100$, 
$b=2a$.

Když je množina reprezentovaná $(a,b)$-stromem 
uložena na serveru a má k ní přístup více 
uživatelů, vzniká problém s aktualizačními 
operacemi. Tyto operace mění strukturu $(a,b)$-stromu a 
v důsledku toho se v něm jiný uživatel 
může ztratit. Tento problém se dá  
řešit tak, že při aktu\-alizačních operacích 
se uzavře celý strom.

 

Nevýhoda: ostatní uživatelé  
do něho nemají přístup a nemohou pracovat. Tzv. paralelní 
implementace operací {\bf INSERT} a {\bf DELETE} nabízí jiné, 
efektivnější řešení.

Předpoklad: $b\ge 2a$. \newline 
Při operaci {\bf INSERT} jsou ve vyhledávací fázi vždy 
uzavřeny vrcholy $t$, $\otec(t)$ a synové vrcholu $t$. 
Algoritmus zjistí, ve kterém synu vrcholu $t$ má 
pokračovat, a pak, když $\rho (t)=b$, provede {\bf Štěpení }
(proto je nutně $b\ge 2a$, abychom po této ope\-raci měli 
zase $(a,b)$-strom). V algoritmu pak odpadne vyva\-žo\-vací 
část (tj. {\bf Štěpení} při cestě vzhůru ke 
kořeni).

Při operaci {\bf DELETE} jsou ve vyhledávací fázi uzavřeny 
vrcholy $t$, $\otec(t)$, bezprostřední bratr $y$ vrcholu $
t$ a 
jejich synové. 
Když $\rho (t)=a$, pak po najiti vrcholu, kde se bude 
pokračovat, se provede buď {\bf Přesun} (když $\rho (
y)>a$) nebo 
{\bf Spojení} (když $\rho (y)=a$). Stejně jako při operaci 
{\bf INSERT} se vynechá vyva\-žo\-vací část 
uzavírající původní algoritmus.

Tato úprava vyžaduje sice více {\bf Štěpení}, {\bf Spojení} a
{\bf Přesunů}, ale asymptoticky vychází čas stejný 
(jen je větší multiplikativní konstanta). Doporučené 
hodnoty $a$ a $b$ jsou $a\approx 100$ a $b=2a+2$ při uložení na serveru 
v externí paměti, ve vnitřní paměti 
se doporučuje $a=2$, $b=6$.

Operace {\bf JOIN2} lze také paralelizovat, ale operaci {\bf SPLIT  }
paralelizovat nelze.

$(a,b)$-stromy dávají také zajímavé aplikace pro 
třídicí 
algoritmy. Použití $(a,b)$-stromů pro setřídění 
náhodné posloupnosti není vhodné, režie na udržování 
struktury $(a,b)$-stromu vede k tomu, že multiplikativní 
konstanta by byla o hodně větší než u klasických 
třídicích algoritmů. Také uložení $(
a,b)$-stromu 
vyžaduje více paměti než je potřeba pro klasické 
algoritmy. Situace se podstatně změní, když vstupní 
posloupnost je před\-tří\-děná a je ji třeba jen dotřídit. 
Klasické algoritmy většinou nejsou schopné využít faktu, že 
posloupnost je předtříděná, a jejich časová náročnost je 
prakticky stejná (někdy i horší) jako u náhodné 
posloupnosti. Na rozdíl od nich algoritmus $A$-{\bf sort }
založený na $(a,b)$-stromech je schopen předtříděnost 
využít a má na předtříděných posloupnostech lepší 
výsledky než klasické algoritmy.

Modifikace $(a,b)$-stromů pro algoritmus 
$A$-{\bf sort}. Máme $(a,b)$-strom reprezentující vstupní 
posloupnost, je dán ukazatel $\Prv$ na první list, listy 
$(a,b)$-stromu jsou propojeny do seznamu v rostoucím 
lexikografickém pořadí (ukazatel na následující prvek je 
$\Nasl$) a je dána cesta z prvního listu do kořene (to 
znamená, že na cestě z prvního listu do kořene známe 
pro každý vrchol $v$ jeho otce). Nyní uvedeme algoritmus 
$A$-{\bf sort}. 

$A$-{\bf sort$(x_1,x_2,\dots,x_n)$\newline 
$i:=n-1$}, vytvoř jednoprvkovy strom s vrcholem $t$\newline 
$\key(t):=x_n$, $\Prv:=t$\newline 
{\bf while} $i\ge 1$ {\bf do $A$-Insert$(x_i)$}, $i:=i-1$ {\bf enddo}\newline 
$y_1:=\key(\Prv)$\newline 
{\bf while} $i\le n$ {\bf do\newline 
\phantom{---}$y_i:=\key(t)$}, $i:=i+1$, $t:=\Nasl(t)$\newline 
{\bf enddo\newline 
Výstup}: $(y_1,y_2,\dots,y_n)$ setříděná posloupnost $
(x_1,x_2,\dots,x_n)$

$A$-{\bf Insert$(x)$\newline 
$t:=\Prv$\newline
while} $t\ne\text{\rm kořen }T$ a $H_t(1)<x$ {\bf do $t:=\otec(t)$ enddo\newline 
while} $t\ne\text{\rm list}$ {\bf do}\newline 
\phantom{---}$i:=1$\newline 
\phantom{---}{\bf while} $H_t(i)<x$ a $i<\rho (t)$ {\bf do} $i:=i+1$ {\bf enddo}\newline 
\phantom{---}{\bf if} $i>1$ {\bf then} $v:=S_t(i-1)$ {\bf else} $v:=S_t(\rho (t))$ {\bf endif}\newline 
\phantom{---}$t:=S_t(i)$\newline 
{\bf enddo\newline 
if} $\key(t)\ne x$ {\bf then\newline }
\phantom{---}vytvoř nový list $t'$, $\key(t')=x$,\newline
\phantom{---}{\bf if} $t$ je kořen {\bf then}\newline 
\phantom{------}vytvoř nový kořen $u$, $\rho (u):=2$\newline 
\phantom{------}{\bf if} $\key(t)>x$ {\bf then}\newline 
\phantom{---------}$H_u(1):=x,$ $S_u(1):=t'$, $S_u(2):=t$,\newline
\phantom{---------}$\Prv:=t'$, $\Nasl(t'):=t$, $\Nasl(t):=NIL$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$H_u(1):=\key(t)$, $S_u(1):=t$, $S_u(2):=t'$\newline
\phantom{---------}$\Prv:=t$, $\Nasl(t):=t'$, $\Nasl(t'):=NIL$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\otec(t)$\newline 
\phantom{------}{\bf if} $\key(t)<x$ {\bf then}\newline  
(komentář: $x>\max S$)\newline 
\phantom{---------}$S_u(\rho (u)+1):=t'$, $H_u(\rho(u)):=\key(t)$, $\rho(u):=\rho(u)+1$\newline 
\phantom{---------}$\Nasl(t):=t'$, $\Nasl(t'):=NIL$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}najdi $i$, že $S_u(i)=t$, $S_u(\rho(u)+1):=S(\rho(u))$,\newline 
\phantom{---------}$j:=\rho (u)-1$, $\Nasl(v):=t'$, $\Nasl(t'):=t$\newline 
\phantom{---------}{\bf while} $j\ge i$ {\bf do\newline 
\phantom{------------}$S_u(j+1):=S_u(j)$}, $H_u(j+1):=H_u(j)$, $j:=j-1$\newline 
\phantom{---------}{\bf enddo}\newline 
\phantom{---------}$S_u(i):=t'$, $H_u(i):=x$, $\rho (u):=\rho (u)+1$,\newline 
\phantom{---------}{\bf if} $t=\Prv$ {\bf then} $\Prv:=t'$ {\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$t:=u$\newline 
\phantom{------}{\bf while} $\rho (t)>b$ {\bf do Štěpení$(t)$ enddo}\newline 
\phantom{---}{\bf endif\newline 
endif}

Korektnost algoritmu plyne z faktu, že $\key$ je 
izomorfismus uspo\-řá\-dání a seznam listů je v 
rostoucím pořadí. Protože $v$ je vždy bez\-prost\-řední 
předchůdce $t$, je seznam korektně definován. 
U\-ka\-zatel $\otec(t)$ je dán na cestě z vrcholu $\Prv$ do 
kořene, pro ostatní vrcholy se řeší stejným 
způsobem jako pro $(a,b)$-stromy.

Složitost algoritmu: Algoritmus $A$-{\bf sort} vyžaduje více 
času i více paměti než klasické třídicí algoritmy, ale jejich 
asymptotická složitost je stejná. Jeho výhoda je v použití 
na před\-tří\-děné posloupnosti. Mějme posloupnost $
(x_1,x_2,\dots,x_n)$ 
prvků z to\-tálně uspořádaného univerza $U$ a definujme 
$$F=|\{(i,j)\mid i<j,\,x_j<x_i\}|.$$
Zřejmě $F=0$, právě když posloupnost 
$(x_1,x_2,\dots,x_n)$ je setří\-děná. Dále $0\le F\le\binom 
n2$ a $F=\binom n2$, právě 
když je posloupnost $(x_1,x_2,\dots,x_n)$ klesající. To vede k tomu 
brát $F$ jako míru předtříděnosti posloupnosti. Spočítáme 
složitost algoritmu $A$-{\bf sort} v závislosti na $n$ a $F$

Zřejmě algoritmus $A$-{\bf sort v} nejhorším případě vyžaduje čas, 
který potřebuje $A$-{\bf Insert}, plus $O(n)$.  Algoritmus $
A$-{\bf Insert$(x)$ }
vyžaduje čas potřebný na nalezení místa, kam vložit $
x$, plus 
$O(\text{\rm počet volání {\bf Štěpení}})$.  Protože každý běh procedury 
{\bf Ště\-pení} vytvořil jeden vnitřní vrchol $
(a,b)$-stromu a protože $a\ge 2$ 
a $(a,b)$-strom po skončení volání $A$-{\bf Insert} má $
n$ listů, 
je vnitřních vrcholů $(a,b)$-stromu $<n$.  Proto všechny 
běhy procedury $A$-{\bf Insert} vyžadují čas na nalezení míst 
jednotlivých prvků plus $O(n)$.  Když procedura 
$A$-{\bf Insert$(x)$} při hledání místa pro prvek $x$ skončila ve výšce $
h$ 
(tj.  první cyklus se $h$-krát opakoval), pak nalezení místa pro 
prvek $x$ vyžadovalo čas $O(h)$.  Všechny prvky reprezentované 
$(a,b)$-stromem pod prvním vrcholem ve výšce $h-1$ jsou menší 
než $x$ a je jich alespoň $a^{h-1}$.  Když $x=x_i$, pak počet 
prvků reprezentovaných $(a,b)$-stromem při běhu 
procedury $A$-{\bf Insert$(x)$}, které jsou menší než $
x$, je počet $j$ takových, že $i<j$ a $x_j<x_i$.
Označme $f_i$ tento počet. Pak platí 
$$a^{h-1}\le f_i\implies h-1\le\log_af_i\implies h\in O(\log f_i).$$

Proto v nejhorším případě čas potřebný pro nalezení 
pozice $x_i$ je $O(\log f_i)$. Odtud plyne, že čas algoritmu potřebný k 
běhu algoritmu $A$-{\bf sort} je 
$$O((\sum_{i=1}^n\log f_i)+n).$$

Zřejmě $\sum_{i=1}^nf_i=F$ a nyní využijeme toho, že geometrický 
průměr je vždy menší nebo roven aritmetickému 
průměru, a odtud dostáváme 
\begin{align*}\sum_{i=1}^n\log f_i=&\log\prod_{i=1}^nf_i=n\log(\prod_{i
=1}^nf_i)^{\frac 1n}\le\\
&n\log\frac {\sum_{i=1}^nf_i}n=n\log\frac Fn.\end{align*}

\begin{veta}Algoritmus $A$-{\bf sort} na setřídění $
n$-členné 
posloupnosti vyžaduje v nejhorším případě čas 
$O(n+n\log\frac Fn)$, kde $F$ je míra setříděnosti vstupní 
posloupnosti.
\end{veta}

Zhodnocení: Protože $A$-{\bf sort} nepoužívá operaci 
{\bf DELETE}, doporučuje se použít $(2,3)$-stromy. Když se 
budou třídit posloupnosti s mírou $F\le n\log n$, pak 
algoritmus $A$-{\bf sort} bude potře\-bo\-vat v nejhorším případě 
čas $O(n\log\log n)$. Mehlhorn a Tsa\-kalidis dokázali, že když 
$F\le 0.02n^{1.57}$, pak algoritmus $A$-{\bf sort} je rychlejší než 
algoritmus {\bf Quicksort}.

\subsection{Propojené stromy s prstem}

\emph{Hladinově} \emph{propojený} $(a,b)$-\emph{strom} \emph{s} 
\emph{prstem} je $(a,b)$-strom, kde struktura vnitřního 
vrcholu různého od kořene je 
rozšířena (proti klasickému $(a,b)$-stromu) o 
ukazatele:\newline 
$\otec(v)$, $\levy(v)$, $\pravy(v)$, kde\newline 
$\levy(v)$ ukazuje na největší vrchol (v lexikografic\-kém 
uspořá\-dá\-ní) ve stejné hladině jako $v$, který je menší než 
$v$ (když neexistuje, tak je to $NIL$),\newline 
$\pravy(v)$ ukazuje na nejmenší vrchol (v lexikografic\-kém 
uspořá\-dá\-ní) ve stejné hladině jako $v$, který je větší než 
$v$ (když ne\-existuje, tak je to $NIL$).\newline 
Navíc je dán ukazatel 
$\Prst$ na některý list. 

Zde se liší hlavně vyhledávání, které je zobecněním 
postupu $A$-{\bf sortu}. Začínáme od listu $p$, na který ukazuje 
$\Prst$. Když $x$ je menší než prvek reprezentovaný tímto 
listem, pak se pokračuje v jeho otci $v$, a když $p$ 
byl $i$-tý syn $v$, tak se pomocí pole $H_v$ zjišťuje, zda $
x$ 
nemá být reprezentován v podstromu jeho $j$-tého syna pro 
$j<i$. Když ne, pokračuje se  ukazatelem $\levy(v)$. 
Když $x$ není reprezentován ani v jeho podstromu, 
tak se celý postup opakuje o hladinu výš (zkoumá se otec vrcholu). 
Když $x$ je větší než prvek reprezentovaný listem $
p$, 
je postup zrcadlově obrácený. Když se nalezne 
vrchol, v jehož podstromu má $x$ ležet, pak se aplikuje od 
tohoto vrcholu (místo od kořene) procedura {\bf Vyhledej}.



Struktura kromě operací uspořádaného 
slovníkového prob\-lé\-mu 
ještě používá přidanou ope\-raci {\bf PRST$(x)$}, která nastaví ukazatel 
$\Prst$ na list, který reprezentuje nejmenší prvek větší 
nebo rovný $x$ (pokud $x>\max S$, tak ukazatel $\Prst$ bude 
ukazovat na největší list). Operace provedou vyhledání a 
pak pokračují klasickým způsobem.

Použití: Tato struktura je velmi výhodná pro 
úlohy, kde vždy skupina po sobě jdoucích ope\-rací  
pracuje v blízkém okolí něja\-ké\-ho $x\in U$. Pak 
vyhledání prvku je rychlejší než v klasickém 
$(a,b)$-stromu, viz $A$-{\bf sort}.

Vyvažovací operace {\bf Štěpení, Spojování, Přesun }
vyžadují čas $O(1)$, ale ve skutečnosti jsou nejpomalejší 
částí 
algoritmů pro operace {\bf INSERT} a {\bf DELETE}.  Omezení 
jejich počtu vedlo k menší složitosti algoritmu $A$-{\bf sort}.  To motivovalo analýzu 
jejich použití.\newline 
Libovolný běh algoritmu {\bf INSERT }
volá podproceduru {\bf Štěpe\-ní} nejvýše $\log(|
S|)$-krát a libovolný běh 
algoritmu  {\bf DELETE} mů\-že nejvýše $\log(|S|
)$-krát zavolat podproceduru 
{\bf Spojení }
a nejvýše jednou podproceduru {\bf Přesun}.  V obecném 
případě tyto od\-ha\-dy nejdou zlepšit.  Pro vhodný typ 
$(a,b)$-stromu však amortizovaný počet vyvažovacích 
ope\-rací (začínáme-li s  
pů\-vod\-ně práz\-dným stromem) je konstantní.

Pro pevné $a$ a $b$ označme 
$$c=\min\{\min\{2a-1,\lceil\frac {b+1}2\rceil \}-a,b-\max\{2a-1,\lfloor\frac {
b+1}2\rfloor \}\}.$$
Připomínáme, že \emph{výška} \emph{vrcholu} v kořenovém stromě je 
maximální délka cesty z něho do některého listu.

\begin{veta}Nechť $b\ge 2a$ a $a\ge 2$. Nechť $\mathcal P$ je 
posloupnost $n$ operací {\bf INSERT} a {\bf DELETE}, aplikujme ji na 
prázdný $(a,b)$-strom. Označme\newline 
$St_h$ -- počet {\bf Štěpení} ve výšce $h$ při aplikaci $
\mathcal P$, $St=\sum_hSt_h$;\newline 
$Sp_h$-- počet {\bf Spojení} ve výšce $h$ při aplikaci $
\mathcal P$, 
$Sp=\sum_hSp_h$;\newline 
$P_h$ -- počet {\bf Přesunů} ve výšce $h$ při aplikaci $
\mathcal P$, 
$P=\sum_hP_h$.\newline 
Pak platí
\begin{enumerate}
\item
$$P\le n\quad \text{\rm a}\quad (2c-1)St+cSp\le n+c+\frac {c(n-2)}{a+c-1};$$
\item
$$St_h+Sp_h+P_h\le\frac {2(c+2)n}{(c+1)^h}.$$
\end{enumerate}
\end{veta}

Z definice plyne, že $c\ge 1$, a protože $a\ge 2$, z 1) dostaneme
$$St+Sp\le\frac nc+1+\frac {n-2}a\le n+1+\frac {n-2}2\le\frac {3n}
2.$$
Amortizovaný počet vyvažovacích operací splňuje tedy 
$$\frac {P+St+Sp}n\le\frac 52.$$

Důkaz je založen na bankovním principu -- 
navrhneme kvantitativní ohodnocení $(a,b)$-stromu, 
nalezneme jeho horní odhad a popíšeme, jak 
toto ohodnocení mohou změnit vyvažo\-vací ope\-race. Srovnání 
těchto odhadů dá požadovaný výsledek.

Mějme $(a,b)$-strom $T$, pro vnitřní vrchol 
$v$ různý od kořene definuj\-me 
$b(v)=\min\{\rho (v)-a,b-\rho (v),c\}$, pro 
kořen $r$ definuj\-me $b(r)=\min\{\rho (r)-2,b-\rho (r),c\}$. 

\begin{pozorovani}Pro vnitřní vrchol stromu $v$  
různý od kořene platí
\begin{enumerate}
\item
$b(v)\le c$;
\item
když $\rho (v)=a$ nebo $\rho (v)=b$, pak $b(v)=0$;
\item
když $\rho (v)=a-1$ nebo $\rho (v)=b+1$, pak $b(v)=-1$;
\item
když $\rho (v)=2a-1$, pak $b(v)=c$;
\item
Když $v'$ a $v^{\prime\prime}$ jsou dva různé vrcholy stromu 
různé od kořene takové, že $\rho (v')=\lceil\frac {
b+1}2\rceil$ a 
$\rho (v^{\prime\prime})=\lfloor\frac {b+1}2\rfloor$, pak $b(v')+
b(v^{\prime\prime})\ge 2c-1$;
\item
pro kořen $r$ platí $b(r)\le c$.
\end{enumerate}
\end{pozorovani}

Strom $(T,r)$ ohodnotíme 
\begin{align*} b_h(T)=&\sum \{b(v)\mid v\ne r\text{\rm\ vnitřní vrchol stromu }\text{\rm\ ve výšce }
h\}\\
b(T)=&\sum_{h=1}^{\infty}b_h(T)+b(r).\end{align*}
Řekneme, že $(T,r,v)$ je \emph{parciální} 
$(a,b)$-\emph{strom}, když $r$ je kořen stromu, $v$ je vnitřní 
vrchol $T$ a platí:
\begin{itemize}
\item
když $v\ne r$, pak $a-1\le\rho (v)\le b+1$ a $2\le\rho (r)\le 
b$;
\item
když $v=r$, pak $2\le\rho (r)\le b+1$;
\item
když $t$ je vnitřní vrchol $T$ různý od $v$ a $
r$, pak 
$$a\le\rho (t)\le b;$$
\item
všechny cesty z kořene $r$ do nějakého listu mají stejnou 
délku.
\end{itemize}

Nyní rozložíme operace {\bf INSERT} a {\bf DELETE} do 
jednotlivých akcí se stromem a vyšetří\-me vliv těchto 
akcí na jeho ohodnocení. Důkazy lemmat jsou 
založené na následujícím pozorování

\begin{pozorovani}Mějme dva stromy $T$ a $T'$, které mají 
stejnou množinu vrcholů ve výšce $h$. Pak platí:
\begin{enumerate}
\item
když každý vrchol ve výšce $h$ má stejný počet synů 
v obou stromech, pak $b_h(T)=b_h(T')$;
\item
když všechny vrcholy ve výšce $h$ až na jeden vrchol mají stejný 
počet synů v obou stromech a počet synů u zby\-lé\-ho vrcholu se ve stromech $
T$ a $T'$ liší nejvýše o $1$, pak $b_h(T)\ge b_h(T')-
1$.
\end{enumerate}
\end{pozorovani}

\begin{lemma_counting}Když $(T,r)$ je $(a,b)$-strom a když strom $
T'$ 
vznikne z $T$ přidáním/ubráním jednoho syna vrcholu $
v$ 
ve výšce $1$ (tj. přidávaný/ubíraný syn je list), pak 
$(T',r,v)$ je parciální $(a,b)$-strom a platí 
\begin{align*} b_1(T')\ge&b_1(T)-1\quad\text{\rm a }b_h(T')=b_h(T)\text{\rm\ pro }
h>1;\\
b(T')\ge&b(T)-1.\end{align*}
\end{lemma_counting}

\begin{lemma_counting}Nechť $(T,r,v)$ je parciální $(a,b)$-strom, 
$\rho (v)=b+1$ a $v$ je ve výšce $l\ge 1$. Když $T'$ vznikne z $
T$ 
operací {\bf Štěpení$(v)$}, pak $(T',r,\otec(v))$ je parciální 
$(a,b)$-strom a platí:  
\begin{align*} b_l(T')\ge&b_l(T)+2c,\text{\rm\ }b_{l+1}(T')\ge b_{l+1}(
T)-1\\
b_h(T')=&b_h(T)\text{\rm\ pro }h\ne l,l+1;\quad b(T')\ge b(T)+2c-
1.\end{align*}
\end{lemma_counting}

\begin{lemma_counting}Nechť $(T,r,v)$ je parciální $(a,b)$-strom, 
$\rho (v)=a-1$, $v$ je ve výšce $l\ge 1$ a $y$ je bezprostřední bratr $v$ takový že $\rho(y)=a$. Když $T'$ vznikne z $T$ operací {\bf Spojení$(v,y)$}, pak $(T',r,\otec(v))$ je parciální $(a,b)$-strom a 
platí:  
\begin{align*} b_l(T')\ge&b_l(T)+c+1,\text{\rm\ }b_{l+1}(T')\ge b_{l+1}
(T)-1\\
b_h(T')=&b_h(T)\text{\rm\ pro }h\ne l,l+1;\quad b(T')\ge b(T)+c.\end{align*}
\end{lemma_counting}

\begin{lemma_counting} Nechť $(T,r,v)$ je parciální $(a,b)$-strom, 
$\rho (v)=a-1$, $v$ je výšce $l\ge 1$ a $y$ je bezprostřední bratr $v$ takový, že $\rho(y)>a$. 
Když $T'$ vznikne z $T$ operací {\bf Přesun$(v,y)$}, 
pak $(T',r)$ je $(a,b)$-strom a platí:  
$$b_l(T')\ge b_l(T)\text{\rm\ a }b_h(T')=b_h(T)\text{\rm\ pro }h\ne 
l;\quad b(T')\ge b(T).$$
\end{lemma_counting}

Označme $T_k$ $(a,b)$-strom vzniklý provedením posloupnosti 
$\mathcal P$ na prázdný $(a,b)$-strom. Sečtením předchozích 
výsledků dostá\-váme

\begin{dusledek_counting}Když položíme 
\begin{gather*} St_0+Sp_0=\text{\rm počet listů v }T_k\le n
,\quad\text{\rm pak}\\
b_h(T_k)\ge 2cSt_h+(c+1)Sp_h-St_{h-1}-Sp_{h-1}\text{\rm\ pro }h\ge 
1.\end{gather*}
Dále $b(T_k)\ge (2c-1)St+cSp-n$, kde $n$ je délka posloupnosti $
\mathcal P$.
\end{dusledek_counting}

První výraz upravíme (využíváme, že $
c\ge 1$):
\begin{align*} St_h+Sp_h\le&\frac {b_h(T_k)}{c+1}+\frac {St_{h-1}+Sp_{h
-1}}{c+1}\le\\
&\frac {b_h(T_k)}{c+1}+\frac {b_{h-1}(T_k)}{(c+1)^2}+\frac {St_{h
-2}+Sp_{h-2}}{(c+1)^2}\le\dots\le\\
&\sum_{i=0}^{h-1}\frac {b_{h-i}(T_k)}{(c+1)^{i+1}}+\frac n{(c+1)^
h}=\\
&\frac n{(c+1)^h}+\sum_{l=1}^hb_l(T_k)\frac {(c+1)^l}{(c+1)^{h+1}}
.\end{align*}

Nyní odhadneme shora $b(T_k)$.

\begin{lemma_counting}Když $T$ je $(a,b)$-strom s $m$ listy, pak 
$0\le b(T)\le c+(m-2)\frac c{a+c-1}$.
\end{lemma_counting}

\begin{proof}Pro $0\le j<c$ označme $m_j$ počet 
vnitřních vrcholů různých od kořene, 
které mají přesně $a+j$ synů, a $m_c$ označme 
počet vnitřních vrcholů různých od 
kořene, které mají alespoň $a+c$ synů. Když 
vrchol $v$ má $a+j$ synů, pak $b_T(v)\le j$ a pro 
každý vnitřní vrchol $v$ platí $b_T(v)\le c$. Tedy 
$b(T)\le c+\sum_{j=0}^cjm_j$. Z vlastností stromů plyne 
\begin{align*}2+\sum_{j=0}^c(a+j)m_j\le&\sum \{\rho (v)\mid v\text{\rm\ je vnitřní vrchol }
T\}=\\
&m+\sum_{j=0}^cm_j.\end{align*}
Odtud plyne
$$\sum_{j=0}^c(a+j-1)m_j\le m-2.$$
Protože $\frac j{a+j-1}\le\frac c{a+c-1}$ pro každé $j$ takové, že $
0\le j\le c$, 
dostáváme
\begin{align*} b(T)\le&c+\sum_{j=0}^cjm_j=c+\sum_{j=0}^c\frac j{a+j-1}(
a+j-1)m_j\le\\
&c+\frac c{a+c-1}(m-2)\end{align*}
a lemma je dokázáno.
\end{proof}

Nyní dokážeme tvrzení (1) Věty. Protože každá operace 
{\bf DE\-LETE} použije nejvýše jednu operaci {\bf Přesun} (a operace 
{\bf INSERT} operaci {\bf Přesun} nepoužívá) dostáváme, že 
$$P\le\text{\rm počet operací {\bf DELETE}}\le n$$
a první nerovnost platí. 
Abychom dokázali druhou nerovnost, spojíme druhé 
tvrzení v Důsledku 5 a Lemma 6 ($T_k$ má nejvýše 
$n$ listů) 
$$(2c-1)St+cSp-n\le b(T_k)\le c+(n-2)\frac c{a+c-1}$$
Odtud plyne požadovaná nerovnost a (1) je dokázáno.

Důkaz (2) využije následující odhad.

\begin{lemma_counting}Pro každé $h\ge 1$ a pro každý 
$(a,b)$-strom $T$ s $m$ listy platí 
$$\sum_{l=1}^hb_l(T)(c+1)^l\le (c+1)m.$$
\end{lemma_counting}

\begin{proof}Pro $0\le j<c$ a pro libovolné $h$ 
označme $m_j(h)$ počet vrcholů ve výšce $h$ 
různých od kořene, které mají přesně $a
+j$ 
synů, a $m_c(h)$ počet vrcholů ve výšce $
h$ 
různých od kořene, které mají alespoň $a+c$ 
synů. Pak máme
\begin{align*} b_h(T)\le&\sum_{j=0}^cjm_j(h)\text{\rm},\\
\sum_{j=0}^c(a+j)m_j(h)\le&\sum_{j=0}^cm_j(h-1)\text{\rm\ pro každé }
h\ge 1,\end{align*}
kde dodefinováváme $\sum_{j=0}^cm_j(0)=m$. Tyto vztahy 
použijeme v následujícím odhadu. Platí 
\begin{align*}\sum_{l=1}^hb_l(T)&(c+1)^l\le\sum_{l=1}^h\big[(c+1)^l\big
(\sum_{j=0}^cjm_j(l)\big)\big]\le\\
&\sum_{l=1}^h\big[(c+1)^l\big(\sum_{j=0}^cm_j(l-1)-a\sum_{j=0}^cm_
j(l)\big)\big]=\\
&(c+1)\sum_{j=0}^cm_j(0)-(c+1)^ha\sum_{j=0}^cm_j(h)+\\
&\quad\sum_{l=1}^{h-1}(c+1)^{l+1}\big(\sum_{j=0}^cm_j(l)-\frac a{
c+1}\sum_{j=0}^cm_j(l)\big)\le\\
&(c+1)m,\end{align*}
kde rovnost jsme získali přerovnáním sčítanců 
tak, aby výrazy $\sum_{j=0}^cm_j(l)$ byly u sebe, a poslední 
nerovnost plyne z toho, že $\frac a{c+1}\ge 1$, a tedy druhý sčítanec 
v předchozím výrazu není kladný.
\end{proof}
 

Zkombinujeme odhad $St_h+Sp_h$ s Lemmatem 7 a 
dostaneme
\begin{align*} St_h+Sp_h\le&\frac n{(c+1)^h}+\sum_{l=1}^hb_l(T_k)\frac {
(c+1)^l}{(c+1)^{h+1}}\le\\
&\frac n{(c+1)^h}+\frac {n(c+1)}{(c+1)^{h+1}}=\frac {2n}{(c+1)^h}
.\end{align*}
Protože $P_h\le Sp_{h-1}-Sp_h\le St_{h-1}+Sp_{h-1}\le\frac {2n}{
(c+1)^{h-1}}$ 
dostáváme, že 
\begin{align*} St_h+Sp_h+P_h\le&\frac {2n}{(c+1)^h}+\frac {2n}{(c+1)^{h
-1}}=\frac {2n+2n(c+1)}{(c+1)^h}=\\
&\frac {2n(c+2)}{(c+1)^h}\end{align*}
a důkaz (2) ve Větě je hotov.

Věta vysvětluje, proč jsou doporučené hodnoty $
b\ge 2a$ -- 
pak je počet vyvažovacích ope\-rací během posloupnosti 
operací {\bf INSERT} a {\bf DELETE} lineární vzhledem k délce 
této posloupnosti. Pro $b=2a-1$ lze lehce nalézt 
posloupnost operací {\bf INSERT} a {\bf DELETE} o délce $n$ takovou, 
že její aplikace na prázdný $(a,b)$-strom vyžaduje počet 
vyvažovacích operací ú\-měrný $n\log n$ (pro každé 
dostatečně velké $n$). Podobná věta platí i pro paralelní 
implementaci $(a,b)$-stromů, ale platí za 
předpokladu $b\ge 2a+2$. Pro $b=2a$ nebo $b=2a+1$ lze 
nalézt posloupnost, která je protipříkladem. Proto se 
doporučuje hodnota $b=2a+2$ pro paralelní implementaci 
$(a,b)$-stromu. Pro propojené $(a,b)$-stromy platí silnější 
verze.

\begin{veta}Předpokládejme, že $b\ge 2a$ a $a\ge 2$. Mějme 
hladinově propojený $(a,b)$-strom s prstem $T$, který reprezentuje 
$n$-prvkovou množinu. Pak posloupnost $\mathcal P$ operací {\bf MEMBER},
{\bf INSERT}, {\bf DELETE} a {\bf PRST} aplikovaná na $T$ vyžaduje čas 
$$O(\log(n)+\text{\rm\ čas na vyhledání prvků})
.$$
\end{veta}

Vysvětlení: Začínáme v libovolném 
propojeném $(a,b)$-stro\-mě $T$, proto jeho struktura 
může být nevýhodná pro danou pos\-loupnost operací $
\mathcal P$. 
Abychom se dostali do vhodného režimu, může 
být třeba až $\log(n)$ vyvažovacích operací. Čas na 
vy\-hledává\-ní nemůžeme ovlivnit, ten musí 
ovlivnit uživatel.

Aplikace: analýza hladinově propojených stromů s prstem 
u\-mož\-nila návrh algoritmu, který pro dvě množiny $
S_1$ a $S_2$ 
repre\-zentované propojenými $(a,b)$-stromy, kde $b\ge 2a$ a 
$a\ge 2$, 
zkonstruuje propojený $(a,b)$-strom reprezentující množinu 
$S_1\cup S_2$ (nebo množinu $\Delta (S_1,S_2)=(S_1\setminus S_
2)\cup (S_2\setminus S_1)$ nebo 
$S_1\cap S_2$ nebo $S_1\setminus S_2$) v čase $O(\log\binom {n
+m}m)$, kde 
$n=\max\{|S_1|,|S_2|\}$ a $m=\min\{|S_1|,|S_2|\}$. Detaily budou v letním 
semestru.

Vyvažování při operaci {\bf INSERT} lze provádět 
tak, že operace {\bf Štěpení$(t)$} se provede, jen když oba 
bratři vrcholu $t$ mají $b$ synů. Jinak se provádí 
operace {\bf Přesun}. Nevím o žádném seriózním pokusu tyto 
alternativy porovnat.   

\section{Vyhledávání v uspořádaném poli}

Zadání úlohy: Máme podmnožinu $S$ lineárně 
uspořádaného univerza a $S$ je uložena v poli 
$A[1..|S|]$ tak, že pro $i<j$ je $A(i)<A(j)$. Pro dané $x\in 
U$ 
máme zjistit, zda $x\in S$ (operace {\bf MEMBER$(x)$}).

Řešení:  Pokud $x<A(1)$ nebo $A(|S|)<x$, pak $
x$ 
není prvkem $S$.  V opačném případě buď $x=
A(1)$ nebo 
$x=A(|S|)$ nebo máme dvě hodnoty $d$ 
a $h$ takové, že $1\le d<d+1<h\le |S|$ a $A(d)<x<A(h)$.  Pak 
najdeme $n$ takové, že $d<n<h$, a dotazem 
zjistíme, zda $x=A(n)$ (pak končíme a $x\in S$) nebo 
$x<A(n)$ (pak položíme $h=n$) nebo $x>A(n)$ (pak 
položíme $d=n$) a proces opakujeme.  Končíme, když 
$d+1\ge h$, pak $x\notin S$. Na začátku položíme $d=1$ a $
h=|S|$.
Formální zápis algoritmu:

{\bf MEMBER$(x)$\newline 
if} $x=A(1)$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$ stop\newline 
{\bf else}\newline 
\phantom{---}{\bf if} $x<A(1)$ {\bf then}\newline 
\phantom{------}{\bf Výstup}: $x\notin S$ stop\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$d=1$\newline 
\phantom{---}{\bf endif\newline
\bf endif\newline 
if} $x=A(|S|)$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$ stop\newline 
{\bf else}\newline 
\phantom{---}{\bf if} $x>A(|S|)$ {\bf then}\newline 
\phantom{------}{\bf Výstup}: $x\notin S$ stop\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$h=|S|$\newline 
\phantom{---}{\bf endif\newline
endif\newline 
while} $d+1<h$ {\bf do}\newline 
\phantom{---}$n:=\text{{\bf next}}(d,h)$\newline 
\phantom{---}{\bf if} $\bold x=A(n)$ {\bf then}\newline 
\phantom{------}{\bf Výstup}: $\bold x\in S$ stop\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $x<A(n)$ {\bf then} $h:=n$ {\bf else} $d:=n$ {\bf endif}\newline 
\phantom{---}{\bf endif\newline 
enddo\newline 
Výstup}: $x\notin S$ stop

V tomto metaalgoritmu je {\bf next$(d,h)$} funkce, která 
nalezne hodnotu $n$ takovou, že $d<n<h$. Korektnost plyne 
z pozorování, že když $d+1=h$, pak $A(d)<x<A(h)$ 
implikuje, že neexistuje $i$ takové, že $x=A(i)$, a tedy 
$x\notin S$. Efektivita algoritmu záleží na fukci {\bf next}. 
Zpracování dotazu vyžaduje čas $O(1)$ a počet 
dotazů je 
počet volání funkce {\bf next}. 

Unární vyhledávání: {\bf next$(d,h)=d+1$}, pak každý 
dotaz zvětší $d$ o $1$, a tedy největší počet 
dotazů je $|S|$. Algoritmus v nej\-horším případě 
vyžaduje čas $O(|S|)$ a očekávaný počet dotazů při 
rovnoměrném rozložení množiny $S$ a prvku $x$ je $\frac {
|S|}2$ 
(tedy očekávaný čas je $O(|S|)$). 

Poznámka: Duální přístup je, když 
{\bf next$(d,h)=h-1$}, výsled\-ky se nezmění. Při aplikacích je 
někdy výhodné použít funkci {\bf next$(d,h)=\min\{d
+c,h-1\}$}, 
kde $c$ je nějaká konstanta (pak krok není $1$, ale $c$). Jak 
uvidíme později, jsou situace, kdy je výhodné  
takovéto unární vyhledávání použít.

Binární vyhledávání: {\bf next$(d,h)=\lceil\frac {
d+h}2\rceil$}, pak 
každý dotaz zmenší rozdíl $h-d$ přibližně na polovinu. 
Počet dotazů je nejvýše $3+\log(|S|-2)$, 
algoritmus tedy v 
nejhorším případě vyžaduje čas $O(\log|S|)$ a  
očekávaný čas při rovnoměrném roz\-ložení množiny $
S$ a 
$x\in U$ je také $O(\log|S|)$.

Interpolační vyhledávání: 
{\bf next$(d,h)=d+\lceil\frac {x-A(d)}{A(h)-A(d)}(h-d)\rceil$}. V nejhorším případě 
musíme položit více než $\frac {|S|}2$ dotazů, a proto čas 
v nejhorším případě je $O(|S|)$, ale při rovnoměrném 
roz\-ložení množiny $S$ a $x\in U$ je očekávaný čas 
$O(\log\log|S|)$. To je založeno na faktu, že hodnota {\bf next }
závisí i na velikosti $x$. Když $x$ je velké, tak hodnota 
{\bf next} je posunuta do větších hodnot, když $x$ je malé, 
pak je posunuta do menších hodnot.

Poznámka: Když rozložení prvků není 
rovnoměrné, ale je zná\-mé, pak podle toho můžeme  
upravit funkci {\bf next} a očekávaný čas algoritmu se 
nezmění.

Pro následující funkci {\bf next} bude 
jednodušší spočítat očekáva\-ný počet dotazů než 
pro interpolační vyhledávání, ale výsledek je 
asymptoticky stejný.

\subsection{Zobecněné kvadratické vyhledávání}

Funkce {\bf next }
je zde definována složitější procedurou, jejíž vý\-sle\-dek 
závisí i na předcho\-zích situacích a na výsledku dotazu.
Procedura zadává dotazy v blocích. První dotaz v bloku je 
interpolační a procedura přitom zjistí velikost kroku a 
zda $x$ je menší nebo větší než první dotaz v bloku.  
Pak střídá unární a binární vy\-hledávání. Blok končí, 
když rozdíl mezi $h$ a $d$ je nejvýše velikost 
kroku. Krok v následujícím bloku klesne 
přibližně na odmoc\-ninu velikosti kroku v tomto bloku. 
Procedura používá boolské pro\-měnné $blok$, $typ$, $
smer$. 
Proměnná $blok$ je inicializována hodnotou $false$ a určuje, 
zda se dotaz zadává v rámci stejného bloku nebo nikoliv. 
Proměnná $typ$ určuje, zda příští dotaz je unární (když 
$typ=true$) nebo binární. Proměnná $smer$ určuje, zda 
dotazy jsou menší než první dotaz v bloku ($smer=tr
ue$) 
nebo větší. Dále procedura používá proměnnou $
krok$ 
typu integer, která obsahuje velikost kroku v rámci 
bloku. Hodnoty těchto pro\-měn\-ných se předávají z jednoho 
volání procedury do dalšího volání (tj. jsou to 
globální proměnné, které se neinicializují voláním 
procedury {\bf next}). 

{\bf next$(d,h)$\newline 
if} $blok$ {\bf then}\newline 
\phantom{---}{\bf if} $typ$ {\bf then}\newline 
\phantom{------}{\bf if} $smer$ {\bf then}\newline 
\phantom{---------}{\bf next}$(d,h):=h-krok$\newline 
\phantom{---------}{\bf if} $A(\text{{\bf next}}(d,h))<x$ {\bf then}\newline
\phantom{------------}$blok:=false$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}{\bf next}$(d,h):=d+krok$\newline 
\phantom{---------}{\bf if} $A(\text{{\bf next}}(d,h))>x$ {\bf then}\newline \phantom{------------}$blok:=false$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$typ:=false$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\min\{h-\lceil\frac {d+h}2\rceil ,\lceil\frac {d+h}2\rceil-d\}<krok$ {\bf then}\newline 
\phantom{---------}$blok:=false$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}{\bf next}$(d,h):=\lceil\frac {d+h}2\rceil$, $typ:=true$\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}$krok:=\lfloor\sqrt {h-d}\rfloor$, 
{\bf next$(d,h):=d+\lceil\frac {x-A(d)}{A(h)-A(d)}(h-d)\rceil$},\newline 
\phantom{---}{\bf if} $A(\text{{\bf next}}(d,h))>x$ {\bf then}\newline 
\phantom{------}$smer:=true$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$smer:=false$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$typ:=true$, $blok:=true$\newline 
{\bf endif}

Po dvou dotazech klesne $h-d$ buď pod $\sqrt {h-d}$ nebo pod 
$\frac {h+d}2$. Proto procedura v nejhorším případě použije 
nejvýše $8+2\log(|S|-1)+2\log\log|S|$ dotazů, a tedy v nejhorším 
případě vyžaduje čas $O(\log|S|)$.

Nyní spočítáme očekávaný počet dotazů 
během jednoho bloku za předpokladu rovnoměr\-ného rozdělení dat. Nechť $p_i$ je prav\-dě\-podobnost, že 
v rámci bloku se položí ales\-poň $i$ dotazů. Pak 
očekávaný počet dotazů v rámci bloku je 
$$E(C)=\sum_{i\ge 1}i(p_i-p_{i+1})=\sum_{i\ge 1}p_i.$$
Nyní odhadneme $p_i$.  Označme $n+d$ argument prvního dotazu 
(interpolační vyhledávaní) v rámci bloku a nechť $
krok=k$ 
v rámci bloku.  Označme $X=|\{i\mid i>d,\,A(i)\le x\}|$ na 
začátku bloku, pak $X$ je náhodná proměnná závislá na 
argumentu ope\-race a bloku.  Když se v bloku položí 
alespoň $i$ dotazů pro $i>2$, pak $|X-n|\ge\lfloor\frac {
i-2}2\rfloor k$, 
protože každý unární dotaz, jehož položení  
nezmění blok, nalezne dalších $k$ hodnot $i$ v rozdílu $|X-n|$. 
Tedy 
$$p_i\le\Prob(|X-n|\ge\lfloor\frac {i-2}2\rfloor k).$$
Použijeme Čebyševovu nerovnost pro náhodnou 
proměn\-nou $X$. Když $Y$ je náhodná proměnná s očekávanou 
(střední) hodnotou $\mu$ a rozptylem $\sigma^2$, pak Čebyševova 
nerovnost říká, že 
$$\Prob(|Y-\mu |\ge t)\le\frac {\sigma^2}{t^2}\qquad\text{\rm pro každé }
t>0.$$

Uvažujme okamžik, kdy jsme na začátku nějakého 
bloku. Pro\-tože $S$ je vybraná s rovno\-měr\-ným rozdělením, je 
pravděpodob\-nost, že $A(i)<x$ pro $d<i<h$, rovna 
$p=\frac {x-A(d)}{A(h)-A(d)}$, a pak pravděpodobnost, že 
$X=j$, je $\binom {h-d}jp^j(1-p)^{h-d-j}$. To znamená, že $X$ je náhodná 
veličina s binomickým rozdělením s rozsahem $d-h$ a pravděpodobností $p$, a tedy její očekávaná 
hodnota je
$$\mu =\sum_{j=0}^{h-d}j\binom {h-d}jp^j(1-p)^{h-d-j}=p(h-d)$$
a rozptyl má hodnotu 
$$\sigma^2=\sum_{j=0}^{h-d}(j-\mu )^2\binom {h-d}jp^j(1-p)^{h-d-j}
=p(1-p)(h-d).$$
Když si uvědomíme, že $k=\lfloor\sqrt {h-d}\rfloor$ a $
n=p(h-d)$, pak dostáváme
\begin{align*} p_i,p_{i+1}\le&\Prob(|X-n|\ge\lfloor\frac {i-2}2\rfloor k 
)\le\frac {4p(1-p)(h-d)}{(i-2)^2k^2}\le\\
&\frac {4p(1-p)}{(i-2)^2}\le\frac 1{(i-2)^2},\end{align*}
protože pro $0\le p\le 1$ je $p(1-p)\le\frac 14$. Když shrneme tato pozorování, 
dostává\-me, že 
\begin{align*} E(C)=&\sum_{i\ge 1}p_i\le 2+2\sum_{i\ge 3}\frac 1{(i-2)^2}=
2+2\sum_{i\ge 1}\frac 1{i^2}=\\
&2+2\frac {\pi^2}6=2+\frac {\pi^2}3\approx 5.3\end{align*}
Závěr: očekávaný počet dotazů v bloku je menší než $
6$.

Když $E(T(n))$ je očekávaný počet dotazů pro operaci 
{\bf MEMBER} a když $|S|=n$, pak platí 
$$E(T(n))\le E(C)+E(T(\sqrt n)).$$
Protože $E(T(1))=1$ a $E(T(2))\le 2$, dostáváme z rekurentního 
vzorce, že 
$$E(T(n))\le 2+E(C)\log\log n\qquad\text{\rm pro }n\ge 2.$$

\begin{veta}Čas operace {\bf MEMBER} v uspořádaném poli délky $
n$ při 
zobec\-něném kvadra\-tickém vyhledávání je v nejhorším 
přípa\-dě $O(\log n)$. Když rozdělení vstupních dat je 
rovno\-měr\-né, pak očekávaný čas je $O(\log\log n)$. 
\end{veta}

Nevýhoda této datové struktury 
spočívá v neexistenci přiroze\-ných efektivních implementací 
ope\-rací {\bf INSERT}, {\bf DELETE}, {\bf SPLIT} a {\bf JOIN}. Přirozené 
implementace těchto ope\-rací vyža\-dují čas 
$O(|S|)$, zhruba řečeno musíme pohybovat s téměř kaž\-dým prvkem. 
Pokusem o řešení 
tohoto problému byl návrh binár\-ních vyhledávacích 
stromů.

\section{Binární vyhledávací stromy}

Binární vyhledávací strom je struktura pro binár\-ní 
vyhledávání v uspořáda\-ném poli rozta\-ženém do roviny a 
vyhledávání odpo\-ví\-dá cestě ve stro\-mě. Formální 
definice:

Předpokládáme, že $U$ je lineárně uspořádané 
univerzum a $S\subseteq U$.  \emph{Binární} \emph{vyhledávací} 
\emph{strom} $T$ \emph{reprezentující} množinu $S$ je úplný 
binární strom (tj. každý vrchol je buď listem nebo má 
dva syny, levého a pravého), kde existuje bijekce mezi 
množinou $S$ a vnitřními vrcholy stromu taková, že
\begin{itemize}
\item
když $v$ je vnitřní vrchol stromu $T$, kterému je přiřazen 
prvek $s\in S$, pak každému vnitřnímu vrcholu $u$ v 
podstromu levého syna vrcholu $v$ je přiřazen prvek z $S$ 
menší než $s$ a každému vnitřnímu vrcholu $
w$ v 
podstromu pravého syna vrcholu $v$ je přiřazen prvek z $S$ 
větší než $s$.
\end{itemize}

Strukura vnitřního vrcholu $v$:\newline 
ukazatel $\otec(v)$ na otce vrcholu $v$,\newline 
ukazatel $\levy(v)$ na levého syna vrcholu $v$,\newline 
ukazatel $\pravy(v)$ na pravého syna vrcholu $v$,\newline 
atribut $\key(v)$ -- prvek z $S$ přiřazený vrcholu $v$.
Když $v$ je kořen stromu, pak hodnota ukazatele $\otec(v)$ 
je $NIL$. List má ukazatele pouze na otce.

Každý list reprezentuje interval mezi dvěma 
sousedními prvky z $S$ -- přesně, když $u$ je list a je 
levým synem vrcholu $v$, nalezneme vrchol na cestě z $u$ 
do kořene nejblíže $u$ takový, že je pravým synem 
vrcholu $w$. Pak $u$ repre\-zentuje interval $(\key(w),\key(v))$ a 
když vrchol $w$ neexistuje, pak $u$ repre\-zentuje 
interval $(-\infty ,\key(v))$ a prvek $\key(v)$ je nej\-menší prvek v 
$S$.  Když $u$ je list a je pravým synem vrcholu $v$, 
nalezneme vrchol na cestě z $u$ do kořene nejblíže 
$u$ takový, že je levým synem vrcholu $w$. Pak $u$ repre\-zentuje 
interval $(\key(v),\key(w))$ a když takový vrchol $w$ neexistuje, 
pak $u$ repre\-zentuje interval $(\key(v),+\infty )$ a prvek $\key
(v)$ 
je největší prvek v $S$.  

Při implementaci binárních vyhledávácích 
stromů je výhodné vynechat listy (místo nich bude 
ukazatel $NIL$). Při návrhu algoritmů je však 
naopak výhodné 
pracovat s listy (vyhlíží to logičtější). Proto při návrhu 
algoritmů budeme předpokládat, že stromy mají 
listy reprezentující intervaly.

Navrhneme algoritmy pro binární vyhledávací stromy 
rea\-lizují\-cí operace z uspořádaného slovníkového problému.

{\bf Vyhledej$(x)$\newline 
$t:=$}kořen stromu\newline 
{\bf while} $t$ není list a $\key(t)\ne x$ {\bf do}\newline 
\phantom{---}{\bf if} $\key(t)>x$ {\bf then} $t:=\levy(t)$ {\bf else} $t:=\pravy(t)$ {\bf endif\newline 
enddo

MEMBER$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ není list {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif

INSERT$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ je list {\bf then}\newline 
$t$ se změní na vnitřní vrchol, $\key(t):=x$,\newline 
$\levy(t)$ a $\pravy(t)$ jsou nové listy, jejichž otcem je $t$\newline 
{\bf endif

DELETE$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ není list {\bf then}\newline 
\phantom{---}{\bf if} $\levy(t)$ je list {\bf then\newline}
\phantom{------}odstraníme vrchol $\levy(t)$, $\otec(\pravy(t)):=\otec(t)$\newline 
\phantom{------}{\bf if} $t=\levy(\otec(t))$ {\bf then}\newline
\phantom{---------}$\levy(\otec(t)):=\pravy(t)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(t)):=\pravy(t)$\newline 
\phantom{------}{\bf endif\newline}
\phantom{------}odstraníme vrchol $t$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\levy(t)$\newline 
\phantom{------}{\bf while} $\pravy(u)$ není list {\bf do}\newline \phantom{---------}$u:=\pravy(u)$\newline 
\phantom{------}{\bf enddo}\newline 
\phantom{------}$\key(t):=\key(u)$, odstraníme vrchol $\pravy(u)$,\newline 
\phantom{------}$\otec(\levy(u)):=\otec(u)$\newline 
\phantom{------}{\bf if} $u=\levy(\otec(u))$ {\bf then}\newline 
\phantom{---------}$\levy(\otec(u)):=\levy(u)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(u)):=\levy(u)$\newline 
\phantom{------}{\bf endif\newline}
\phantom{------}odstraníme vrchol $u$\newline 
\phantom{---}{\bf endif\newline 
endif}

{\bf MIN\newline 
$t:=$}kořen stromu\newline 
{\bf while} levý syn $t$ není list {\bf do} $t:=\levy(t)$ {\bf enddo\newline 
Výstup}: prvek reprezentovaný $t$ je nejmenší prvek v $
S$

{\bf MAX\newline 
$t:=$}kořen stromu\newline 
{\bf while} pravý syn $t$ není list {\bf do} $t:=\pravy(t)$ {\bf enddo\newline 
Výstup}: prvek reprezentovaný $t$ je největší prvek v $
S$

{\bf SPLIT$(x)$}:\newline 
$T_1$ a $T_2$ jsou prázdné stromy\newline 
$u_1:=u_2:=NIL$\newline 
$t:=\text{\rm kořen stromu }T$\newline 
{\bf while} $t$ není list a $\key(t)\ne x$ {\bf do\newline}
\phantom{---}{\bf if} $\key(t)>x$ {\bf then\newline 
\phantom{------}$u:=\levy(t)$}, $\levy(t):=NIL$, $\otec(u):=NIL$\newline 
\phantom{------}{\bf if} $T_2$ je prázdný strom {\bf then}\newline \phantom{---------}$T_2:=\text{\rm podstrom vrcholu }t$\newline
\phantom{------}{\bf else}\newline 
\phantom{---------}$\levy(u_2):=t$, $\otec(t):=u_2$\newline 
\phantom{------}{\bf endif}\newline
\phantom{------}$u_2:=t$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\pravy(t)$, $\pravy(t):=NIL$, $\otec(u):=NIL$\newline
\phantom{------}{\bf if} $T_1$ je prázdný strom {\bf then}\newline \phantom{---------}$T_1:=\text{\rm podstrom vrcholu }t$\newline
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(u_1):=t$, $\otec(t):=u_1$\newline 
\phantom{------}{\bf endif}\newline
\phantom{------}$u_1:=t$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$t:=u$\newline 
{\bf enddo\newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}$\otec(\levy(t)):=u_1$, $\pravy(u_1):=\levy(t)$\newline 
\phantom{---}$\otec(\pravy(t)):=u_2$, $\levy(u_2):=\pravy(t)$\newline 
\phantom{---}$\otec(u_1):=NIL$, $\otec(u_2):=NIL$, {\bf Výstup}: $x\in S$\newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x\notin S$\newline 
{\bf endif\newline }
Komentář: $T_1$ je binární vyhledávací strom reprezentující 
mno\-ži\-nu 
$\{s\in S\mid s<x\}$ a $T_2$ je binární vyhledávací strom 
reprezentující množinu $\{s\in S\mid s>x\}$.

{\bf JOIN3$(T_1,x,T_2)$} -- předpokládáme, že když $
T_i$ reprezentuje 
množinu $S_i$ pro $i=1,2$, pak $\max S_1<x<\min S_2$\newline 
vytvořme nový vrchol $u$, $\key(u)=x$, $\otec(u):=NIL$, \newline 
$\otec(\text{kořene }T_1):=u$, $\otec(\text{kořene }T_2):=u$, \newline 
$\levy(u):=$kořen $T_1$, $\pravy(u):=$kořen $T_2$.

Abych dokázali korektnost algoritmu {\bf Vyhledej} -- 
jedná se o modifikaci vyhledávání v uspořádaném poli --
popíšeme po\-drobněji vlastnosti binárního vyhledávacího 
stromu. Nej\-prve rozšíříme universum o dva nové prvky, o nový 
nejmenší prvek $-\infty$ a o nový největší prvek $+\infty$. 
Mějme binární vyhledávací strom $T$ reprezentující 
množinu $S$, pak pro vrchol $t$ stromu $T$ definujeme indukcí hodnoty $\lambda(t)$ 
a $\pi(t)$. Když $r$ je kořen, pak $\lambda(r)=-\infty$ a $\pi(r)=+\infty$. 
Když hodnoty $\lambda(t)$ a $\pi(t)$ jsou pro vrchol $t$ definovány, pak pro levého syna $u$ vrcholu $t$ definujeme $\lambda(u)=\lambda(t)$ a $\pi(u)=\key(y)$
a pro pravého syna $w$ vrcholu $t$ definujeme $\lambda(w)=\key(t)$ a $\pi(w)=\pi(t)$.
Nyní dokážeme

\begin{lemma}Je-li $T'$ podstrom binárního vyhledávacího 
stromu $T$ určený vrcholem $t$, pak $T'$ reprezentuje množinu 
$S\cap (\lambda (t),\pi (t))$. Navíc interval $(\lambda (t),\pi 
(t))$ je největší interval, 
který obsahuje jenom prvky z $S$, které jsou reprezentovány 
vrcholy podstromu $T'$. Navíc, když $t$ je list, pak $<\lambda(t),\pi(t)>$ je interval repreyentovaný listem $t$.
\end{lemma}

\begin{proof}Tvrzení dokážeme indukcí.  Zřejmě platí, 
když $t$ je kořen stromu $T$.  Předpokládej\-me, že platí pro vrchol 
$t$ a doká\-že\-me ho pro syny vrcholu $t$.  Označme $t_l$ levého syna 
vrcholu $t$, $t_p$ pravého syna vrcholu $t$.  Z definice binárního 
vyhledávacího stromu stromu plyne, že když $u$ je vnitřní 
vrchol v podstromu $T$ určeném vrcholem $t_l$ a když $v$ je vnitřní 
vrchol v podstromu $T$ určeném vrcholem $t_p$, pak 
$\key(u)<\key(t)<\key(v)$.  Nyní platnost tvrzení pro $t$ 
implikuje platnost tvrzení i pro vrcholy $t_l$ a $t_p$. 
\end{proof}

Korektnost podprocedury {\bf Vyhledej} plyne z 
následujícího invariantu:
\begin{itemize}
\item
Když při vyhledávání $x$ vyšetřujeme vrchol $
t$, pak 
$$\lambda (t)<x<\pi (t).$$
\end{itemize}
Toto tvrzení se lehce dokáže indukcí z popisu algoritmu 
{\bf Vy\-hledej}.  Tedy operace {\bf Vy\-hledej} je korektní a korekt\-nost 
ope\-rací {\bf MEMBER} a {\bf INSERT} je teď zřejmá. V operaci {\bf DELE\-TE},  
když $\levy(t)$ je list, pak korektnost je zřejmá. Když $\levy
(t)$ 
není list, pak algoritmus nalezne list $v$ takový, že $\pi(v)=x$. 
Pak pro $u=\otec(v)$ platí $v=\pravy(u)$ a $\lambda(v)=\key(u)$ a 
$(\lambda(v),\pi(v))\cap S=\emptyset$. Když $y=\key(u)$, pak 
odstranění vrcholů $u$ a $v$ dává binární vyhledávací strom reprezentující $S\setminus \{y\}$. 
Protože $(y,x)\cap S=\emptyset$, tak příkaz $\key(t):=y$ dává binární 
vyhledávací strom reprezentující $S\setminus \{x\}$ a proto operace 
{\bf DELETE} je korektní. 

Korektnost operací {\bf MIN}, {\bf MAX} a {\bf JOIN3} plyne z definice 
binárního vyhledavacího stromu.  Korektnost operace {\bf SPLIT }
plyne z korektnosti algoritmu {\bf Vyhledej} a z faktu, že $u_
1$ je otec 
nej\-pravějšího listu stromu $T_1$ a $u_2$ je otec nejlevějšího listu stromu $T_2$.  
Protože ke stromu $T_1$ se přidává část stromu $T$ reprezentující 
prvky, které jsou větší než prvky reprezentované v $
T_1$, a ke 
stromu $T_2$ se přidává část stromu $T$ reprezentující prvky, 
které jsou menší než prvky reprezentované v $T_2$, korektnost 
algoritmu pro operaci {\bf SPLIT} je jasná.  

Zpracování jednoho vrcholu vyžaduje čas $O(
1)$ a 
algoritmus se pohybuje po jedné cestě z kořene do 
nějakého listu. Označme $\hloubka(T)$ délku nejdelší cesty 
z kořene do nějakého listu. Pak dostáváme

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, {\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, 
{\bf JOIN3} a {\bf SPLIT} v binár\-ním vy\-hledá\-va\-cím stro\-mě $
T$ vyžadují 
čas $O(\hloubka(T))$. 
\end{veta}

Bohužel ani struktura binárních vyhledávacích 
stromů nepodporuje efektivní implementaci operace 
{\bf ord$(k)$}. Pro její efektivní implentaci je vhodné rozšířit 
datovou strukturu tak, že u každého vrcholu $t$ je deklarován 
také údaj $p(t)$ -- počet listů v podstromu určeném 
vrcholem $t$. Po provedení operací {\bf INSERT}, {\bf DELETE}, {\bf JOIN3} a 
{\bf SPLIT} je pak nutné aktualizovat tuto položku na cestě z 
vrcholu do kořene. Následující algoritmus pak 
realizuje operaci {\bf ord}$(k)$.

{\bf ord$(k)$ \newline 
$t:=$}kořen stromu \newline 
{\bf if} $k\ge p(t)$ {\bf then} $k$-tý prvek neexistuje, {\bf stop endif\newline 
while} true {\bf do}\newline 
\phantom{---}{\bf if} $k>p(\levy(t))$ {\bf then}\newline 
\phantom{------}$k:=k-p(\levy(t))$, $t:=\pravy(t)$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $k<p(\levy(t)$ {\bf then}\newline 
\phantom{---------}$t:=\levy(t)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\key(t)$ je $k$-tý prvek reprezentované množiny, stop \newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
enddo}

Korektnost algoritmu plyne z následujícího invariantu:  
Když algoritmus má v daném okamžiku v proměnné $t$ vrchol $
v$ 
a hodnota proměnné $k$ je $k'$, pak $k$-tý prvek v $S$ se rovná 
$k'$-tému prvku v intervalu reprezentovaném v podstromu 
stromu $T$ určeném vrcholem $v$.  Protože na počátku algoritmu 
je $v$ kořen stromu a interval je $S$ (a $k'=k$), tak na počátku 
běhu algoritmu invariant platí.  Předpokládejme, že platí v 
některém kroku.  Nechť $u$ je levý syn $v$, $w$ je pravý syn $
v$ a 
$I_a$ je interval reprezovaný podstromem $T$ určeným vrcholem $
a$.  
Pak $|I_u|=p(u)-1$, $\max I_u<\key(v)<\min I_w$ a 
$I_v=I_u\cup \{\key(v)\}\cup I_w$.  Odtud plyne, že když $k'
<p(u)$, pak 
$k'$-tý prvek v intervalu $I_v$ je $k'$-tý prvek v intervalu $
I_u$, když 
$k'>p(u)$, pak $k'$-tý prvek v intervalu $I_v$ je $(k'-p(u))$-tý prvek 
v intervalu $I_w$, a když $k'=p(u)$, pak $k'$-tý prvek v intervalu $
I_v$ 
je $\key(v)$.  Odtud plyne invariant a korektnost algoritmu.  
Podle stejných argumentů jako v předchozím případě 
dostaneme, že časová složitost algoritmu je $O(\hloubka
(T))$.  
Tedy můžeme tato fakta shrnout.  

\begin{veta}Algoritmy pro operace {\bf MEMBER}, {\bf INSERT}, {\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, 
{\bf JOIN3}, {\bf SPLIT} a $\bold o\bold r\bold d(k)$ pro všechna $
k$ v rozšířených binár\-ních 
vy\-hledávacích stromech vyžadují čas $O(\hloubka
(T))$, kde $T$ je 
reprezentující strom. 
\end{veta}

Tento výsledek motivuje používání binárních 
vyhledávacích stromů, které splňují další 
podmínku, která má zajistit, že 
$\hloubka(T)=O(\log|S|)$.  V takovémto případě mluvíme o 
\emph{vyvážených} \emph{binárních} 
\emph{vyhledávacích} \emph{stromech}.  Je však nutné 
přidat k ope\-racím {\bf INSERT}, {\bf DELETE}, {\bf JOIN3} a {\bf SPLIT} další 
kroky, které 
zaručí, že po jejich provedení strom opět splňuje 
požadované podmínky.  To vede k požadavku, aby 
vyvažovací operace byly rychlé a provádělo se jich málo.  

Při náhodné posloupnosti operací {\bf INSERT} a {\bf DELETE} je 
velká pravděpodobnost, že dostaneme náhodný binární 
vy\-hledávací strom.  Je známo, že očekávaná hodnota proměn\-né 
$\hloubka(T)$ je $O(\log|S|)$.  Protože se nepoužívají vyvažovací 
operace, můžeme dostat lepší výsledek (časově) než pro 
vyvá\-žené binár\-ní vyhledávací stromy.  Tento problém se teď 
intenzivně studu\-je.  Velká pozornost je věnována 
pravděpodobnost\-ním modifikacím binárních vyhledávacích 
stromů.  Hledají se však i další možnosti.  

Studují se tzv.  samoupravující struktury.  Zde se 
pracuje s datovou strukturou bez dodatečných informací, ale 
operace nad touto strukturou provádí vyvažování v závislosti 
na argumentu operace.  Dokázalo se, že existuje strategie 
vyvažování, která zajišťuje dobré chování bez ohledu na 
vstupní data.  Další strategie je, že se jen zjišťuje, zda datová 
struktura nemá výraz\-ně špatné chování, a pokud ho má nebo 
po dlouhé řadě úspěš\-ných aktualizačních operací se vybuduje 
nová datová struktura (s optimálním chováním).  Třetí, 
poměrně stará, strategie je zalo\-že\-na na předpokladu, že 
známe rozdělení vstupních dat.  Zde se datová struktura 
předem upravuje pro toto rozdělení.  Ukazuje se, že tyto 
strategie mají úspěch.  Další podrobnosti v letním semestru.  

Nyní si ukážme dvě operace se stromy, na nichž jsou 
založeny  vyvažovací operace pro binární vyhledávací 
stromy. Obě ope\-race vyžadují čas $O(1)$.

Mějme vrchol $v$ binárního vyhledávacího stromu $
T$ a 
jeho syna $u$, který je vnitřní vrchol.  Pak {\bf Rotace$
(v,u)$} je 
znázorněna na obrázku a provádí ji následující algoritmus.  

\begin{figure}[h!]
  \centerline{
    \input fig1.tex
    }
  \caption{Rotace $(v,u)$}
\end{figure}

{\bf Rotace$(v,u)$\newline} 
$\otec(u):=\otec(v)$,\newline 
{\bf if} $v=\levy(\otec(v))$ {\bf then}\newline 
\phantom{---}$\levy(\otec(v)):=u$\newline 
{\bf else}\newline 
\phantom{---}$\pravy(\otec(v)):=u$\newline 
{\bf endif\newline 
$\otec(v):=u$\newline 
if} $u=\levy(v)$ {\bf then}\newline 
\phantom{---}$\otec(\pravy(u)):=v$, $\levy(v):=\pravy(u)$, $\pravy(u):=v$\newline 
{\bf else}\newline 
\phantom{---}$\otec(\levy(u)):=v$, $\pravy(v):=\levy(u)$, $\levy(u):=v$\newline 
{\bf endif}

Všimněme si, že při {\bf Rotace} můžeme 
aktualizovat i funkci $p$. Pro vrchol $w\ne u,v$ se její hodnota 
nemění, nová hodnota $p(u)$ je rovná původní hodnotě 
$p(v)$ a novou hodnotu $p(v)$ dostaneme jako 
$p(\levy(v))+p(\pravy(v))$.

Mějme vrchol $w$ stromu $T$, jeho syna $v$ a jeho 
syna $u$ takového, že $u$ není list a $v$ je pravý syn 
vrcholu $w$, právě když $u$ je levý syn vrcholu $v$. Pak 
{\bf Dvojita}-{\bf rotace$(w,v,u)$} je znázorněna na obrázku a provádí 
ji následující algoritmus.

\begin{figure}[h!]
  \centerline{
    \input fig2.tex
    }
  \caption{Dvojita-rotace$(w,v,u)$}
\end{figure}

{\bf Dvojita}-{\bf rotace$(w,v,u)$\newline 
$\otec(u):=\otec(w)$\newline 
if} $w=\levy(\otec(w))$ {\bf then}\newline 
\phantom{---}$\levy(\otec(w)):=u$\newline 
{\bf else}\newline 
\phantom{---}$\pravy(\otec(w)):=u$\newline 
{\bf endif}\newline 
$\otec(v):=u$, $\otec(w):=u$\newline 
{\bf if} $v=\levy(w)$ {\bf then}\newline  
\phantom{---}$\levy(w):=\pravy(u)$, $\otec(\pravy(u)):=w$, $\pravy(v):=\levy(u)$\newline \phantom{---}$\otec(\levy(u)):=v$, $\levy(u):=v$, $\pravy(u):=w$\newline 
{\bf else}\newline 
\phantom{---}$\pravy(w):=\levy(u)$, $\otec(\levy(u)):=w$, $\levy(v):=\pravy(u)$\newline 
\phantom{---}$\otec(\pravy(u)):=v$, $\levy(u):=w$, $\pravy(u):=v$\newline 
{\bf endif}

Také zde můžeme v čase $O(1)$ spočítat nové hodnoty $
p$. 
Pro vrchol $x\ne u,v,w$ se hodnota nemění, nová hodnota 
$p(u)$ je 
rovná původní hodnotě $p(w)$ a nové hodnoty $
p(v)$ 
a $p(w)$ 
získáme pod\-le stejného vzorce  jako v {\bf Rotace}.

\section{AVL-stromy}

Binární vyhledávací strom je 
\emph{AVL}-\emph{strom}, když pro každý vnitř\-ní vrchol 
$v$ se délka nejdelší cesty z jeho levého syna do 
listu a délka nejdelší cesty z jeho pravého syna do listu 
liší nejvýše o $1$.  

Pro vnitřní vrchol $v$ stromu $T$ označme $\eta 
(v)$ 
délku nejdelší cesty z vrcholu $v$ do listu.

 

Struktura vnitřních vrcholů v 
AVL-stromech je rozšířena o hodnotu $\omega$:\newline 
$\omega (v)=-1$, když 
$$\eta (\text{\rm levý syn vrcholu }v)=\eta (\text{\rm pravý syn vrcholu }
v)+1;$$
$\omega (v)=0$, když 
$$\eta (\text{\rm levý syn vrcholu }v)=\eta (\text{\rm pravý syn vrcholu }
v);$$
$\omega (v)=+1$, když
$$\eta (\text{\rm levý syn vrcholu }v)+1=\eta (\text{\rm pravý syn vrcholu }
v).$$

Všimněme si, že hodnota $\eta (v)$ pro vnitřní vrcholy 
$v$ stromu $T$ není nikde uložena.  Hodnoty $\eta$ jsme schopni 
spočítat z hodnot $\omega$, ale není to třeba.  Stačí, když po 
aktualizačních operacích budeme umět aktualizovat 
hodnoty $\omega$ a upravit binární vy\-hledávací strom tak, 
aby byl opět AVL-strom.

Odhad velikosti $\eta (\text{\rm kořen }T)$ v závislosti na 
velikosti reprezentované množiny $S$.\newline 
Když $T$ je AVL-strom a $v$ je vnitřní vrchol $T$, pak 
podstrom $T$ určený vrcholem $v$ je opět AVL-strom. 
Označme\newline 
$mn(i)$ velikost nejmenší množiny reprezentované 
AVL-stromem $T$ takovým, že $$\eta (\text{\rm kořen }T)=i,$$ 
$mx(i)$ velikost největší množiny reprezentované 
AVL-stromem $T$ takovým, že $$\eta (\text{\rm kořen }T)=i.$$ 
Z definice AVL-stromu plynou rekurze
\begin{gather*} mn(i)=mn(i-1)+mn(i-2)+1,\,mx(i)=2mx(i-1)+1,\\
\text{a }mn(1)=mx(1)=1,\quad mn(2)=2,\quad mx(2)=3.\end{gather*}
Nejprve spočítáme $mx$.

Dokážeme, že $mx(i)=2^i-1$. Tento vzorec je 
splněn pro $i=1,2$. Dále 
$$mx(i+1)=2mx(i)+1=2(2^i-1)+1=2^{i+1}-1.$$
Tím je vzorec dokázán. 

Abychom spočítali $mn$, připomeneme si definici Fibonacciho čísel. \emph{Fibonacciho} 
\emph{číslo} $F_i$ je definováno rekurencí
$$F_1=F_2=1\text{\rm\ a }F_{i+2}=F_i+F_{i+1}\text{\rm\ pro všechna }
i\ge 3.$$
Pak platí vzorec $F_i=\frac {\big(\frac {1+\sqrt 5}2\big)^i-\big
(\frac {1-\sqrt 5}2\big)^i}{\sqrt 5}$ pro všechna $i\ge 1$ 
(dokážeme si ho v části o haldách). 

Protože 
$-1<\frac {1-\sqrt 5}2<0$ a $\frac {1+\sqrt 5}2>1$, dostáváme, že 
$$\lim_{n\mapsto\infty}F_n\sqrt 5(\frac {1+\sqrt 5}2)^{-n}=1.$$
Proto existují konstanty $0<c_1<c_2$ takové, že 
$$c_1(\frac {1+\sqrt 5}2)^i<\sqrt 5F_i<c_2(\frac {1+\sqrt 5}2)^i.$$

Dokážeme, že $mn(i)=F_{i+2}-1$. Protože $F_3
=2$ a 
$F_4=3$, 
tvrzení platí pro $i=1$ a $i=2$. Dále 
\begin{align*} mn(i+2)=&mn(i+1)+mn(i)+1=\\&F_{i+3}-1+F_{i+2}-1+1=F_{i+4}-1.\end{align*}
Z toho indukcí plyne požadovaný vztah. 

Když AVL-strom $T$ o výšce $i$ reprezentuje množinu $
S$ o 
velikosti $n$, pak platí 
$$\frac {c_1}{\sqrt 5}(\frac {1+\sqrt 5}2)^{i+2}-1<F_{i+2}-1\le n
\le 2^i-1.$$
Po zlogaritmování z toho okamžitě dostáváme
$$\log(\frac {c_1}{\sqrt 5})+(i+2)\log(\frac {1+\sqrt 5}2)<\log(n
+1)<i.$$
Protože $\log(\frac {1+\sqrt 5}2)\approx 0.69\approx\frac 1{1.
44}$ dostáváme, že pro dostatečně velká $n$ 
platí, že $0.69i<\log(n+1)\le i$. Odtud plyne, že 
$\log(n+1)\le i\le 1.44\log(n)$, a tedy $i=\Theta (\log(n))$.

Operace {\bf MEMBER$(x)$} pro AVL-stromy je stejná jako 
ope\-race {\bf MEMBER$(x)$} pro nevy\-vá\-žené binární vyhledávací 
stro\-my. Aktualizační operace pro AVL-stromy nejprve provedou 
příslušnou ope\-raci pro nevyvážené binární vyhledávací stromy 
a pak násle\-du\-je jejich vyvažovací část. Při úspěšně 
provedené operaci {\bf IN\-SERT$(x)$} v nevyvážených binárních 
stromech změníme vhod\-ný list $t$ na vnitřní vrchol 
stromu reprezentující $x$ a přidáme k $t$ dva syny, kteří 
budou listy. Důsledkem je, že definujeme 
$\omega (t)=0$. Protože se však zvětšila hodnota $\eta 
(t)$ (bylo 
$\eta (t)=0$ a teď je $\eta (t)=1$), zavoláme proceduru 
{\bf Kontrola-INSERT$(t)$}, která zajistí správnou hodnotu 
funkce $\omega$ pro otce $t$. Navíc, když zjistí, že se zvětšila 
hodnota $\eta$ vrcholu otce $t$, pak zavolá sama sebe na vrchol 
otec $t$. Nejprve provedeme analýzu situace. 

Mějme vrchol $t$, jeho $\eta (t)=a$ (ale $a$ neznáme), na 
začátku 
ope\-ra\-ce {\bf INSERT} bylo $\eta (t)=a-1$.  V podstromu určeném 
vrcholem $t$ máme už správné hodnoty $\omega$.  Vrchol $
v$ je otcem $t$, 
$t=\levy(v)$ a $\omega (v)$ má ještě původní hodnotu.  

\begin{lemma}Když se hodnota $\eta (t)$ při operaci {\bf INSERT }
zvětšila a $t$ nebyl listem před operaci, pak po operaci 
neplatí $\omega (t)=0$.
\end{lemma}

Označme $u=\pravy(v)$ a uvažme případy:\newline 
A) $\omega (v)=1$, pak $\eta (u)=a$ a $\eta (v)=a+1$ se nezměnilo, 
tedy stačí položit $\omega (v)=0$.\newline 
B) $\omega (v)=0$, pak $\eta (u)=a-1$ a $\eta (v)=a+1$ se změnilo, 
tedy musíme položit $\omega (v)=-1$ a zavolat proceduru 
{\bf Kontrola-INSERT} na vrchol $v$.\newline 
C) $\omega (v)=-1$, pak $\eta (u)=a-2$ a $\eta (v)=a+1$ se změnilo. 
Nyní $\omega (v)=-2$ a to je zakázané. Označme $t_1=\levy
(t)$, 
$t_2=\pravy(t)$ ($\omega (t)=0$ nenastane, viz Lemma). 
\newline 
C1) $\omega (t)=-1$, pak $\eta (t_1)=a-1$, $\eta (t_2)=a-2$ a provedeme 
{\bf Rotace$(v,t)$}. Pak $t_2$ je druhý syn $v$ a stačí položit 
$\omega (v)=\omega (t)=0$.\newline 
C2) $\omega (t)=1$, pak $\eta (t_1)=a-2$, $\eta (t_2)=a-1$ a provedeme 
{\bf Dvojita-rotace$(v,t,t_2)$}. Pro $t_3=\levy(t_2)$ a $t_4=\pravy
(t_2)$ 
platí:\newline 
C2i) $\omega (t_2)=1\implies\eta (t_3)=a-3$ a $\eta (t_4)=a-2$ a stačí 
položit $\omega (t)=-1$, $\omega (v)=\omega (t_2)=0$, protože $
\eta (t_2)=a$.\newline 
C2ii) $\omega (t_2)=0\implies\eta (t_3)=\eta (t_4)=a-2$ a stačí položit 
$\omega (t_2)=\omega (v)=\omega (t)=0$, protože $\eta (t_2)=a$. \newline 
C2iii) $\omega (t_2)=-1\implies\eta (t_3)=a-2$ a $\eta (t_4)=a-3$ a 
stačí položit $\omega (v)=1$, $\omega (t_2)=\omega (t)=
0$, protože $\eta (t_2)=a$.\newline 
Když $t$ je pravý syn $v$, pak situace je symetrická.\newline 
Popíšeme proceduru {\bf Kontrola-INSERT}.

{\bf Kontrola-INSERT$(t)$\newline 
$v:=\otec(t)$\newline 
if} $t=\levy(v)$ {\bf then}\newline 
\phantom{---}{\bf if} $\omega (v)=1$ {\bf then}\newline 
\phantom{------}$\omega (v):=0$ \newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{---------}$\omega (v):=-1$, $t:=v$, {\bf Kontrola-INSERT}$(t)$\newline 
\phantom{------}{\bf else}\newline
\phantom{---------}{\bf if} $\omega (t)=-1$ {\bf then}\newline 
\phantom{------------}{\bf Rotace$(v,t)$}, $\omega (v):=0$, $\omega (t):=0$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$w:=\pravy(t)$, {\bf Dvojita-rotace$(v,t,w)$},\newline 
\phantom{------------}{\bf if} $\omega (w)=0$ {\bf then}\newline 
\phantom{---------------}$\omega (t):=0$, $\omega (v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------------}$\omega (v):=0$, $\omega (t):=-1$\newline 
\phantom{---------------}{\bf else}\newline 
\phantom{------------------}$\omega (v):=1$, $\omega (t):=0$\newline 
\phantom{---------------}{\bf endif}\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{------------}$\omega (w):=0$\newline 
\phantom{---------}{\bf endif}\newline
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf if} $\omega (v)=-1$ {\bf then}\newline 
\phantom{------}$\omega (v):=0$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{---------}$\omega (v):=1$, $t:=v$, {\bf Kontrola-INSERT}$(t)$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}{\bf if} $\omega (t)=1$ {\bf then}\newline 
\phantom{------------}{\bf Rotace$(v,t)$}, $\omega (v):=0$, $\omega (t):=0$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$w:=\levy(t)$, {\bf Dvojita-rotace$(v,t,w)$},\newline 
\phantom{------------}{\bf if} $\omega (w)=0$ {\bf then}\newline 
\phantom{---------------}$\omega (t):=0$, $\omega (v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------------}$\omega (v):=0$, $\omega(t):=-1$\newline 
\phantom{---------------}{\bf else}\newline 
\phantom{------------------}$\omega (v):=1$, $\omega (t):=0$\newline 
\phantom{---------------}{\bf endif}\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{------------}$\omega (w):=0$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}

Všimněme si, že po provedení {\bf Rotace} nebo
{\bf Dvojita-rotace} vyvažování v operaci {\bf INSERT} končí. Tedy 
operace {\bf INSERT} provádí nejvýše jednu proceduru {\bf Rotace }
nebo {\bf Dvojita-rota\-ce}. Korektnost vyvažovací operace je 
založena na faktu, že když se zvětší hodnota $
\eta (t)$, pak 
nemůže být $\omega (t)=0$. Tento fakt se využívá  v 
{\bf if}-příkazu na 5-tém a 6-tém řádku a na 13-tém a 14-tém  
řádku programu.

Popíšeme vyvažovací operaci pro operaci 
{\bf DELETE}.  Před\-po\-kládejme, že $t$ je vrchol, jehož otec se 
odstranil (tj.  bratr $t$ byl list) a hodnota $\eta (t)$ je menší 
než byla hodnota $\eta (\otec(t))$.  Proto zavoláme proceduru 
{\bf Kontrola-DELETE$(t)$}.  Tato procedura zajistí správnou 
hodnotu funkce $\omega$ pro otce $t$.  Navíc, když zjistí, že se 
zmenšila hodnota $\eta$ vrcholu otce $t$, pak zavolá sama sebe 
na vrchol otec $t$. Popíšeme analýzu situace, na níž je 
založena korektnost procedury {\bf Kontrola-DELETE$(t)$}.  

V analýze je důležité, že když procedura {\bf Kontrola-DELETE }
přesune vrchol $x$ na místo vrcholu $y$, pak skutečná hodnota $
\eta (x)$ 
je buď původní hodnota $\eta (y)$ nebo je přesně o $
1$ menší. Všimněte si, že to platí. 

Dán vrchol $t$, jehož hodnota $\eta (t)$ se zmenšila (o $
1$).  V 
podstromu určeném vrcholem $t$ jsou hodnoty $\omega$ aktualizovány, 
$v=\otec(t)$ a $\omega (v)$ je původní.  Předpokládejme 
$t=\levy(v)$, $u=\pravy(v)$ a $\eta (t)=a$ ($a$ je neznámé).  Nastávají 
případy:\newline 
A) když $\omega (v)=1$, pak $\eta (u)=a+2$ a $\eta (v)=a+3$ (původně 
bylo $\eta (t)=a+1$).  Označme $u_1=\levy(u)$, $u_2=\pravy(u)$.\newline 
A1) $\omega (u)=1\implies\eta (u_1)=a,\,\eta (u_2)=a+1$.  Provedeme 
{\bf Rotace$(v,u)$}.  
Vrchol $u_1$ je druhým synem $v$ a platí $\eta (t)=\eta (u_
1)=a$, 
$\eta (v)=\eta (u_2)=a+1$ a $\eta (u)=a+2$.  Tedy položme $\omega 
(v)=\omega (u)=0$ a 
zavolejme {\bf Kontrola-DELETE} na vrchol $u$.\newline 
A2) $\omega (u)=0\implies\eta (u_1)=\eta (u_2)=a+1$. Provedeme 
{\bf Rotace$(v,u)$}. Vrchol $u_1$ je druhým synem $v$ a platí 
$\eta (t)=a$, $\eta (u_1)=a+1=\eta (u_2)$, $\eta (v)=a+2$, $\eta 
(u)=a+3$. Položme 
$\omega (v)=1$, $\omega (u)=-1$ a končíme.

 

A3) $\omega (u)=-1\implies\eta (u_1)=a+1,\,\eta (u_2)=a$.  Provedeme 
{\bf Dvojita-rotace$(v,u,u_1)$}.  Pro $u_3=\levy(u_1)$, 
$u_4=\pravy(u_1)$ nastanou případy:\newline 
A3i) $\omega (u_1)=-1\implies\eta (u_3)=a,\,\eta (u_4)=a-1$ a tedy 
$\eta (v)=\eta (u)=a+1$ a $\eta (u_1)=a+2$. Proto položíme 
$\omega (v)=\omega (u_1)=0$, $\omega (u)=1$ a zavoláme proceduru {\bf Kontrola-DELETE }
na vrchol $u_1$.\newline 
A3ii) $\omega (u_1)=0\implies\eta (u_3)=\eta (u_4)=a$ a tedy 
$\eta (v)=\eta (u)=a+1$ a $\eta (u_1)=a+2$. Proto položíme 
$\omega (v)=\omega (u_1)=\omega (u)=0$ a zavoláme proceduru {\bf Kontrola-DELETE }
na vrchol $u_1$.\newline 
A3iii) $\omega (u_1)=1\implies\eta (u_3)=a-1,\,\eta (u_4)=a$ a tedy 
$\eta (v)=\eta (u)=a+1$ a $\eta (u_1)=a+2$. Proto položíme 
$\omega (u)=\omega (u_1)=0$, $\omega (v)=-1$ a zavoláme proceduru {\bf Kontrola-DELETE }
na vrchol $u_1$.\newline 
B) když $\omega (v)=0$, pak $\eta (u)=a+1$ a $\eta (v)=a+2$. 
Stačí položit $\omega (v)=1$ a skončit.\newline 
C) když $\omega (v)=-1$, pak $\eta (u)=a$ a $\eta (v)=a+2$. 
Nyní položíme $\omega (v)=0$ a 
zavoláme proceduru {\bf Kontrola-DELETE} na vrchol $v$.

{\bf Kontrola-DELETE$(t)$\newline 
$v:=\otec(t)$\newline 
if} $t=\levy(v)$ {\bf then}\newline 
\phantom{---}{\bf if} $\omega (v)=1$ {\bf then}\newline 
\phantom{------}$u:=\pravy(v)$\newline 
\phantom{------}{\bf if} $\omega (u)\ge 0$ {\bf then}\newline 
\phantom{---------}{\bf Rotace$(v,u)$}\newline 
\phantom{---------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{------------}$\omega (v):=1$, $\omega (u):=-1$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$\omega (u):=\omega (v):=0$, $t:=u$, {\bf Kontrola-DELETE}$(t)$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$w:=\levy(u)$, {\bf Dvojita-rotace}$(v,u,w)$\newline 
\phantom{---------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------}$\omega (u):=0$, $\omega (v):=-1$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}{\bf if} $\omega (w):=0$ {\bf then}\newline 
\phantom{---------------}$\omega (u):=0$, $\omega(v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}$\omega (u):=1$, $\omega (v):=0$\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{---------}$\omega (w):=0$, $t:=w$, {\bf Kontrola-Delete}$(t)$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{------}$\omega (v):=1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$\omega (v):=0$, $t:=v$, {\bf Kontrola-DELETE}$(t)$\newline \phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf if} $\omega (v)=-1$ {\bf then}\newline 
\phantom{------}$u:=\levy(v)$\newline 
\phantom{------}{\bf if} $\omega (u)\le 0$ {\bf then}\newline 
\phantom{---------}{\bf Rotace}$(v,u)$\newline 
\phantom{---------}{\bf if} $\omega (u)=0$ {\bf then}\newline 
\phantom{------------}$\omega (v):=-1$, $\omega (u):=1$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}$\omega (u):=\omega (v):=0$, $t:=u$, {\bf Kontrola-DELETE}$(t)$\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$w:=\pravy(u)$, {\bf Dvojita-rotace$(v,u,w)$}\newline 
\phantom{---------}{\bf if} $\omega (w)=1$ {\bf then}\newline 
\phantom{------------}$\omega (u):=-1$, $\omega (v):=0$\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}{\bf if} $\omega (w):=0$ {\bf then}\newline 
\phantom{---------------}$\omega (u):=0$, $\omega(v):=0$\newline 
\phantom{------------}{\bf else}\newline 
\phantom{---------------}$\omega (u):=0$, $\omega (v):=1$\newline 
\phantom{------------}{\bf endif}\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{---------}$\omega (w):=0$, $t:=w$, {\bf Kontrola-Delete}$(t)$\newline
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $\omega (v)=0$ {\bf then}\newline 
\phantom{---------}$\omega (v):=-1$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\omega (v):=0$, $t:=v$, {\bf Kontrola-DELETE}$(t)$\newline \phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}

V operaci {\bf DELETE} se může stát, že procedury 
{\bf Rotace} nebo {\bf Dvojita-rotace} jsou volány až $\log(
|S|)$-krát. 
To je výrazný rozdíl proti operaci {\bf INSERT}. Proto operace 
{\bf DELETE} je pomalejší než operace {\bf INSERT}, i když 
asymptoticky jsou stejně rychlé. Korektnost se 
ověří přímo.

\begin{veta}Datová struktura AVL-strom 
umožňuje implementaci operací {\bf MEMBER}, {\bf INSERT} a 
{\bf DELETE}, které vyžadují čas $O(\log(|S|))$ (kde $
S$ je 
reprezentovaná množina).  Ope\-race {\bf INSERT} zavolá 
nejvýše jednu proceduru {\bf Rotace} nebo {\bf Dvo\-ji\-ta-rotace}.  
\end{veta}

\section{Červeno-černé stromy}

Binární vyhledávací strom $T$ reprezentující 
množinu $S$, jehož vrcholy jsou obarveny červeně nebo 
černě (každý vrchol má právě jednu barvu) tak, že jsou 
splněny podmínky:
\begin{itemize}
\item
listy jsou obarveny černě,
\item
když $v$ je vrchol obarvený červeně, pak je buď kořen 
stromu nebo jeho otec je obarven černě,
\item
všechny cesty z kořene do listů mají stejný 
počet čer\-ných vrcholů
\end{itemize}
se nazývá \emph{červeno}-\emph{černý} \emph{strom}. 

Nejprve ukážeme, že červeno-černé stromy jsou 
vyvážené stro\-my, tj. $$\hloubka(T)=O(\log(|S|).$$
Předpokládejme, že $T$ je červeno-černý strom, který má 
na cestě z kořene do listu právě $k$ černých 
vrcholů. Pak pro počet vrcholů $\#T$ 
stromu $T$ platí 
$$2^k-1\le \#T\le 2^{2k}-1.$$
Nejmenší takový strom má všechny vrcholy černě 
obarvené a je to úplný pravidelný binární strom o 
výšce $k-1$, což dává dolní odhad.  Největší takový 
strom má všechny vrcholy v sudých hladinách obarveny 
červeně a v lichých hladinách černě, je to úplný 
pravidelný binární strom o výšce $2k-1$ a tím je dán 
horní odhad. Tedy $k\le\log(1+\#T)\le 2k$.
Protože velikost $S$ je počet vnitřních vrcholů, 
dostáváme, že $\#T=2|S|+1$. Z vlastností červeno-černých 
stromů plyne, že 
$$k\le\hloubka(T)\le 2k.$$
Tedy

\begin{tvrzeni}Když červeno-černý strom $T$ 
reprezentuje množinu $S$, pak $$\hloubka(T)\le 2\log(2|S|+2)=1+\log(|S|+1).$$
\end{tvrzeni}

Pro červeno-černé stromy navrhneme algoritmy 
realizující ope\-race z uspořádaného slovní\-ko\-vého problému.  
Operace {\bf MEMBER} pro červeno-černé stromy je stejná jako pro 
nevyvážené binární vyhledávací stromy. Operace 
{\bf IN\-SERT} a {\bf DELETE} mají dvě části:  nejprve se provede 
ope\-race {\bf INSERT} nebo {\bf DELETE} pro nevyvážené binární 
vy\-hledávací stromy a pak následují vyvažovací operace, které 
zajistí, že výsledný strom splňuje pod\-mín\-ky pro červeno-černé 
stromy (stejné schéma jako pro AVL-stromy). Schéma operací 
{\bf JOIN} a {\bf SPLIT} bude vycházet z jejich realizací v $
(a,b)$-stromech. 
V operaci {\bf JOIN} prohledáváním nalezneme místo, kde se 
stromy  
dají spojit (a aplikujeme operaci {\bf JOIN} pro 
nevyvážené 
binární vyhledá\-va\-cí stromy), a pak použijeme 
vyvažovací operace. Algoritmus ope\-race {\bf SPLIT} rozdělí červeno-černý strom 
do několika menších podle cesty vyhledávající $
x$ (podobně jako 
v $(a,b)$-stromech) a na tyto stromy pak aplikuje operaci {\bf JOIN }
a zkonstruuje hledané červeno-černé stromy. Algoritmy pro 
ope\-race {\bf MIN} a {\bf MAX} jsou stejné jako pro nevyvážené binární 
vyhledávací stromy.

Nejprve popíšeme vyvažovací operace. 
Dvojice $(T,v)$ se nazývá 2-\emph{parciální}
\emph{červeno}-\emph{černý} \emph{strom}, když $T$ je 
binární vyhledávací strom, každý vrchol je obarven 
červeně nebo černě, $v$ je 
vnitřní vrchol stromu $T$ obarvený červeně a platí:
\begin{itemize}
\item
listy jsou obarveny černě,
\item
když $t$ je vrchol obarvený červeně, pak je buď kořen 
stromu nebo $t=v$ nebo jeho otec je obarven černě,
\item
všechny cesty z kořene do listů mají stejný 
počet čer\-ných vrcholů.
\end{itemize}

Vyvažování 2-parciálního červeno-černého stromu $(T',v)$ 
pro\-vá\-dí procedura {\bf Vyvaz-IN\-SERT$(v)$}.  Po jejím 
provedení buď do\-sta\-neme čer\-ve\-no-černý strom nebo 
je procedura {\bf Vyvaz-IN\-SERT} zavolána na vrchol $
v'$ takový, 
že $(T',v')$ je 2-parciální červe\-no-černý strom a $
v'$ je děd $v$ 
(tj.  je o dvě hladiny blíž ke kořeni než vrchol $
v$). 

Obarvení je realizováno rozšířením struktury vrcholu $v$ 
o boolskou proměnnou $b(v)$, kde $b(v)=0$ znamená, že $v$ je obarven 
červeně, a $b(v)=1$ znamená, že $v$ je obarven černě.

Popíšeme proceduru {\bf Vyvaz-INSERT$(v)$} (předpokládáme, že 
$v$ je obarven červeně). Pro zjednodušení $s(v
)=levy$, když $v=\levy(\otec(v))$, a $s(v)=pravy$ pro  
$v=\pravy(\otec(v))$.

{\bf Vyvaz-INSERT$(v)$}.\newline 
{\bf if} $v$ není kořen $T'$ a $b(\otec(v))=0$ {\bf then}\newline 
\phantom{---}{\bf if} $otec(v)$ je kořen {\bf then}\newline 
\phantom{------}$b(\otec(v)):=1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$w:=\otec(v)$, $u:=\bratr(w)$\newline 
\phantom{------}{\bf if} $b(u)=0$ {\bf then}\newline 
\phantom{---------}$v:=\otec(w)$, $b(w):=1$, $b(u):=1$\newline 
\phantom{---------}$b(v):=0$, {\bf Vyvaz-INSERT$(v)$} (Viz Obrázek \ref{fig3})\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$t:=\otec(w)$\newline 
\phantom{---------}{\bf if} $s(w)=s(v)$ {\bf then}\newline 
\phantom{------------}{\bf Rotace$(t,w)$}, $b(t):=0$, $b(w):=1$ (Viz Obrázek \ref{fig4})\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}{\bf Dvojita-rotace$(t,w,v)$}, $b(t):=0$, $b(v):=1$ (Viz Obrázek \ref{fig5})\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}

Na obrázku $b$ značí černou barvu a $r$ značí červenou 
barvu. Otec vrcholu $w$ je označen $t$. 


\begin{figure}[h!]
  \centerline{
    \input fig3.tex
    }
  \caption{}
  \label{fig3}
\end{figure}

\begin{figure}[h!]
  \centerline{
    \input fig4.tex
    }
  \caption{}
  \label{fig4}
\end{figure}


\begin{figure}[h!]
  \centerline{
    \input fig5.tex
    }
  \caption{}
  \label{fig5}
\end{figure}


$2$-parciální červeno-černé stromy vznikají při 
operacích {\bf INSERT} a {\bf JOIN.}  Při operaci {\bf DELETE} se poruší 
struktura červeno-černých stromů jiným 
způsobem a vznikne 3-parciální červeno-čer\-ný strom.  

Řekneme, že dvojice $(T,v)$ je \emph{3}-\emph{parciální} 
\emph{červeno}-\emph{černý} \emph{strom}, když $T$ je binární 
vy\-hledávací strom, každému vrcholu je při\-řazena právě jedna z 
dvojice barev červená -- černá, $v$ je vrchol ve stromu $
T$ a 
platí následující podmínky: 
\begin{itemize}
\item
listy a vrchol $v$ jsou obarveny černě,
\item
když $t$ je vrchol obarvený červeně, pak je buď kořen 
stromu nebo jeho otec je obarven černě,
\item
existuje číslo $k$ takové, že všechny cesty z kořene do 
listů, které neobsahují vrchol $v$, obsahují právě 
$k$ čer\-ných vrcholů, a všechny cesty z kořene do 
listů prochá\-ze\-jí\-cí vrcholem $v$ obsahují $
k-1$ černých 
vrcholů.
\end{itemize}

Popíšeme proceduru {\bf Vyvaz-DELETE$(v)$}, která se 
použije na 3-parciální červeno-černý strom $(T,v)$, když $
v$ není jeho 
kořen.  Výsledkem procedury bude buď červeno-černý strom 
nebo zavolání procedury {\bf Vyvaz-DELE\-TE$(v')$}, kde $v'$ je otcem 
vrcholu $v$.  Z faktu, že když $(T,v)$ je 3-parciální červeno-černý 
strom a $v$ je jeho kořen, pak $T$ je červeno-černý strom, plyne, 
že aplikací {\bf Vyvaz-DELETE$(v)$} na 3-parciální červeno-černý strom 
$(T,v)$ dostaneme červeno-černý strom.  

{\bf Vyvaz-DELETE$(v)$\newline 
$u:=\bratr(v)$}, $t:=\otec(v)$\newline 
{\bf if} $b(u)=0$ {\bf then}\newline 
\phantom{---}{\bf Rotace}$(t,u)$, $b(u):=1$, $b(t):=0$, $u:=\bratr(v)$\newline 
{\bf endif\newline}
(Viz Obr. 4, Komentář: nyní $b(u)=1$)\newline 
$w_1$ je syn $u$ takový, že $s(v)=s(w_1)$, $w_2:=\bratr(w_1)$\newline 
{\bf if} $b(w_1)=b(w_2)=1$ {\bf then}\newline 
\phantom{---}$b(u):=0$\newline 
\phantom{---}{\bf if} $b(t):=0$ {\bf then}\newline 
\phantom{------}$b(t):=1$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $t$ není kořen stromu {\bf then}\newline \phantom{---------}$v:=t$, {\bf Vyvaz-DELETE}$(v)$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif} (Viz Obr. 5)\newline 
{\bf else}\newline 
\phantom{---}{\bf if} $b(w_1)=1$ {\bf then}\newline 
(Komentář: $b(w_2)=0$)\newline 
\phantom{------}{\bf Rotace$(t,u)$}, $b(w_2):=1$, $b(u):=b(t)$, $b(t):=1$ (Viz Obr. 6)\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf Dvojita-rotace}$(t,u,w_1)$, $b(w_1):=b(t)$, $b(t):=1$ (Viz Obr. 7)\newline
\phantom{---}{\bf endif\newline 
endif}

V následujících obrázcích jsou vrcholy, které 
nemají specifikovanou barvu (mohou být jak červené tak černé).
Tyto barvy budeme označovat $a$, $a'$. Důvod je, že se 
tato barva může přenést do cílového stromu, ale 
i na jiný vrchol. V tomto smyslu jsou tyto barvy určeny vstupním 
stromem a specifikují tyto barvy v cílovém stromě. V Obr. 5 
se barva $a$ v cílovém stromě neobjevuje.

\midinsert
\centerline{\input fig6.tex}
\botcaption{Obr. 4}
\endcaption
\endinsert

\midinsert
\centerline{\input fig7.tex}
\botcaption{Obr. 5}
\endcaption
\endinsert



\midinsert
\centerline{\input fig8.tex}
\botcaption{Obr. 6}
\endcaption
\endinsert

\midinsert
\centerline{\input fig9.tex}
\botcaption{Obr. 7}
\endcaption
\endinsert

Nyní popíšeme algoritmy realizující operace {\bf INSERT}, 
{\bf DE\-LE\-TE}, {\bf JOIN3} a {\bf SPLIT} pro červeno-černé stromy.  
Před\-po\-klá\-dejme, že $T$ je červeno-černý strom reprezentující 
množinu $S$ a pro\-vá\-dí\-me operaci {\bf INSERT$(x)$} pro $
x\notin S$.  Když 
ope\-race {\bf IN\-SERT$(x)$} pro nevyvážené binární vyhledávací stro\-my 
vytvoří strom $T'$, kde vrchol $v$ reprezentuje $x$, pak $
v$ 
obar\-ví\-me červeně a syny $v$ (jsou to listy) obarvíme černě.  
Dostáváme, že $(T',v)$ je 2-parciální červeno-černý strom, a pak 
aplikujeme proceduru {\bf Vyvaz-INSERT}.  

Operace {\bf INSERT} v červeno-černých stromech 
volá nejvýše $2+\log(|S|)$-krát proceduru {\bf Vyvaz-INSERT} a 
provede nejvýše jednu rotaci nebo dvojitou rotaci.

Operace {\bf DELETE} je řešena stejným způsobem 
jako ope\-race {\bf INSERT}, ale při operaci {\bf DELETE} je porušena třetí 
pod\-mín\-ka v definici červeno-černých stro\-mů a 
vyvažování je technicky náročnější.  
Předpokádejme, že $T$ je červeno-černý strom. Když chceme 
provést operaci {\bf DELETE}, pak nejprve provedeme algoritmus {\bf DELETE} 
pro nevyvážené 
binární vyhledávací stro\-my. Při provádění jsme 
odstranili vrchol $u$ a jeho syna $w$, který je list. Na 
místo vrcholu $u$ se dostal jeho druhý syn $v$, který 
obarvíme černě. Pak jsou splněny první 
dvě podmínky v definici červeno-černých 
stromů a pokud vrchol $u$ nebo vrchol $v$ byl
obarven červeně, pak je splněna i 
třetí podmínka. Pokud vrchol $u$ i vrchol $v$ byly obarveny 
černě, pak každá cesta z kořene do listu obsahující 
vrchol $v$ má o jeden černý  vrchol méně  než cesta z 
kořene do listu neobsahující vrchol $v$ (chybí černý  
vrchol $u$), a tedy $(T,v)$ je 3-parciální červeno-černý strom. 
Nyní aplikujeme proceduru {\bf Vyvaz-DELETE}.
Analýza poskytuje rychlý test na to, zda 
vznikne červeno-černý strom nebo 3-parciální 
červeno-černý strom (pak $v$ je list). 

Mějme červeno-černé stromy $T_1$ a $T_2$ reprezentující 
množiny $S_1$ a $S_2$ a mějme prvek $x\in U$ takový, že 
$\max S_1<x<\min S_2$.  Nejprve zajistíme, že kořeny $T_
1$ i $T_2$ jsou 
obarveny černě.  Předpokládejme, že $k_i$ je počet černých 
vrcholů na cestě z kořene do listů ve stromě 
$T_i$ pro $i=1,2$.  Když $k_1=k_2$, pak stačí provést {\bf JOIN3$
(T_1,x,T_2)$ }
pro nevyvážené binární vyhledávací stromy (kořen obarvíme 
červeně).  Problém je, když $k_1\ne k_2$.  Například 
předpokládejme, že $k_1>k_2$.  Pak začneme v kořeni stromu $
T_1$ a 
jdeme po pravých synech dolů tak dlouho, až nalezneme 
černý vrchol $v$ takový, že všechny cesty z $v$ do listů 
v $T_1$ obsahují právě $k_2$ černých vrcholů.  Pak 
provedeme {\bf JOIN3} pro nevyvážené binární vyhledavací stromy 
na podstrom $T_1$ určený vrcholem $v$, na $x$ a na $T_2$. Kořen $
w$ 
vzniklého stromu obarvíme červeně a tento strom vložíme do 
$T_1$ místo podstromu určeného vrcholem $v$. Pak $(T_1,w
)$ je 
$2$-parciální červeno-černý strom a aplikujeme proceduru 
{\bf Vyvaz-INSERT}. Případ $k_2>k_1$ se řeší symetricky. 

Algoritmus pro operaci {\bf SPLIT} je velmi podobný 
algoritmu pro $(a,b)$-stromy. Vy\-hledává\-me vrchol 
reprezentující $x$. Když jsme ve vrcholu $t$ a pokračujme akcí 
$t:=\levy(t)$, pak dvojici $\key(t)$ a podstrom $T$ určený pravým 
synem $t$ vložíme do zásobníku $Z_2$, když pokračujeme akcí 
$t:=\pravy(t)$, pak do zásobníku $Z_1$ vložíme dvojici podstrom $
T$ 
určený levým synem $T$ a $\key(t)$. Když $\key(t)=x$, pak do $
Z_1$ 
vložíme podstrom určený levým synem $t$ a do $Z_2$ podstrom 
určený pravým synem $t$. Když $t$ je list, pak do $Z_1$ i $
Z_2$ vložíme 
jednoprvkové stromy. Ze zásobníku $Z_1$ pomocí operace {\bf JOIN3 }
vytvoříme strom $T_1$ a ze zásobníku $Z_2$ pomocí operace {\bf JOIN3 }
dostaneme strom $T_2$. 

Nyní popíšeme algoritmy pro tyto operace.

{\bf INSERT$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ je list {\bf then}\newline 
\phantom{---}$t$ se změní na vnitřní vrchol, $\key(t):=x$\newline 
\phantom{---}pro vrchol $t$ vytvořme syny $\levy(t)$ a $\pravy(t)$\newline 
\phantom{---}$b(t):=0$, $b(\levy(t)):=1$, $b(\pravy(t)):=1$, {\bf Vyvaz-INSERT$(t)$\newline
endif

DELETE$(x)$\newline 
Vyhledej$(x)$\newline 
if} $t$ není list {\bf then}\newline 
\phantom{---}$vyv:=false$ \newline 
\phantom{---}{\bf if} $\levy(t)$ je list {\bf then}\newline 
\phantom{------}$v:=\pravy(t)$\newline 
\phantom{------}{\bf if} $b(t)=1$ a $b(v)=1$ {\bf then}\newline 
\phantom{---------}$vyv:=true$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}odstraníme vrchol $\levy(t)$, $\otec(v):=\otec(t)$\newline 
\phantom{------}{\bf if} $t=\levy(\otec(t))$ {\bf then}\newline 
\phantom{---------}$\levy(\otec(t)):=v$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(t)):=v$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$b(v):=1$, odstraníme vrchol $t$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}$u:=\levy(t)$\newline 
\phantom{------}{\bf while} $\pravy(u)$ není list {\bf do} $u:=\pravy(u)$ {\bf enddo}\newline 
\phantom{------}$\key(t):=\key(u)$, $v:=\levy(u)$ \newline 
\phantom{------}{\bf if} $b(u)=1$ a $b(v)=1$ {\bf then}\newline 
\phantom{---------}$vyv:=true$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}odstraníme vrchol $\pravy(u)$, $\otec(v):=\otec(u)$\newline
\phantom{------}{\bf if} $u=\levy(\otec(u))$ {\bf then}\newline 
\phantom{---------}$\levy(\otec(u)):=v$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$\pravy(\otec(u)):=v$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{------}$b(v):=1$, odstraníme vrchol $u$\newline 
\phantom{---}{\bf endif} \newline 
\phantom{---}{\bf if} $vyv$ {\bf then Vyvaz-DELETE$(v)$ endif\newline 
endif}

{\bf JOIN3$(T_1,x,T_2)$\newline 
if} $b(\text{kořen }T_1)=0$ {\bf then} $b(\text{kořen }T_1)
:=1$ {\bf endif\newline 
if} $b(\text{kořen }T_2)=0$ {\bf then} $b(\text{kořen }T_2)
:=1$ {\bf endif}\newline 
$k_1$ je počet černých vrcholů v $T_1$ z kořene do listů \newline 
$k_2$ je počet černých vrcholů v $T_2$ z kořene do listů \newline 
{\bf if} $k_1\ge k_2$ {\bf then}\newline 
\phantom{---}$t:=\text{ kořen }T_1$, $i:=k_1-k_2$ \newline 
\phantom{---}{\bf while} $i>0$ {\bf do}\newline 
\phantom{------}$t:=\pravy(t)$\newline 
\phantom{------}{\bf if} $b(t)=1$ {\bf then} $i:=i-1$ {\bf endif}\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}vytvoř vrchol $u$, $b(u):=0$, $\key(u):=x$\newline 
\phantom{---}{\bf if} $t$ není kořen $T_1$ {\bf then}\newline 
\phantom{------}$\otec(u):=\otec(t)$, $\pravy(\otec(t)):=u$\newline 
\phantom{---}{\bf endif}\newline 
\phantom{---}$\otec(t):=u$, $\otec(\text{kořen }T_2):=u$ \newline 
\phantom{---}$\pravy(u):=\text{ kořen }T_2$, $\levy(u):=t$, {\bf Vyvaz-INSERT$(T_1,u)$\newline 
else}\newline 
\phantom{---}$t:=\text{kořen }T_2$, $i:=k_2-k_1$ \newline 
\phantom{---}{\bf while} $i>0$ {\bf do}\newline 
\phantom{------}$t:=\levy(t)$\newline 
\phantom{------}{\bf if} $b(t)=1$ {\bf then} $i:=i-1$ {\bf endif}\newline 
\phantom{---}{\bf enddo}\newline 
\phantom{---}vytvoř vrchol $u$, $b(u):=0$, $\key(u):=x$ \newline 
\phantom{---}$\otec(u):=\otec(t)$, $\levy(\otec(t)):=u$, $\otec(t):=u$ \newline 
\phantom{---}$\otec(\text{kořen }T_1):=u$, $\levy(u):=\text{ kořen }T_1$ \newline 
\phantom{---}$\pravy(u):=t$, {\bf Vyvaz-INSERT}$(T_2,u)$\newline 
{\bf endif}

{\bf SPLIT$(x)$\newline 
$Z_1$} a $Z_2$ jsou prázdné zásobníky, $t:=\text{ kořen }T$\newline 
{\bf while} $\key(t)\ne x$ a $t$ není list {\bf do}\newline 
\phantom{---}{\bf if} $\key(t)>x$ {\bf then}\newline 
\phantom{------}vlož $(\key(t),\pravy(t))$ do $Z_2$, $t:=\levy(t)$ \newline 
\phantom{---}{\bf else}\newline 
\phantom{------}vlož $(\levy(t),\key(t))$ do $Z_1$, $t:=\pravy(t)$ \newline 
\phantom{---}{\bf endif\newline 
enddo \newline 
if} $\key(t)=x$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x\in S$, $T_1$ je podstrom $T$ určený $\levy(t)$ \newline 
\phantom{---}$T_2$ je podstrom $T$ určený $\pravy(t)$ \newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x\notin S$, $T_1$ a $T_2$ jsou jednoprvkové stromy\newline 
{\bf endif \newline 
while} $Z_1\ne\emptyset$ {\bf do}\newline 
\phantom{---}$(t,x)$ je na vrcholu $Z_1$, odstraň $(t,x)$ ze $Z_1$ \newline 
\phantom{---}$T'$ je podstrom $T$ určený $t$, $T_1:=${\bf JOIN3$(T',x,T_1
)$ \newline 
enddo\newline 
while} $Z_2\ne\emptyset$ {\bf do}\newline 
\phantom{---}$(x,t)$ je na vrcholu $Z_2$, odstraň $(x,t)$ ze $Z_1$ \newline 
\phantom{---}$T'$ je podstrom $T$ určený $t$, $T_2:=${\bf JOIN3$(T_2,x,T'
)$ \newline 
enddo}

Korektnost algoritmů je vidět z 
obrázků. Všimněme si při ope\-raci {\bf DELETE}, že když $
u$ je 
obarven červeně, pak po provedení {\bf Rotace$(t,u)$} bude $
(T,v)$ opět 
3-parciální červeno-černý strom a vrchol $t$ bude obarven červeně.  
Pak z Obr.  5 je vidět, že dostaneme červeno-černý 
strom. Tedy můžeme shrnout:

\begin{veta}Algoritmy operací {\bf MEMBER}, {\bf INSERT}, 
{\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, {\bf JOIN3} a {\bf SPLIT} pro červeno-černé 
stro\-my vyžadují v nejhorším případě čas $O
(\log(|S|)$, kde $S$ je 
reprezentovaná množina.  Operace {\bf INSERT} a {\bf JOIN3} zavolají 
nejvýše jednou buď {\bf Rotace} nebo {\bf Dvojita-rota\-ce} a operace 
{\bf DE\-LE\-TE} zavolá nejvýše dvakrát {\bf Rotace} nebo {\bf Rotace} a 
{\bf Dvojita-ro\-ta\-ce}.  
\end{veta}

Všimněte si, že operace {\bf JOIN3} ve skutečnosti 
vyžaduje čas $O(|k_1-k_2|+1)$. Protože $Z_1$ a $Z_2$ obsahují nejvýše 
$\log(|S|)$ položek, tak se odhad časové složitosti operace {\bf SPLIT }
prove\-de stejným způsobem jako v $(a,b)$-stromech. 
V ostatních pří\-pa\-dech je odhad časové složitosti vidět z toho, 
že $\hloubka(T)=O(\log(|S|))$ a akce na každé hladině vyžadují jen 
$O(1)$ času.

Pokud chceme mít i algoritmus pro operaci {\bf ord$
(k)$}, pak 
musíme rozšířit strukturu o funkci $p$. Pak lze použít přímo 
algoritmus pro {\bf ord$(k)$} v nevyvážených binárních vyhledávacích 
stromech. Připomeňme si, že procedury {\bf Rotace} a {\bf Dvojita-rotace }
mohou aktualizovat funkci $p$ v čase $O(1)$. Proto dostáváme 

\begin{veta}Algoritmy operací {\bf MEMBER}, 
{\bf INSERT}, {\bf DE\-LE\-TE}, {\bf MIN}, {\bf MAX}, {\bf JOIN3}, {\bf SPLIT} a {\bf ord$
(k)$} pro 
roz\-ší\-ře\-nou strukturu červeno-černých stromů vyžaduje 
v nejhorším případě čas $O(\log(|S|)$, kde $S$ je reprezentovaná 
množina.  Operace {\bf INSERT} a {\bf JOIN3} zavolají nejvýše jednou buď 
{\bf Rotace} nebo {\bf Dvojita-rota\-ce} a operace {\bf DELETE} zavolá nejvýše 
dvakrát {\bf Rotace} nebo jednou {\bf Rotace} a {\bf Dvojita-rotace}.  \end{veta}

Vzniká otázka, proč se tolik pozornosti věnuje 
procedurám {\bf Rotace} a {\bf Dvojita-rotace}. Sice vyžadují čas 
$O(1)$, ale jsou to nej\-složitější akce vyžadující nejvíce času. 
V mnoha aplikacích (pou\-žívají se hlavně ve výpočetní geometrii), 
tvar stromu spolu s parametry nesou ještě 
další zakódované informace. Při změně tvaru stromu je 
třeba je přepočítat. {\bf Rotace} a {\bf Dvojita-rotace} mění tvar 
stromu, kdežto posun směrem ke kořeni pouze mění 
obarvení. V tomto případě pak {\bf Rotace} nebo {\bf Dvo\-ji\-ta-rotace }
vyžaduje čas $O(|S|)$ (obvykle je třeba prohlédnout celý 
strom) a nikoliv $O(1)$.

\section{Váhově vyvážené stromy}

V osmdesátých letech se ve výpočetní geometrii 
hodně použí\-va\-ly $BB(\alpha )$-stromy, proto se o nich alespoň 
orientačně zmíníme. Mějme reálné číslo $
\alpha$ takové, že 
$\frac 14<\alpha\;\le\frac {\sqrt 2}2$. Pro strom $T$ označme $
p(T)$ počet 
listů ve stromu $T$. Binární vyhledávací strom $T$ 
reprezentující množinu $S$ se nazývá $BB(\alpha )$-\emph{strom}, 
když pro každý vnitřní vrchol $v$ platí:
$$\alpha\le\frac {p(T_l)}{p (T_v)}=1-\frac {p(T_r)}{p(T_v)}\le 1-\alpha$$
kde $T_v$ je podstrom $T$ určený vrcholem $v$, $T_l$ je podstrom 
$T$ určený levým synem vrcholu $v$, $T_r$ je podstrom $T$ 
určený pravým synem vrcholu $v$. Platí

\begin{tvrzeni}Když $T$ je $BB(\alpha )$-strom reprezentující 
$n$-prvkovou množinu, pak 
$$\hloubka(T)\le 1+\frac {\log(n+1)-1}{\log\frac 1{1-\alpha}}.$$
\end{tvrzeni}

Důsledek je, že $BB(\alpha )$-stromy patří do 
skupiny vyvážených binárních vyhledávacích 
stro\-mů.  Vyvažování se provadí opět pomocí 
{\bf Rotace} a {\bf Dvojita-rotace} a popisuje ho následu\-jí\-cí 
technické tvrzení. 

\begin{tvrzeni}Pro každé $\alpha$ existuje konstanta $
d$ 
taková, že $\alpha <d<1-\alpha$ a pro každý binární vyhledávací 
strom $T$ s kořenem $t$ splňující podmínky
\begin{enumerate}
\item
podstromy $T_l$ a $T_r$ stromu $T$ určené levým a pravým 
synem $t$ jsou $BB(\alpha )$-stromy;
\item
$\frac {p(T_l)}{p(T)}<\alpha$, ale $\alpha\le\frac {
p(T_l)}{p(T)-1}\le 1-\alpha$ nebo $\alpha\le\frac {
p(T_l)+1}{p(T)+1}\le 1-\alpha$
\end{enumerate}
platí:\newline 
když $\rho\le d$ a provedeme {\bf Rotace$(t,\pravy(t))$}, nebo když 
$\rho >d$ a provedeme proceduru {\bf Dvojita-rotace$(t,\pravy(t),\levy(\pravy(t)))$}, pak dostaneme 
$BB(\alpha )$-strom (zde $\rho =\frac {p(T')}{p(T_r
)}$ a $T'$ je určen levým synem 
pravé\-ho syna kořene $t$).  
\end{tvrzeni}

Toto tvrzení a jeho symetrické verze jednoznačně ukazují, 
jak vyvažovat $BB(\alpha )$-stromy při aktualizačních 
operacích (podstrom $BB(\alpha )$-stromu je $BB(\alpha )$-strom). Pak dostáváme:

\begin{veta}Implementace operací {\bf MEMBER}, {\bf INSERT} a {\bf DELETE }v $BB(\alpha )$-stromech vyžaduje v nejhorším 
případě čas $O(\log(|S|))$, kde $S$ je 
reprezentovaná množina.
\end{veta}

Obliba $BB(\alpha )$-stromů byla zapříčiněna 
platností následující věty, která je analogií věty o 
vyvažovacích operacích pro $(a,b)$-stromy.

\begin{veta}Když $\alpha$ je reálné číslo takové, že 
$\frac 14<\alpha <1-\frac {\sqrt 2}2$, pak existuje konstanta $c>
0$ závislá jen na 
$\alpha$ taková, že každá posloupnost operací {\bf INSERT} a {\bf DELETE }
o délce $m$ aplikovaná na prázdný $BB(\alpha )$-strom volá 
nejvýše $cm$ procedur {\bf Rotace} a {\bf Dvojita-rotace}.
\end{veta}

\section{Historický přehled:}

$(a,b)$-stromy zavedli Bayer a McGreght (1972),\newline 
věty o počtu vyvažovacích operací pro $(a,b)$-stromy dokázali 
Huddleston a Mehlhorn (1982).\newline 
$A$-sort analyzovali Guibas, McGreight, Plass a Roberts (1977).

Analýza interpolačního vyhledávání pochází od Perla, 
Itai a Avniho (1978),\newline 
kvadratické vyhledávání analyzovali Perl a Reingold (1977).

Adelson-Velskij a Landis (1962) definovali 
AVL-stromy,\newline 
červeno-černé stromy definovali Guibas a Sedgewick 
(1978),\newline 
verze algoritmu {\bf DELETE} pochází od Tarjana (1983).
$BB(\alpha )$-stromy zavedli Nievergelt a Reingold (1973),\newline 
věty o jejich vyvažování dokázali Blum a Mehlhorn (1980).\newline 
Priorita AVL-stromů se odráží v 
jejim hojném používání, i když červeno-černé stromy 
jsou efektivnější. 

\end{document}
