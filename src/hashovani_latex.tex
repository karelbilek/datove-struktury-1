\documentclass[a4paper,12pt]{article}
 \usepackage{amsmath}
 \usepackage{amsthm}
 \usepackage{amsfonts}
 
 
 \usepackage[utf8]{inputenc}
 \usepackage[czech]{babel}
 \usepackage{hyperref}
 
 \setlength{\hoffset}{-3cm} 
 \setlength{\voffset}{-3cm}
 \setlength{\textheight}{26.0cm} 
 \setlength{\textwidth}{19cm}
 \setlength{\parindent}{0in}
 \setlength{\parskip}{0.1in}
 
 \begin{document}
     

\newtheorem*{dusledek}{Důsledek}
\newtheorem*{lemma}{Lemma}
\newtheorem*{veta}{Věta}
\newtheorem*{tvrzeni}{Tvrzení}

\def \emph#1{\underbar{#1}}
\def \Prob{\operatorname{Prob}}
\def \var{\operatorname{var}}

\title{Datové struktury}
\date{}
\maketitle

\section{Úvod}

Základní problém: Reprezentace množin a 
operace s nimi. V řadě úloh a algoritmů je tento 
podproblém rozhodující pro složitost řešení, protože 
tyto operace se mnohokrát opakují. Proto je třeba 
navrhnout pro tyto úlohy co nejefektivnější algoritmy 
(každý ušetřený čas mnohonásobným opakováním začne 
hrát důležitou roli). To vede k detailní 
analýze složitosti v závislosti na vnějších okolnostech. 
Nelze říct, 
že některý algoritmus je nejlepší, protože za určitých 
okolností může být `méně efektivní' algoritmus 
výhodnější.

Cílem této přednášky není pouze seznámit vás s algoritmy 
pro řešení těchto problémů, protože s těmi jste se 
seznámili už v přednášce `Algoritmy a datové struktury'. Hlavním cílem 
je ukázat vám prostředky a metody, jak měřit a zjiš\v tovat 
jejich efektivitu, a tím vám ukázat prostřed\-ky, které vám 
umožní rozhodnout se v dané situaci pro určitý algoritmus. 
Proto hlavní náplní této přednášky bude počítání efektivity 
algoritmů. Budeme počítat za 
zjednoduše\-ných 
předpokladů, protože neumím říct (a ani to nelze, protože vždy záleží 
na konkrétních okolnostech), které sofistikovanější metody 
budou v praxi vhodné pro řešení vašeho problému. Cílem přednášky je 
seznámit vás s možnostmi, jak řešit tyto problémy, a se základními 
metodami pro jejich řešení. Nejprve si zadefinujeme asi 
nejzákladnější problém, který řešíme v datových strukturách. 

Řešíme tzv. slovníkový problém: Dáno 
univerzum $U$, máme reprezentovat $S\subseteq U$ a navrhnout algoritmy pro 
násle\-dující operace\newline 
{\bf MEMBER$(x)$} -- zjistí, zda $x\in S$, a nalezne jeho 
uložení\newline 
{\bf INSERT$(x)$} -- když $x\notin S$, pak vloží $x$ do struktury 
repre\-zentující $S$\newline 
{\bf DELETE$(x)$} -- když $x\in S$, pak odstraní $x$ ze struktury 
reprezentující $S$.\newline 
Efektivita algoritmu: časová složitost, prostorová 
složitost;\newline 
vy\-šetřené buď v nejhorším případě nebo v 
průměrném případě nebo amortizovaně.

Literatura:\newline 
K.~Mehlhorn: Data Structures and Algorithms 1: Sorting 
and Searching, Springer 1984\newline 
\url{http://www.mpi-sb.mpg.de/~mehlhorn/DatAlgbooks.html}

J.~S.~Vitter, W.-Ch.~Chen: Design and Analysis of 
Coalesced Hashing, Oxford Univ. Press, 1987

\section{Hašování}

Pomocí bitového pole můžeme rychle 
implementovat operace {\bf MEMBER}, {\bf INSERT} a {\bf DELETE}. 

Nevýhoda: když je velké univerzum, pak je prostorová 
složitost v nejlepším případě ohrom\-ná, ve špatném 
případě nelze pole zadat do počítače.\newline 
Hašování chce zachovat rychlost operací, ale odstranit 
pamě\v to\-vou náročnost. První publikovaný článek o 
hašování je od Dumney z roku 1956, první analýza hašování 
pochází od Petersona z roku 1957, ale existuje technická  
zpráva od IBM o hašování z roku 1953.

Základní idea: Dáno univerzum $U$ a množina 
$S\subseteq U$ tak, že $|S|<<|U|$. Máme funkci 
$h:U@>>>\{0,1,\dots,m-1\}$ a množinu $S$ reprezentujeme 
tabulkou (polem) s $m$ řádky tak, že $s\in S$ je uložen na 
řádku $h(s)$.\newline 
Nevýhoda: mohou existovat různá $s,t\in S$ taková, 
že $h(s)=h(t)$ - tento jev se nazývá \emph{kolize}.\newline 
Hlavní problém: řešení kolizí.\newline 
Základní řešení: použijeme pole o velikosti $[
0..m-1]$ a 
$i$-tá položka pole bude spojový seznam obsahující 
všechny prvky $s\in S$ takové, že $h(s)=i$. Toto řešení se 
nazývá \emph{hašování} \emph{se} \emph{separovanými} 
\emph{řetězci}.

Příklad: $U=\{1,2,\dots,1000\}$, $S=\{1,7,11,53,
73,141,161\}$ a 
funkce je $h(x)=x\bmod10$. Pak 
\begin{gather*} P(0)=P(2)=P(4)=P(5)=P(6)=P(8)=P(9)=\emptyset ,\\
P(7)=<7>,\quad P(3)=<53,73>,\quad P(1)=<1,141,11,161>.\end{gather*}
Seznamy nemusí být uspořádané.  

\subsection{
Algoritmy operací
}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf if} $i$-tý seznam je neprázdný {\bf then\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf while} $t\ne x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf do\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf enddo\newline 
endif\newline 
if} $t=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $x\notin 
S$ {\bf endif

INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf if} $i$-tý seznam je neprázdný {\bf then\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf while} $t\ne x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf do\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf enddo\newline 
endif\newline 
if} $t\ne x$ {\bf then} vložíme $x$ do $i$-tého seznamu {\bf endif}

{\bf DELETE}$(x)$\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf if} $i$-tý seznam je neprázdný {\bf then\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf while} $t\ne x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf do\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf enddo\newline 
endif\newline 
if} $t=x$ {\bf then} odstraníme $x$ z $i$-tého seznamu {\bf endif}

V následující analýze předpokládáme, že hodnota funkce $
h(x)$ 
je spočitatelná v čase $O(1)$.\newline 
V nejhorším případě operace vyžadují čas $
O(|S|)$ 
(všechny prv\-ky jsou v jednom seznamu). \newline 
Požadovaná pamě\v tová náročnost $O(m+|S|)$ 
(předpokládáme, že reprezentace prvku $s\in S$ vyžaduje pamě\v t $
O(1)$)\newline 
Pamě\v t není efektivně využitá.

Spočítáme očekávanou délku řetězců za 
předpokladů
\roster
\item
$h$ je rychle spočitatelná (tj. $O(1)$) a neměnná během 
výpočtu;
\item
$h$ rozděluje univerzum $U$ rovnoměrně (tj. 
$-1\le |h^{-1}(i)|-|h^{-1}(j)|\le 1$ pro $i,j\in \{0,1,\dots,m-1\}$);
\item
$S$ je náhodně vybraná z univerza $U$ (tj. pro dané $n=|
S|$ 
jsou všechny podmnoži\-ny $U$ o velikosti $n$ reprezentovanou 
množinou $S$ se stejnou pravděpodobností);\item
každý prvek z $U$ má stejnou pravděpodobnost být 
argumentem operace;
\item
velikost reprezentované množiny je výrazně menší než 
velikost univerza.
\endroster

Použité značení: $|S|=n$, $m=$počet 
řetězců, $|U|=N$,\newline 
$\ell (i)=$délka $i$-tého řetězce, $\alpha =\frac nm$ faktor naplnění (load factor)

Důsledky předpokladů:
\roster
\item"{}"
$\Prob(h(x)=i)=\frac 1m$ pro všechna $x\in U$ a všechna 
$i=0,1,\dots,m-1$; 
\item"{}"
$\Prob(\ell (i)=l)=p_{n,l}=\binom nl(\frac 1m)^l(1-\frac 1m)^{n-l}$ 
pro všechna $i=0,1,\dots,m-1$.
\endroster

Vysvětlení: $i$-tý řetězec má délku $
l$, právě když existuje 
pod\-mno\-žina $A\subseteq S$ taková, že $|A|=l$ (těchto možností je 
$\binom nl$), pro každé $x\in A$ platí $h(x)=i$ (pravděpodobnost 
tohoto jevu je $(\frac 1m)^l$) a pro každé $x\in S\setminus 
A$ platí $h(x)\ne i$ 
(pravděpodobnost tohoto jevu je $(1-\frac 1m)^{n-l}$). To znamená, že jev má 
binomiální rozdělení.

Zde jsme nepřesní. Obecně pro náhodně zvolené $
x\in U$ 
a dané $i$ je $\Prob(h(x)=i)=\frac {|h^{-1}(i)|}{|U|}$ a když existují dvě různá 
$i,j\in \{0,1,\dots,m-1\}$ taková, že $|h^{-1}(i)|\ne |h^{-1}
(j)|$, pak obecně 
$\frac {|h^{-1}(i)|}{|U|}\ne\frac 1m$. Toto nastane i v případě, když jsme již zvolili nějaký 
prvek v $h^{-1}(i)$. Protože však předpokládáme, že $
n,m<<|U|$ tak 
ve všech uvažovaných případech je $Prob(h(x)=i)$ přibližně 
$\frac 1m$, a můžeme tuto pravděpodobnost aproximovat 
hodnotou $\frac 1m$.

\subsection{
Očekávaná délka řetězců
}
$$\align E(l)=&\sum_{l=0}^nlp_{n,l}=\sum_{l=0}^nl\binom nl(\frac 
1m)^l(1-\frac 1m)^{n-l}=\\
&\sum_{l=0}^nl\frac {n!}{l!(n-l)!}(\frac 1m)^l(1-\frac 1m)^{n-l}=\\
&\frac nm\sum_{l=1}^n\frac {(n-1)!}{(l-1)!(n-l)!}(\frac 1m)^{l-1}
(1-\frac 1m)^{n-l}=\\
&\frac nm\sum_{l=1}^n\binom {n-1}{l-1}(\frac 1m)^{l-1}(1-\frac 1m
)^{(n-1)-(l-1)}=\\
&\frac nm\sum_{l=0}^{n-1}\binom {n-1}l(\frac 1m)^l(1-\frac 1m)^{n
-1-l}=\\
&\frac nm(\frac 1m+1-\frac 1m)^{n-1}=\frac nm.\endalign$$
Toto je standardní elementární výpočet 
očekávané hodnoty binomiálního rozdělení.  

\subsection{
Výpočet druhého momentu
}

$$\align E(l^2)=&E(l(l-1))+E(l),\\
E(l(l-1&))=\sum_{l=0}^nl(l-1)\binom nl(\frac 1m)^l(1-\frac 1m)^{n
-l}=\\
&\frac {n(n-1)}{m^2}\sum_{l=2}^n\binom {n-2}{l-2}(\frac 1m)^{l-2}
(1-\frac 1m)^{(n-2)-(l-2)}=\\
&\frac {n(n-1)}{m^2}\sum_{l=0}^{n-2}\binom {n-2}l(\frac 1m)^l(1-\frac 
1m)^{n-2-l}=\\
&\frac {n(n-1)}{m^2},\\
E(l^2)=&\frac {n(n-1)}{m^2}+\frac nm=\frac nm(1+\frac {n-1}m).\endalign$$
\subsection{
Výpočet rozptylu
}

$$\align\var(l)=&E(l-E(l))^2=E(l^2)-(E(l))^2=\\
&\frac nm(1+\frac {n-1}m)-(\frac nm)^2=\frac nm(1-\frac 1m).\endalign$$

Shrneme výsledky:\newline 
Očekávaná délka řetězců je $\frac nm$ a rozptyl délky 
řetězců je $\frac nm(1-\frac 1m)$.
Toto jsou standardní elementární odvození druhého momentu
a rozptylu binomiálního rozdělení.

\subsection{
Očekávaný nejhorší případ
}

Spočítáme $E(NP)$ očekávanou délku maximálního 
řetězce.\newline 
O\-znač\-me $\ell (i)$ délku $i$-tého řetězce. Pak
$$\Prob(\max_i\ell (i)=j)=\Prob(\max_i\ell (i)\ge j)-\Prob(\max_i
\ell (i)\ge j+1).$$

Pak můžeme počítat:
$$\align E(NP)=&\sum_jj\Prob(\max_i\ell (i)=j)=\\
&\sum_jj(\Prob(\max_i\ell (i)\ge j)-\Prob(\max_i\ell (i)\ge j+1))
=\\
&\sum_jj\Prob(\max_i\ell (i)\ge j)-\sum_jj\Prob(\max_i\ell (i)\ge 
j+1)=\\
&\sum_jj\Prob(\max_i\ell (i)\ge j)-\sum_j(j-1)\Prob(\max_i\ell (i
)\ge j)=\\
&\sum_j(j-j+1)\Prob(\max_i\ell (i)\ge j)=\\
&\sum_j\Prob(\max_i\ell (i)\ge j).\endalign$$
Vysvětlení: Při čtvrté rovnosti se v druhé sumě zvětšil 
index, přes který sčítáme, o $1$, v páté rovnosti se k sobě 
daly koeficienty při stejných pravděpodobnostech ve dvou 
sumách. 

Odtud
$$\align\Prob(\max_i&(\ell (i))\ge j)=\\
&\Prob(\ell (1)\ge j\vee\ell (2)\ge j\vee\dots\vee\ell (m-1)\ge j
)\le\\
&\sum_i\Prob(\ell (i)\ge j)\le m\binom nj(\frac 1m)^j=\\
&\frac {\prod_{k=0}^{j-1}(n-k)}{j!}(\frac 1m)^{j-1}\le n(\frac nm
)^{j-1}\frac 1{j!}.\endalign$$
Vysvětlení:  První nerovnost plyne z toho, že 
pravděpodobnost disjunkce jevů je menší než 
součet pravděpodobností jevů, dru\-há nerovnost 
plyne z toho, že $i$-tý řetězec má délku alespoň $
j$, jakmile existuje 
podmnožina $A\subseteq S$ taková, že $|A|=j$ (těchto možností je $\binom 
nj$) a pro každé $x\in A$ platí $h(x)=i$ (pravděpo\-dob\-nost 
tohoto jevu je $(\frac 1m)^j$). Protože pravděpodobnost je pro všechna $i$ stejná a $i$ nabývá $m$ hodnot, dostáváme druhou nerovnost. Následující rovnost plyne z rozepsání binomických koeficientů. Poslední nerovnost dostane\-me nahrazením $n-k$ hodnotou $n$.

\proclaim{Důsledek}
$$\Prob(\max_i(\ell (i))\ge j)\le\min\{1,n(\frac nm)^{j-1}\frac 1{
j!}\}.$$
\endproclaim

Předpoklad: $\alpha =\frac nm\le 1$. Ukážeme, že pro dostatečně 
velká $n$ pro 
$$j_0=\min\{j\mid n(\frac nm)^{j-1}\frac 1{j!}\le 1\}$$
platí $j_0\le\frac {(1+o(1))\log n}{\log\log n}$. 
K tomu použijeme Stirlingův vzorec pro faktoriály
$$j!=\sqrt{2j\pi}\left(\frac je\right)^j\left(1+\frac 1{12j}+\frac 1{288j^2}+O(j^{-3})\right)$$
a následující lemma.

\proclaim{Lemma}Když $(\frac qe)^q\le n$, pak $q\le(1+o(1))\frac{\ln n}{\ln\ln n}$.
\endproclaim

\demo{Důkaz}Všimněme si nejdřív, že platí
$$\align\left((\ln(\frac{\ln n}{\ln\ln n})-1\right)\frac{\ln n}{\ln\ln n}=&(\ln\ln n-\ln\ln\ln n-1)\frac{\ln n}{\ln\ln n}=\\&
\ln n-\frac{\ln n(\ln\ln\ln n)}{\ln\ln n}-\frac{\ln n}{\ln\ln n}=\\&\ln n(1-\frac{\ln\ln\ln n}{\ln\ln n}-
\frac 1{\ln\ln n})=(1+o(1))\ln n,\endalign$$
protože $\lim_{n\mapsto\infty}\frac{\ln\ln\ln n}{\ln\ln n}=0=\lim_{n\mapsto\infty}\frac 1{\ln\ln n}$. 
Odtud plyne $$\lim_{n\mapsto\infty}\left(\frac{\frac{\ln n}{\ln\ln n}}e\right)=e^{(1+o(1))\ln n}=n.$$ Protože $(\frac qe)^q$ je rostoucí funkce, tak dostáváme, že $q\le(1+o(1))(\frac{\ln n}{\ln\ln n})$. \qed
\enddemo

Protože $\frac nm\le1$, tak platí, že 
$$j_0=\min\{j\mid n(\frac nm)^{j-1}\frac 1{j!}\le 1\}\le\min\{j\mid n\le j!\}\le\min\{j\mid n\le
(\frac je)^j\}\le(1+o(1))\frac{\ln n}{\ln\ln n}.$$ 

Toto použijeme při odhadu $E(NP)$.
$$\align E(NP)=&\sum_j\Prob(\max_i(\ell (i))\ge j)\le\\
&\sum_j\min\{1,n(\frac nm)^{j-1}\frac 1{j!}\}=\\
&\sum_{j=1}^{j_0}1+\sum_{j=j_0+1}^{\infty}\big(n(\frac nm)^{j-1}\frac 
1{j!}\big)\le j_0+\sum_{j=j_0+1}^{\infty}\frac n{j!}=\\
&j_0+\frac n{j_0!}\sum_{j=j_0+1}^{\infty}\frac {j_0!}{j!}\le j_0+
\sum_{j=j_0+1}(\frac 1{j_0+1})^{j-j_0}=\\
&j_0+\frac {\frac 1{j_0+1}}{-\frac 1{j_0+1}+1}=j_0+\frac 1{j_0}=O
(j_0).\endalign$$
Vysvětlení: Při druhé rovnosti jsme použili, že $n(\frac nm)^{j-1}\frac 1{j!}\le 1$, právě když $j\le j_0$. Při druhé nerovnosti jsme použili, že $\frac 
nm\le 1$, 
při třetí nerovnosti jsme použili, že $\frac n{j_
0!}\le 1$ a 
$$\frac {j_0!}{j!}=\frac 1{\prod_{k=j_0+1}^jk}\le (\frac 1{j_0+
1})^{j-j_0}.$$
Shrneme získaný výsledek

\proclaim{Věta}Za předpokladu $\alpha =\frac nm\le 1$ je při hašování 
se se\-parovanými řetězci horní odhad očekávané délky 
maximálního ře\-těz\-ce $O(\frac {\log n}{\log\log n}
)$.  

Když $0.5\le\alpha\le 1$, je to zároveň i dolní odhad.
\endproclaim

\subsection{
Očekávaný počet testů
}

Test je porovnání argumentu operace s 
prvkem na daném místě řetězce nebo zjiště\-ní, 
že vyšetřovaný řetězec je prázdný.

Budeme rozlišovat dva případy:\newline 
\phantom{---}\emph{úspěšné} \emph{vyhledávání} -- argument 
operace je mezi prvky reprezentované množiny,\newline 
\phantom{---}\emph{neúspěšné} \emph{vyhledávání} -- argument 
operace není mezi prv\-ky reprezentované mno\-žiny.

\subsection{
Neúspěšné vyhledávání
}

Očekávaný počet testů:
$$\align E(T)=&\Prob(\ell (i)=0)+\sum_ll\Prob(\ell (i)=l)=\\
&p_{n,0}+\sum_llp_{n,l}=\\
&(1-\frac 1m)^n+\frac nm\approx e^{-\alpha}+\alpha .\endalign$$
Vysvětlení: Zjištění, zda řetězec je prázdný, vyžaduje 
jeden test, tj. $\Prob(\ell (i)=0)$ není s koeficientem $0$, ale $
1$.
Protože pravděpodobnosti jsou stejné pro všechny 
řetězce, nemusíme specifikovat řetězec, který 
vyšetřujeme, stačí psát obecně $i$. $\sum_llp_{
n,l}$ jsme spočítali 
při výpočtu očekávané délky řetězce.

\subsection{
\'Uspěšné vyhledávání
}

Zvolme jeden řetězec prvků o délce $l$. 
Počet testů při vyhledání všech prvků 
v tomto řetězci je
$$1+2+\dots+l=\binom {l+1}2.$$

Očekávaný počet testů při vyhledání všech 
prvků v nějakém řetězci je 
$$\sum_l\binom {l+1}2\Prob(\ell (i)=l)=\sum_l\binom {l+1}2p_{n,l}
.$$

Očekáný počet testů při vyhledání všech 
prvků v tabulce je $m\sum_l\binom {l+1}2p_{n,l}$.

Očekávaný počet testů pro 
vyhledání jednoho prvku je 
$$\align\frac mn\sum_{l=0}^n\binom {l+1}2p_{n,l}=&\frac m{2n}\big
(\sum_{l=0}^nl^2p_{n,l}+\sum_{l=0}^nlp_{n,l}\big)=\\
&\frac m{2n}\big(\sum_{l=1}^nl(l-1)p_{n,l}+2\sum_{l=1}^nlp_{n,l}\big
)=\\
&\frac m{2n}(\frac {n(n-1)}{m^2}+\frac {2n}m)=\frac {n-1}{2m}+1\approx\\
&1+\frac {\alpha}2.\endalign$$

Jiný postup: Předpokládejme, že počet testů při úspěšném 
vyhledávání prvku $x\in S$ je $1+$počet porovnání 
klíčů při neúspěšném vyhledávání $
x$ v operaci 
{\bf INSERT$(x)$}. Pak počet porovnání klíčů je délka 
řetězce, a proto očekáva\-ný počet porovnání klíčů 
je očekáva\-ná délka řetězce. Tedy očekávaný počet 
testů při úspěšném vyhledávání $x$ je  
$1+$očekávaná délka řetězce v okamžiku vkládání $
x$, neboli 
$$\frac 1n\sum_{i=0}^{n-1}(1+\frac im)=1+\frac {n-1}{2m}.$$

\proclaim{Věta}Při hašování se separovanými řetězci je 
očekávaný po\-čet testů při neúspeš\-ném 
vy\-hledávaní přibližně $e^{-\alpha}+\alpha$ a při ús\-pěš\-ném 
vyhledávání přibližně $1+\frac {\alpha}2$.
\endproclaim

Následující tabulka dává přehled očekávaného 
počtu testů pro různé hodnoty $\alpha$
$$\vtop{\hbox{\vbox {\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\hfill # \hfill \vrule\cr\noalign{\hrule} $
\alpha$ & 0 & 0.1 & 0.2 & 0.3 & 0.4 & 0.5 & 0.6 \cr\noalign{\hrule}neúsp. vyh. & 1 & 1.005 & 1.019 & 1.041 & 1.07 & 1.107 & 1.149 \cr\noalign{\hrule} úspěš. vyh. & 1 & 1.05 & 1.1 & 1.15 & 1.2 & 1.25 & 1.3 \cr\noalign{\hrule}}}}\hbox{\vbox {\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\hfill # \hfill \vrule\cr\noalign{\hrule} $
\alpha$ & 0.7 & 0.8 & 0.9 & 1 & 2 & 3 \cr\noalign{\hrule}neúsp. vyh. & 1.196 & 1.249 & 1.307 & 1.368 & 2.135 & 3.05 \cr\noalign{\hrule}úspěš. vyh. & 1.35 & 1.4 & 1.45 & 1.5 & 2 & 2.5 \cr\noalign{\hrule}}}}}$$

Všimněte si, že očekávaný počet testů 
při neúspěšném vy\-hledávání je menší než očekávaný 
počet testů při úspěšném vy\-hledávání, když 
$\alpha\le 1$. Na první pohled vypadá tento výsledek nesmyslně, 
ale důvod je, že počet testů při 
úspěšném vy\-hledávání průměrujeme proti $
n$, 
kdežto při neúspěšném vy\-hledávání proti $
m$. Ilustrujeme 
to na následujícím příkladu:\newline 
Nech\v t $n=\frac m2$ a nech\v t polovina neprázdných 
řetězců má délku $1$ a polovina má délku $
2$. \newline 
Očekávaný počet testů při neúspěšném 
vyhledávaní:
\roster
\item"{}"
$1$ test pro prázdné řetězce a řetězce 
délky $1$ -- těchto případů je $\frac {5m}6$
\item"{}"
$2$ testy pro řetězce délky $2$ -- těchto případů je 
$\frac m6$.
\endroster
Očekávaný počet testů je 
$\frac 1m(1\frac {5m}6+2\frac m6)=\frac 76$.\newline 
Očekávaný počet testů při úspěšném 
vyhledávání: 
\roster
\item"{}"
$1$ test pro prvky na prvním místě řetězce -- těchto 
případů je $\frac {2n}3$
\item"{}"
$2$ testy pro prvky, které jsou na druhém místě řetězce -- těchto 
případů je $\frac n3$.
\endroster
Očekávaný počet testů je $\frac 1n(1\frac {2n}
3+2\frac n3)=\frac 43$.

Velikost $\alpha$ je doporučována menší než $
1$, ale nemá být 
hodně malá, protože by pamě\v t nebyla efektivně využita. 

\section{Hašování s uspořádanými separovanými řetězci}

Vylepšení metody: hašování s uspořádanými řetězci.
Rozdíl proti původní metodě -- řetězce jsou 
uspořádané ve vzrůsta\-jícím pořadí. Protože 
řetězce obsahují tytéž prvky, je počet očeká\-va\-ných testů 
při úspěšném vyhledávání stejný jako u ne\-uspořádaných 
řetězců. Při neúspěšném vyhledávání končíme, 
když argument operace je menší než vyšetřovaný prvek 
v řetěz\-ci, tedy končíme dřív. Následující věta (bez 
důkazu) uvádí očekavaný počet testů v 
neúspěšném případě.

\proclaim{Věta}Očekávaný počet testů při 
neúspěšném vyhledávání pro hašování s uspořá\-danými 
řetězci je přibližně $e^{-\alpha}+1+\frac {\alpha}
2-\frac 1{\alpha}(1-e^{-\alpha})$. Očekávaný 
počet testů při úspěšném vyhledávání pro 
hašování s uspořádanými řetězci je 
přibližně $1+\frac {\alpha}2.$
\endproclaim

Uvedeme algoritmy pro operace s uspořádanými 
ře\-těz\-ci.

\subsection{
Algoritmy
}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf if} $i$-tý seznam je neprázdný {\bf then\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf while} $t<x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf do\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf enddo\newline 
endif \newline 
if} $t=x$ {\bf then} $x\in S$ {\bf else} $x\notin S$ {\bf endif

INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline 
{\bf if} $i$-tý seznam je neprázdný {\bf then\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf while} $t<x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf do\newline 
\phantom{{\rm ------}}$t:=$}následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf enddo\newline 
endif \newline 
if} $t\ne x$ {\bf then\newline 
\phantom{{\rm ---}}if} $x<t$ {\bf then\newline 
\phantom{{\rm ------}}}vložíme $x$ do $i$-tého seznamu před prvek $
t$\newline 
\phantom{---}{\bf else}\newline  
\phantom{------}vložíme $x$ do $i$-tého seznamu za prvek $
t$\newline 
\phantom{---}{\bf endif\newline 
endif

DELETE$(x)$}\newline 
Spočítáme $i:=h(x)$, $t:=NIL$\newline
{\bf if} $i$-tý seznam je neprázdný {\bf then\newline 
\phantom{{\rm ---}}$t:=$}první prvek $i$-tého seznamu\newline 
\phantom{---}{\bf while} $t<x$ a $t\ne$poslední prvek $i$-tého seznamu {\bf do}\newline 
\phantom{------}$t:=$následující prvek $i$-tého seznamu\newline 
\phantom{---}{\bf enddo\newline 
endif\newline 
if} $t=x$ {\bf then} odstraníme $x$ z $i$-tého seznamu {\bf endif


}
Nevýhody hašovaní se separovanými řetězci --\newline 
\phantom{---}nevyužití alokované paměti (nehospodárné)\newline 
\phantom{---}používání ukazatelů (cache).\newline 

Řešení: využít pro řetězce původní tabulku. Pak řádky tabulky musí mít strukturu, která umožňuje prohledávat řetězce, a velikost reprezentované množiny 
může být nejvýše rovna velikosti tabulky.  

Položky tabulky:\newline 
\phantom{---}key,\newline 
\phantom{---}odkaz na uložená data,\newline 
\phantom{---}položky pro práci s tabulkou.

Předpokládáme, že data jsou velká, v tom případě se 
ukládají mimo tabulku. V tabulce je jen odkaz na uložená data. 
Při popisu práce s tabulkou tuto část budeme vynechávat (tj. 
data budou pouze klíč).

Podle řešení kolize dělíme dál hašování:
\roster
\item"{}"
hašování s přemís\v továním, hašování s dvěma 
ukazateli, 
\item"{}"
srůstající hašování,
\item"{}"
dvojité hašování a hašování s lineárním 
přidáváním.
\endroster

\section{Hašování s přemís\v továním}

Položky pro práci s tabulkou: next, previous\newline 
\phantom{---}položka next -- číslo řádku tabulky 
obsahující následující polož\-ku seznamu\newline 
\phantom{---}položka previous -- číslo řádku tabulky obsahující 
předcházející položku seznamu.

Protože velikost tabulky omezuje velikost reprezentované množiny, může nastat přeplnění. O řešení 
případného přeplnění pojednáme později na str. 29. Stejný způsob řešení přeplnění se používá i v dalších metodách, kde velikost tabulky omezuje velikost reprezentované množiny.

Příklad: $U=\{1,2,\dots,1000\}$, $h(x)=x\bmod10$,\newline 
uložená množina $S=\{1,7,11,53,73,141,161\}$,\newline 
řetězce: $P(1)=(1,141,11,161)$, 
$P(3)=(73,53)$, $P(7)=(7)$.\newline 
Hašovací tabulka:
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & previous\hfil \cr\noalign{\hrule}P(0) & & & \hfill \cr\noalign{\hrule}P(1) & 1 & 9 & \hfill \cr\noalign{\hrule}P(2) & & & \hfill \cr\noalign{\hrule}P(3) & 73 & 6 & \hfill \cr\noalign{\hrule}P(4) & & &\hfill \cr\noalign{\hrule}P(5) & 161 & & 8 \cr\noalign{\hrule}P(6) & 53 & & 3 \cr\noalign{\hrule}P(7) & 7 & &\hfill \cr\noalign{\hrule}P(8) & 11 & 5 & 9 \cr\noalign{\hrule}P(9) & 141 & 8 & 1 \cr\noalign{\hrule}}}$$

Tabulka vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(141)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$},\newline 
{\bf INSERT$(7)$}, {\bf INSERT$(161)$}. 

\subsection{
Algoritmy
}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.previous\ne$prázdné nebo $i.key=$prázdné {\bf then Výstup}: $
x\notin S$, stop {\bf endif \newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif

DELETE$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.previous\ne$prázdné nebo $i.key=$prázdné {\bf then} stop {\bf endif\newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then}\newline  
\phantom{---}{\bf if} $i.previous\ne$prázdné {\bf then}\newline 
\phantom{------}$(i.previous).next:=i.next$\newline 
\phantom{------}{\bf if} $i.next\ne$prázdné {\bf then} $(i.n
ext).previous:=i.previous$ {\bf endif}\newline 
\phantom{------}$i.key:=i.next:=i.previous:=$ prázdné \newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $i.next\ne$prázdné {\bf then}\newline 
\phantom{---------}$i.key:=(i.next).key$, $i.next:=(i.next).next$\newline 
\phantom{---------}{\bf if} $((i.next).next)\ne$prázdné {\bf then} $
((i.next).next).previous:=i$ {\bf endif}\newline 
\phantom{---------}$(i.next).key:=(i.next).next:=(i.next).previous:=$ prázdné \newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$i.key:=$ prázdné \newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline
{\bf if} $i.key=NIL$ {\bf then} $i.key:=x$, stop {\bf endif}\newline 
{\bf if} $i.previous\ne NIL${\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nech\v t $j$ je volný řádek tabulky\newline 
\phantom{------}$j.key:=i.key$, $j.previous:=i.previous$, $j.next:=i.next$, $(j.previous).next:=j$\newline 
\phantom{------}{\bf if} $j.next\ne NIL$ {\bf then} $(j.next).previous:=j$ {\bf endif}\newline 
\phantom{---------}$i,key:=x$, $i.next:=i.previous:=$prázdné\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}{\bf while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo}\newline 
\phantom{---}{\bf if} $i.key\ne x$ {\bf then}\newline 
\phantom{------}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{---------}{\bf Výstup}: přeplnění\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}nech\v t $j$ je volný řádek tabulky\newline 
\phantom{---------}$i.next:=j$, $j.key:=x$, $j.previous:=i$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline
endif}


V příkladu provedeme {\bf INSERT$(28)$}, nový řádek je 4. řádek\newline 
-- výsledná hašovací tabulka
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & previous\hfil \cr\noalign{\hrule}P(0) & & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 &\hfill \cr\noalign{\hrule}P(2) & & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 &\hfill \cr\noalign{\hrule}P(4) & 11 & 5 & 9 \cr\noalign{\hrule}P(5) & 161 & & 4 \cr\noalign{\hrule}P(6) & 53 & & 3 \cr\noalign{\hrule}P(7) & 7 & &\hfill \cr\noalign{\hrule}P(8) & 28 &  &\hfill  \cr\noalign{\hrule}P(9) & 141 & 4 & 1 \cr\noalign{\hrule}}}$$

Očekávaný počet testů je stejný jako pro 
hašování se se\-pa\-ro\-va\-ný\-mi řetězci:\newline 
\phantom{---}úspěšné vyhledávání: $\frac {n-1}{
2m}+1\approx 1+\frac {\alpha}2$\newline 
\phantom{---}neúspěšné vyhledávání: $(1-\frac 1
m)^n+\frac nm\approx e^{-\alpha}+\alpha$,\newline 
kde $m=$ velikost tabulky, $n=$ velikost $S$, tj. počet uložených 
prvků, $\alpha =\frac nm=$ faktor zaplnění.

\section{Hašování s dvěma ukazateli}

Nevýhodou hašování s přemís\v továním je v operaci 
{\bf INSERT} případ, že $previous$ $h(i)$-tého řádku je neprázdný. Pak přemís\v tujeme položku na $h(i)$-tém řádku na volný řádek a to vyžaduje více času -- operace s přemístěním 
položky. Toto odstraňuje další implementace hašování se 
separujícími řetězci.

Položky pro práci s tabulkou -- next, 
begin\newline 
\phantom{---}Položka next -- číslo řádku tabulky obsahující 
následující polož\-ku seznamu\newline 
\phantom{---}Položka begin -- číslo řádku tabulky obsahující první položku seznamu 
s touto adresou\newline 

Stejná data jako v minulém případě\newline 

Hašovací tabulka:
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & begin \hfil \cr\noalign{\hrule}P(0) & & & \hfill \cr\noalign{\hrule}P(1) & 1 & 9 & 1 \cr\noalign{\hrule}P(2) & & & \hfill \cr\noalign{\hrule}P(3) & 73 & 7 & 3 \cr\noalign{\hrule}P(4) & & &\hfill \cr\noalign{\hrule}P(5) & 161 & & \hfill \cr\noalign{\hrule}P(6) & 7 & & \hfill \cr\noalign{\hrule}P(7) & 53 & & 6 \cr\noalign{\hrule}P(8) & 11 & 5 & \hfill \cr\noalign{\hrule}P(9) & 141 & 8 & \hfill \cr\noalign{\hrule}}}$$

Tabulka vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(141)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(7)$}, {\bf INSERT$(161)$}. 

\subsection{
Algoritmy
}

{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.begin=$prázdné {\bf then Výstup}: $x\notin S$, stop {\bf else} $i:=i.begin$ {\bf endif\newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif


DELETE$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.begin=$prázdné {\bf then} stop {\bf else} $j:=i$, $
i:=i.begin$ {\bf endif\newline 
while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $j:=i$, $i:
=i.next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then\newline 
\phantom{{\rm ---}}if} $i=j.begin$ {\bf then\newline 
\phantom{{\rm ------}}if} $i.next\ne$prázdné {\bf then\newline 
\phantom{{\rm ---------}}$j.begin:=i.next$\newline 
\phantom{{\rm ------}}else\newline 
\phantom{{\rm ---------}}$j.begin:=$}prázdné\newline 
\phantom{------}{\bf endif\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}$j.next:=i.next$\newline 
\phantom{{\rm ---}}endif\newline 
\phantom{{\rm ---}}$i.key:=i.next:=$}prázdné\newline 
{\bf endif


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.begin=$prázdné {\bf then}\newline 
\phantom{---}{\bf if} $i.key=$prázdné {\bf then}\newline 
\phantom{------}$i.key:=x$, $i.begin:=i$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{---------}{\bf Výstup}: přeplnění\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}nech\v t $j$ je volný řádek tabulky\newline 
\phantom{---------}$j.key=x$, $i.begin:=j$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
else}\newline 
\phantom{---}$i:=i.begin$\newline
\phantom{---}{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo}\newline 
\phantom{---}{\bf if} $i.key\ne x$ {\bf then}\newline 
\phantom{------}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{---------}{\bf Výstup}: přeplnění\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}nech\v t $j$ je volný řádek tabulky\newline 
\phantom{---------}$i.next:=j$, $j.key:=x$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}


V příkladu provedeme {\bf INSERT$(28)$}, nový řádek je 4. 
řádek\newline 
-- výsledná hašovací tabulka
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next & begin\hfil \cr\noalign{\hrule}P(0) & & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 & 1 \cr\noalign{\hrule}P(2) & & &\hfill \cr\noalign{\hrule}P(3) & 73 & 7 & 3 \cr\noalign{\hrule}P(4) & 28 &  &\hfill \cr\noalign{\hrule}P(5) & 161 & & \hfill \cr\noalign{\hrule}P(6) & 7 & &\hfill \cr\noalign{\hrule}P(7) & 53 & & 6 \cr\noalign{\hrule}P(8) & 11 & 5 & 4  \cr\noalign{\hrule}P(9) & 141 & 8 & \hfill \cr\noalign{\hrule}}}$$

Algoritmus při práci s položkami je rychlejší než při 
hašování s přemís\v továním, ale začátek řetězce v 
jiném místě tabulky přidává jeden test. Výsledek bez 
odvozování:\newline 
Očekávaný počet testů:\newline 
\phantom{---}úspěšný případ: $1+\frac {(n-1)(n-2
)}{6m^2}+\frac {n-1}{2m}\approx 1+\frac {\alpha^2}6+\frac {\alpha}
2$\newline 
\phantom{---}neúspěšný případ: $\approx 1+\frac {
\alpha^2}2+\alpha +e^{-\alpha}(2+\alpha )-2$.

\section{Srůstající hašování}

Srůstající hašování se dělí podle práce s 
pamětí na standardní a na srůstající hašování 
s pomocnou pamětí (které se nazývá jen 
srůstající hašování) a podle způsobu 
přidávání dalšího prvku.

Popíšeme metody:\newline 
\phantom{---}Standardní srůstající hašování: LISCH, EISCH,\newline 
\phantom{---}Srůstající hašování: LICH, VICH, EICH.

Všechny metody pro práci s tabulkou používají jen 
položku next -- číslo řádku tabulky obsahující 
následující položku seznamu. 

Základní idea: řetězec začíná na svém místě, ale 
pokud už tam byl uložen 
nějaký údaj, pak řetězec tohoto údaje sroste s řetězcem 
začínajícím na tomto řádku. To znamená, že prvky řetězce, který začíná na tomto místě, budou uloženy v řetězci, který už je uložen na tomto místě, ale jen od tohoto místa dál.

\subsection{
Metody EISCH a LISCH
}

\phantom{---}EISCH -- early-insertion standard coalesced hashing\newline 
\phantom{---}LISCH -- late-insertion standard coalesced hashing.
 

Organizace tabulky je stejná jako v předchozích 
případech.\newline 
Základní ideje: LISCH přidává nový prvek na konec 
řetězce, \newline 
EISCH přidává nový prvek $x$ do řetězce na 
řádek $h(x)$ (pokud je prázdný) nebo hned za prvek na řádku $h(x)$\newline 

Příklad: $U=\{1,2,\dots,1000\}$, $h(x)=x\bmod10$\newline 
množina $S=\{1,7,11,53,73,141,171\}$ je uložena 
v hašovací tabulce
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 \cr\noalign{\hrule}P(4) &  &\hfill \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & 53 &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7  \cr\noalign{\hrule}P(9) & 141 & 8 \cr\noalign{\hrule}}}$$

Tabulka pro metodu LISCH vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(141)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$},\newline 
{\bf INSERT$(161)$}, {\bf INSERT$(7)$}.\newline 
Pro metodu EISCH tabulka vznikla následující posloupností 
operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(161)$}, {\bf INSERT$(11)$}, {\bf INSERT$
(73)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(7)$}, {\bf INSERT$(141)$}. 

Provedeme {\bf INSERT$(28)$}, přidáváme do čvrtého rádku, vý\-sled\-ná tabulka vlevo je pro meto\-du 
LISCH, vpravo pro metodu EISCH.
$$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key & next \hfil\cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 \cr\noalign{\hrule}P(4) & 28 &\hfill \cr\noalign{\hrule}P(5) & 7 & 4 \cr\noalign{\hrule}P(6) & 53 &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7 \cr\noalign{\hrule}P(9) & 141 & 8 \cr\noalign{\hrule}}}\qquad\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 6 \cr\noalign{\hrule}P(4) & 28 & 7 \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & 53 & \hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 4  \cr\noalign{\hrule}P(9) & 141 & 8 \cr\noalign{\hrule}}}}}$$

\subsection{
Algoritmy
}

Algoritmus operace {\bf MEMBER} je pro obě metody stejný.


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo \newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif}


Metoda LISCH -- {\bf INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo \newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nech\v t $j$ je prázdný řádek $j.
key:=x$, 
$i.next:=j$\newline 
\phantom{---}{\bf endif\newline 
endif}


Metoda EISCH -- {\bf INSERT$(x)$}\newline 
Spočítáme $k:=i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo \newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nech\v t $j$ je volný řádek tabulky\newline 
\phantom{------}$j.next:=k.next$, $k.next:=j$, $j.key:=x$\newline 
\phantom{---}{\bf endif\newline 
endif}


Efektivní operace {\bf DELETE}  není známá, ale i primitivní 
algoritmy pro operaci {\bf DELETE} mají rozumnou očekávanou 
časovou složitost.

\subsection{
Analýza složitosti těchto algoritmů
}

Popis situace: Uložena množina 
$S=\{s_1,s_2,\dots,s_n\}$ do ta\-bulky velikosti $m$, je dán 
prvek $s_{n+1}$ a máme zjistit, zda $s_{n+1}\in S$. Označme 
$a_i=h(s_i)$ pro $i=1,2,\dots,n+1$, kde $h$ je použitá hašovací 
funkce.\newline 
Předpoklad: všechny posloupnosti $a_1,a_2,\dots,a_{n+1}$ jsou 
{\bf stejně pravděpodobné}. Výběr prázdného řádku je 
pevně daný, to znamená, že při stejně obsazených 
řadcích dostaneme vždy stejný prázdný řádek.  

\subsection{
Neúspěšné vyhledávání ($s_{n+1}\notin S$) 
}

Označení: $C(a_1,a_2,\dots,a_n;a_{n+1})$ označuje počet 
testů pro zjiš\-tění, že $s_{n+1}\notin S$. Platí: 
očekávaný počet testů při 
neúspěšném vy\-hledávání v množině $S$ je 
$$\frac {\sum C(a_1,a_2,\dots,a_n;a_{n+1})}{m^{n+1}},$$
kde se sčítá přes všechny posloupnosti $a_1,a_2,\dots
,a_{n+1}$ -- 
a těch je $m^{n+1}$. \newline 
Řetězec délky $l$ v množině $S$ je maximální posloupnost 
adres $(b_1,b_2,\dots,b_l)$ taková, že $b_i.next=b_{i+1}$ pro 
$i=1,2,\dots,l-1$.
Když adresa $a_{n+1}$ je $i$-tý prvek v řetězci, pak počet 
testů je $l-i+1$. Řetězec délky $l$ přispěl k součtu 
$\sum C(a_1,a_2,\dots,a_n;a_{n+1})$ počtem testů $1+2+\dots+l=l+\binom l2$. 

$c_n(l)=$ počet všech řetězců délky $
l$ ve všech 
reprezentacích $n$-prvkových množin (ztotožňuje\-me dvě 
množiny, které měly stej\-nou posloupnost adres při 
ukládaní prvků), pak 
$$\align\sum C(a_1,a_2,&\dots,a_n;a_{n+1})=c_n(0)+\sum_{l=1}^n(l+\binom 
l2)c_n(l)\\
&=c_n(0)+\sum_{l=1}^nlc_n(l)+\sum_{l=1}^n\binom l2c_n(l),\endalign$$
kde $c_n(0)$ je počet prázdných řádků ve všech 
reprezentacích. \newline 
Reprezentace $S$ má $m-n$ prázdných řádků,\newline 
všech posloupností $n$-adres je $m^n$, proto 
$$c_n(0)=(m-n)m^n.$$
$\sum_{l=1}^nlc_n(l)$ je celková délka všech řetězců ve 
všech tabulkách reprezentujících všechny $n$-prvkové 
množiny, a proto 
$$\sum_{l=1}^nlc_n(l)=nm^n.$$
Spočítáme $S_n=\sum_{l=1}^n\binom l2c_n(l)$.  Nejprve rekurentní vztah 
pro $c_n(l)$.  Přidáváme prvek s adresou $a_{n+1}$.  Pak řetězec 
délky $l$ v reprezentaci $S$ zůstal stejný, když 
adresa $a_{n+1}$ neležela v tomto řetězci, v opačném případě 
se délka řetězce zvětšila na $l+1$.  Proto přidání jednoho 
prvku vytvořilo z řetězce délky $l$ celkem $m-l$ 
řetězců délky $l$ a $l$ řetězců délky $
l+1$.  
Vysčítáním přes všechny $n$-prvkové posloupnosti adres 
dostáváme 
$$c_{n+1}(l)=(m-l)c_n(l)+(l-1)c_n(l-1).$$

Odtud
$$\align S_n=&\sum_{l=1}^n\binom l2c_n(l)=\\
&\sum_{l=1}^n\big(\binom l2(m-l)c_{n-1}(l)+\binom l2(l-1)c_{n-1}(
l-1)\big)=\\
&\big(\sum_{l=1}^n\binom l2(m-l)c_{n-1}(l)\big)+\big(\sum_{l=0}^{
n-1}\binom {l+1}2lc_{n-1}(l)\big)=\\
&\binom n2(m-n)c_{n-1}(n)+\\
&\big(\sum_{l=1}^{n-1}(\binom l2(m-l)+\binom {l+1}2l)c_{n-1}(l)\big
)+\binom 120c_{n-1}(0)=\\
&\sum_{l=1}^{n-1}\binom l2(m+2)c_{n-1}(l)+\sum_{l=1}^{n-1}lc_{n-1}
(l)=\\
&(m+2)S_{n-1}+(n-1)m^{n-1},\endalign$$
kde jsme použili, že $c_{n-1}(n)=0$, a identitu
$$\align(m-l)\binom l2+l\binom {l+1}2=&\frac 12(l^2m-lm-l^3+l^2+l^
3+l^2)=\\
&\frac 12(l^2m-lm+2l^2)=\\
&\frac 12(l^2m-lm+2(l^2-l))+l=\\
&(m+2)\binom l2+l.\endalign$$

Rekurence pro $S_n$ dává 
$$\align S_n=&(m+2)S_{n-1}+(n-1)m^{n-1}=\\
&(m+2)^2S_{n-2}+(m+2)(n-2)m^{n-2}+(n-1)m^{n-1}=\\
&(m+2)^3S_{n-3}+(m+2)^2(n-3)m^{n-3}+\\
&(m+2)(n-2)m^{n-2}+(n-1)m^{n-1}=\\
&(m+2)^{n-1}S_0+\sum_{i=0}^{n-1}(m+2)^i(n-1-i)m^{n-1-i}=\\
&(m+2)^{n-1}\sum_{i=0}^{n-1}(n-1-i)\big(\frac m{m+2}\big)^{n-1-i}
=\\
&(m+2)^{n-1}\sum_{i=1}^{n-1}i\big(\frac m{m+2}\big)^i,\endalign$$
kde jsme využili, že $S_0=0$. Spočítáme součet 
$T_c^n=\sum_{i=1}^nic^i$ pro $n=1,2,\dots$ a $c\ne 1$. Z
$cT_c^n=\sum_{i=1}^nic^{i+1}$ plyne 
$$\align(c-1)T_c^n=&cT_c^n-T_c^n=\sum_{i=2}^{n+1}(i-1)c^i-\sum_{i
=1}^nic^i=\\
&nc^{n+1}+\big(\sum_{i=2}^n((i-1)c^i-ic^i)\big)-c=\\
&nc^{n+1}+\big(\sum_{i=2}^n-c^i\big)-c=\\
&nc^{n+1}-\sum_{i=1}^nc^i=nc^{n+1}-\frac {c^{n+1}-c}{c-1}=\\
&\frac {nc^{n+2}-(n+1)c^{n+1}+c}{c-1}.\endalign$$

Tedy platí 
$$T_c^n=\frac {nc^{n+2}-(n+1)c^{n+1}+c}{(c-1)^2}.$$
Protože $\frac m{m+2}\ne 1$, dostáváme, že 
$$\align S_n=&(m+2)^{n-1}\frac {(n-1)\big(\frac m{m+2}\big)^{n+1}
-n\big(\frac m{m+2}\big)^n+\frac m{m+2}}{\big(\frac m{m+2}-1\big)^
2}=\\
&\frac 14(m+2)^{n+1}\big[(n-1)\big(\frac m{m+2}\big)^{n+1}-n\big(\frac 
m{m+2}\big)^n+\frac m{m+2}\big]=\\
&\frac 14\big[(n-1)m^{n+1}-n(m+2)m^n+m(m+2)^n\big]=\\
&\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big).\endalign$$
Očekávaný počet testů při neúspěšném 
vyhledávání je  
$$\align&\frac {(m-n)m^n+nm^n+\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big
)}{m^{n+1}}=\\
&\frac {m^{n+1}+\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big)}{m^{n+1}}
=\\
&1+\frac 14\big((1+\frac 2m)^n-1-\frac {2n}m\big)\sim 1+\frac 14(
e^{2\alpha}-1-2\alpha ).\endalign$$
Tento odhad je stejný pro obě metody -- LISCH i EISCH, 
protože mají stejné posloupnosti adres (liší se jen pořadím 
prvků v jednotlivých řetězcích).

\subsection{
\'Uspěšný případ ($s_{n+1}\in S$)
}

Očekávaný počet testů při úspěšném 
vyhledávání v modelu LISCH spočítáme stejnou meto\-dou jako 
pro hašování se separujícími řetězci.  Pro vyhledání prvku 
$s_{n+1}\in S$ je počet testů roven $1+$počet porovnání 
klíčů při operaci {\bf INSERT$(s_{n+1})$.}  Když $
s_{n+1}$ je vložen 
na místo $h(s_{n+1})$, nebyl porovnáván žádný klíč a test bude $
1$, 
když $h(s_{n+1})$ byl na na $i$-tém místě v řetězci délky $
l$, pak bylo 
při operaci {\bf INSERT$(s_{n+1})$} použito $l-i+1$ porovnání klíčů 
a teď se použije $l-i+2$ testů. Podle předchozí části analýzy dostaneme, že očekávaný počet 
porovnání klíčů při neúspěšném vyhledávání je 
$$\align&\frac 1{m^{n+1}}(\sum_{l=1}^n(l+\binom l2)c_n(l))=\\
&\frac 1{m^{n+1}}(nm^n+\frac 14\big(m(m+2)^n-m^{n+1}-2nm^n\big))=\\
&\frac 14\big((1+\frac 2m)^n-1+\frac {2n}m\big).\endalign$$
Tedy očekávaný počet testů při úspěšném 
vy\-hledávání v $n$-prvkové množině je podle 
před\-cho\-zí analýzy 
roven $1+n$-tina součtu očekávaného počtu porovnání 
klíčů při neúspěšném vy\-hledávání v $
i$-prvkové 
množině, kde $i$ probíhá čísla $0,1,\dots,n-1$.  Podle předchozích 
výsledků je hledaný součet 
$$\align\sum_{i=0}^{n-1}\frac 14\big[(1+\frac 2m)^i-&1+\frac {2i}
m\big]=\frac 14\frac {(1+\frac 2m)^n-1}{1+\frac 2m-1}-\frac n4+\frac {\binom 
n2}{2m}=\\
&\frac m8\big((1+\frac 2m)^n-1-\frac {2n}m\big)+\frac {n^2-n}{4m}
.\endalign$$
Tedy očekávaný počet testů v úspěšném 
případě pro $n$-prvko\-vou množinu je 
$$1+\frac m{8n}\big((1+\frac 2m)^n-1-\frac {2n}m\big)+\frac {n-1}{
4m}\sim 1+\frac 1{8\alpha}(e^{2\alpha}-1-2\alpha )+\frac {\alpha}
4.$$
Pro metodu EISCH je očekáváný počet testů v 
úspěšném přípa\-dě 
$$\frac mn\big((1+\frac 1m)^n-1\big)\sim\frac 1{\alpha}(e^{\alpha}
-1).$$
Výpočet je ale komplikovanější, musí se použít složitější metoda (metoda EISCH dává nový prvek hned za místo, kde má být uložen). Chyba aproximace 
pro tyto odhady je $O(\frac 1m)$. 

\subsection{
Metody LICH, EICH, VICH
}

\phantom{---}LICH -- late-insertion coalesced hashing\newline 
\phantom{---}EICH -- early-insertion coalesced hashing\newline 
\phantom{---}VICH -- varied-insertion coalesced hashing.

Základní idea: Metody používají pomocnou pamě\v t. 
Tabulka je rozdělená na adresovací část a na pomocnou 
pamě\v t, která není dostupná pomocí hašovací funkce, 
ale pomáhá při řešení kolizí. Metody se liší operací 
{\bf INSERT}. Všechny metody při kolizi nejprve použijí řádek 
tabulky z pomocné části a teprve, když je pomocná část 
zaplněna, používají adresovací část.\newline 
Metoda LICH: při {\bf INSERT}u vkládá prvek vždy na konec 
ře\-těz\-ce.\newline 
Metoda EICH: při {\bf INSERT}u vkládá prvek $x$ do řetězce vždy 
na místo hned za řádkem $h(x)$.\newline 
Metoda VICH: Při {\bf INSERT}u, když nový řádek je z 
pomocné části, tak je vložen s novým prvkem na konec 
řetězce, když je pomocná část paměti vyčer\-pá\-na, tak se 
řádek s novým prvkem vkládá do řetězce za posled\-ní 
řádek z pomocné části tabulky. Když řetězec neobsahuje 
žádný řádek z pomocné paměti, tak se řádek s novým  prvkem $
x$ vkládá hned za řádek $h(x)$. 

Idea: pomocná část má zabránit rychlému 
srůstání řetězců.

Tyto metody nepodporují přirozené efektivní algoritmy 
pro ope\-raci {\bf DELETE}.

Příklad: $U=\{1,2,\dots,1000\}$, $h(x)=x\bmod10$,\newline 
$S=\{1,7,11,53,73,141,161\}$. Tabulka má 12 řádků a 
má tvar
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 10 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) &  &\hfill \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7 \cr\noalign{\hrule}P(9) & &\hfill \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 8 \cr\noalign{\hrule}P(11) & 53 & \cr\noalign{\hrule}}}$$

Hašovací tabulka vznikla posloupnostmi operací:\newline 
Pro metodu LICH:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(141)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(11)$},\newline 
{\bf INSERT$(161)$}, {\bf INSERT$(7)$}.\newline 
Pro metodu EICH:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(161)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(11)$},\newline 
{\bf INSERT$(141)$}, {\bf INSERT$(7)$},

ale nedodržovalo se, že se nejdřív zaplňují řádky z 
pomocné části.  Při dodržování tohoto pravidla takováto tabulka 
nemůže vznik\-nout.\newline 
Pro metodu VICH:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(141)$}, 
{\bf INSERT$(53)$}, {\bf INSERT$(161)$},\newline 
{\bf INSERT$(11)$}, {\bf INSERT$(7)$}. 

Aplikujeme operace {\bf INSERT$(28)$} a {\bf INSERT$(31
)$}, nové řád\-ky 
budou řádky číslo 4 a 9. Tabulka vytvořená pomocí 
metody LICH je na levé straně, metodou VICH je v 
prostředku a metodou EICH je na pravé straně.

$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\hfil # \hfil\vrule\cr\noalign{\hrule}řádek & key & next \hfil\cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 10 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) & 28 & 9 \cr\noalign{\hrule}P(5) & 7 & 4 \cr\noalign{\hrule}P(6) &  &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 7 \cr\noalign{\hrule}P(9) & 31 &\hfill \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 8 \cr\noalign{\hrule}P(11) & 53 & \hfill \cr\noalign{\hrule}}}\,\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key & next \hfil\cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 10 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) & 28 & 7 \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) &  &\hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 4 \cr\noalign{\hrule}P(9) & 31 & 8 \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 9 \cr\noalign{\hrule}P(11) & 53 & \hfill \cr\noalign{\hrule}}}\,\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key & next \hfil \cr\noalign{\hrule}P(0) & &\hfill \cr\noalign{\hrule}P(1) & 1 & 9 \cr\noalign{\hrule}P(2) & &\hfill \cr\noalign{\hrule}P(3) & 73 & 11 \cr\noalign{\hrule}P(4) & 28 & 7 \cr\noalign{\hrule}P(5) & 7 & \hfill \cr\noalign{\hrule}P(6) & & \hfill \cr\noalign{\hrule}P(7) & 161 & 5 \cr\noalign{\hrule}P(8) & 11 & 4  \cr\noalign{\hrule}P(9) & 31 & 10 \cr\noalign{\hrule}\noalign{\hrule}P(10) & 141 & 8 \cr\noalign{\hrule}P(11) & 53 & \hfill \cr\noalign{\hrule}}}}}$

\subsection{
Algoritmy
}

Algoritmus operace {\bf MEMBER} je pro tyto metody 
stejný jako pro LISCH a EISCH


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf while} $i.next\ne$prázdné a $i.key\ne x$ {\bf do} $i:=i.
next$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif

}
Algoritmus operace {\bf INSERT} je pro metodu LICH stejný 
jako pro metodu LISCH a pro metodu EICH je stejný jako 
pro metodu EISCH s jediným doplňkem, pokud existuje 
prázdný řádek v pomocné části, tak $j$-tý řádek je z 
pomocné části. Tento předpoklad je i pro algoritmus 
{\bf INSERT} pro metodu VICH.


Metoda LICH -- {\bf INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.next=NIL$ {\bf then} $i.next=x$, stop {\bf endif\newline 
while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo\newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nech\v t $j$ je prázdný řádek, $j
.key:=x$, $i.next:=j$\newline 
\phantom{---}{\bf endif\newline 
endif}


Metoda EICH -- {\bf Insert$(x)$}\newline 
Spočítáme $k:=i:=h(x)$\newline 
{\bf if} $i.next=NIL$ {\bf then} $i.next=x$, stop {\bf endif\newline 
while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do} $i:=i.next$ {\bf enddo\newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek tabulky {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nech\v t $j$ je volný řádek tabulky\newline 
\phantom{------}$j.next:=k.next$, $k.next:=j$, $j.key:=x$\newline 
\phantom{---}{\bf endif\newline 
endif}


Metoda VICH -- {\bf INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$\newline 
{\bf if} $i.next=NIL$ {\bf then} $i.next=x$, stop {\bf endif\newline 
while} $i.next\ne NIL$ a $i.key\ne x$ {\bf do}\newline 
\phantom{---}{\bf if} $k$ není definováno a $i.next<m$ {\bf then} $k:=i$ {\bf endif\newline 
Poznámka}: Podmínka pro $k$ je splněna, když jsme byli na 
začátku nebo v pomocné části, podmínka na $i.next$ je 
splněna, když $i.next$ není v pomocné části.\newline 
\phantom{---}$i:=i.next$\newline 
{\bf enddo\newline 
if} $i.key\ne x$ {\bf then}\newline 
\phantom{---}{\bf if} neexistuje prázdný řádek {\bf then}\newline 
\phantom{------}{\bf Výstup}: přeplnění\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}nech\v t $j$ je volný řádek, $j.key:=x$\newline 
\phantom{------}{\bf if} $k$ není definováno {\bf then}\newline 
\phantom{---------}$i.next:=j$\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$j.next:=k.next$, $k.next:=j$\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf endif\newline 
endif}


Složitost algoritmů pro srůstající hašování.\newline 
Značení: $n$ -- velikost uložené množiny,\newline 
$m$ -- velikost adresovací části tabulky,\newline 
$m'$ -- velikost tabulky,\newline 
$\alpha =\frac n{m'}$ -- faktor zaplnění,\newline 
$\beta =\frac m{m'}$ -- adresovací faktor,\newline 
$\lambda$ -- jediné nezáporné řešení rovnice $e^{
-\lambda}+\lambda =\frac 1{\beta}$.

Očekávaný počet testů pro metodu LICH\newline 
neúspěšný případ:\newline 
\phantom{---}$e^{-\frac {\alpha}{\beta}}+\frac {\alpha}{\beta}$, když  $
\alpha\le\lambda\beta$, \newline 
\phantom{---}$\frac 1{\beta}+\frac 14(e^{2(\frac {\alpha}{\beta}-
\lambda )}-1)(3-\frac 2{\beta}+2\lambda )-\frac 12(\frac {\alpha}{
\beta}-\lambda )$, když $\alpha\ge\lambda\beta$\newline 
úspěšný případ:\newline 
\phantom{---}$1+\frac {\alpha}{2\beta}$, když $\alpha\le\lambda
\beta$, \newline 
\phantom{---}$1+\frac {\beta}{8\alpha}(e^{2(\frac {\alpha}{\beta}
-\lambda )}-1-2(\frac {\alpha}{\beta}-\lambda ))(3-\frac 2{\beta}
+2\lambda )+\frac 14(\frac {\alpha}{\beta}+\lambda )+\frac {\lambda}
4(1-\frac {\lambda\beta}{\alpha})$, 
když $\alpha\ge\lambda\beta$.

Očekávaný počet testů pro metodu EICH\newline 
neúspěšný případ:\newline 
\phantom{---}$e^{-\frac {\alpha}{\beta}}+\frac {\alpha}{\beta}$, když  $
\alpha\le\lambda\beta$, \newline 
\phantom{---}$e^{2(\frac {\alpha}{\beta}-\lambda )}(\frac 34+\frac {
\lambda}2-\frac 1{2\beta})+e^{\frac {\alpha}{\beta}-\lambda}(\frac 
1{\beta}-1)+(\frac 14-\frac {\alpha}{2\beta}+\frac 1{2\beta})$, když $
\alpha\ge\lambda\beta$\newline 
úspěšný případ:\newline 
\phantom{---}$1+\frac {\alpha}{2\beta}$, když $\alpha\le\lambda
\beta$, \newline 
\phantom{---}$1+\frac {\alpha}{2\beta}+\frac {\beta}{\alpha}((e^{\frac {
\alpha}{\beta}-\lambda}-1)(1+\lambda )-(\frac {\alpha}{\beta}-\lambda 
))(1+\frac {\lambda}2+\frac {\alpha}{2\beta}))$, když $\alpha\ge
\lambda\beta$.

Očekávaný počet testů pro metodu VICH\newline 
neúspěšný případ:\newline 
\phantom{---}$e^{-\frac {\alpha}{\beta}}+\frac {\alpha}{\beta}$, když  $
\alpha\le\lambda\beta$, \newline 
\phantom{---}$\frac 1{\beta}+\frac 14(e^{2(\frac {\alpha}{\beta}-
\lambda )}-1)(3-\frac 2{\beta}+2\lambda )-\frac 12(\frac {\alpha}{
\beta}-\lambda )$, když $\alpha\ge\lambda\beta$\newline 
úspěšný případ:\newline 
\phantom{---}$1+\frac {\alpha}{2\beta}$, když $\alpha\le\lambda
\beta$, \newline 
\phantom{---}$1+\frac {\alpha}{2\beta}+\frac {\beta}{\alpha}((e^{\frac {
\alpha}{\beta}-\lambda}-1)(1+\lambda )-(\frac {\alpha}{\beta}-\lambda 
))(1+\frac {\lambda}2+\frac {\alpha}{2\beta}))+\frac {1-\beta}{\alpha}
(\frac {\alpha}{\beta}-\lambda -e^{\frac {\alpha}{\beta}-\lambda}
+1)$, 
když $\alpha\ge\lambda\beta$.

Chyba aproximace pro tyto odhady je $O(\log\frac {m'}{\sqrt {
m'}})$.

\section{Hašování s lineárním přidáváním}

Tabulka má jedinou položku -- key

Základní idea:  Při operaci {\bf INSERT$(x)$} vložíme $
x$ 
na řádek $h(x)$, když je prázdný, v opačném případě 
nalezneme nejmenší $i$ takové, že řádek $h(x)+i\bmod 
m$ je 
prázdný, a tam vložíme $x$. Tato metoda byla motivována snahou o co největší využití paměti. 

Komentář:  Metoda vyžaduje minimální velikost paměti.  
V tabulce se vytvářejí shluky použitých řádků, a proto 
při velkém zaplnění metoda vyžaduje velký počet testů.  
Metoda nepodporuje efektivní implementaci operace {\bf DELETE}.  
Při vy\-hle\-dá\-vá\-ní je třeba testovat, zda nevyšetřujeme 
podruhé první vyšetřovaný řádek, a pro zjištění přeplnění je 
vhodné mít uložen počet vyplněných řádků v tabulce. Pro standarní paměti není výhodná. Při použití cache-paměti se výrazně mění její hodnocení. Důvodem je, že v tomto případě hraje klíčovou roli nikoliv počet testů, ale počet přechodů mezi různými úrovněmi paměti. Protože tabulka je reprezentovaná polem, tak je tento počet menší než u jiných metod. Proto se tato metoda doporučuje pro počítače s cache-pamětí.


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h(x)$, $h:=i$\newline 
{\bf if} $i.key=x$ {\bf then Výstup} $x\in S$, stop {\bf endif\newline 
if} $i.key=$prázdný {\bf then {{\rm Výstup}}}: $x\notin S$, stop {\bf endif\newline 
$i:=i+1$\newline 
while} $i.key\ne$prázdný a $i.key\ne x$ a $i\ne h$ {\bf do} $
i:=i+1\bmod m$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif


INSERT$(x)$}\newline 
Spočítáme $i:=h(x)$, $j:=0$\newline 
{\bf while} $i.key\ne$prázdný a $i.key\ne x$ a $j<m$ {\bf do} $
i:=i+1\bmod m${\bf ,} $j:=j+1$ {\bf enddo\newline 
if} $j=m$ {\bf then Výstup}: přeplnění, stop {\bf endif\newline 
if} $i.key=$prázdný {\bf then} $i.key:=x$ {\bf endif}


Příklad: Máme universum $U=\{1,2,\dots,1000\}$, 
hašovací funk\-ci $h(x)=x\bmod10$ a množinu  
$S=\{1,7,11,53,73,141,161\}$. Tato množina je uložena v levé tabulce. 
Provedeme operaci {\bf INSERT$(35)$}. Výsledek je uložen v 
pravé tabulce.
$$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key \hfil\cr\noalign{\hrule}P(0) & \hfill \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & 11 \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 161 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 7 \cr\noalign{\hrule}P(8) & \hfill\cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}\qquad\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key \hfil \cr\noalign{\hrule}P(0) & \hfill \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & 11 \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 161 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 7 \cr\noalign{\hrule}P(8) & 35  \cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}}}$$

Tabulka vznikla posloupností operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(11)$}, {\bf INSERT$(73)$}, 
{\bf INSERT$(141)$}, {\bf INSERT$(161)$},\newline 
{\bf INSERT$(53)$}, {\bf INSERT$(7)$}. 

Na závěr uvedeme složitost této metody. Očekávaný 
počet testů:\newline 
\phantom{---}neúspěšný případ: $\approx\frac 12(
1+\big(\frac 1{1-\alpha}\big)^2)$, \newline 
\phantom{---}úspěšný případ: $\approx\frac 12(1+\frac 
1{1-\alpha})$.

\section{Dvojité hašování}

Základní nevýhoda předchozí metody je způsob 
výběru dal\-ší\-ho řádku. Je velmi determinován a 
důsledkem je vznik shluku řádků, který 
vede k výraznému zpomalení metody. \newline 
Idea jak odstranit tuto nevýhodu: Použijeme dvě 
hašovací funkce $h_1$ a $h_2$ a při operaci {\bf INSERT$
(x)$ }
nalezneme nejmenší $i=0,1,\dots$ takové, že 
$(h_1(x)+ih_2(x))\bmod m$ je prázdný řádek, a tam uložíme 
prvek $x$.\newline 
Tabulka má jedinou položku -- key.\newline 
Požadavky na korektnost: Pro každé $x$ musí být $h_
2(x)$ a 
$m$ nesoudělné (jinak prvek $x$ nemůže být uložen 
na libovolném řádku tabulky). \newline 
Předpoklad pro výpočet očekávaného počtu testů: posloupnost 
$\{h_1(x)+ih_2(x)\}_{i=0}^{m-1}$ je náhodná permutace množiny 
řádků tabulky.\newline 
Nevýhoda: Uvedená metoda nepodporuje operaci {\bf DELETE}. \newline 
Poznámka: Metoda hašování s lineárním přidáváním je 
speciál\-ní případ dvojitého hašování, kde $
h_2(x)=1$ pro 
každé $x\in U$.

\subsection{
Algoritmy
}


{\bf MEMBER$(x)$}\newline 
Spočítáme $i:=h_1(x)$, $h:=h_2(x)$, $j:=0$\newline 
{\bf while} $i.key\ne$prázdný a $i.key\ne x$ a $j<m$ {\bf do} $
i:=i+h\bmod m$, $j:=j+1$ {\bf enddo\newline 
if} $i.key=x$ {\bf then Výstup}: $x\in S$ {\bf else Výstup}: $
x\notin S$ {\bf endif


INSERT$(x)$}\newline 
Spočítáme $i:=h_1(x)$, $h:=h_2(x)$, $j:=0$\newline 
{\bf while} $i.key\ne$prázdný a $i.key\ne x$ a $j<m$ {\bf do} $
i:=i+h\bmod m$, $j:=j+1$ {\bf enddo\newline 
if} $j=m$ {\bf then Výstup}: přeplnění, stop {\bf endif\newline 
if} $i.key=$prázdný {\bf then} $i.key:=x$ {\bf endif}


Příklad: Mějme universum $U=\{1,2,\dots,1000
\}$. 
Hašovací funkce jsou 
$h_1(x)=x\bmod10$ a $h_2(x)=1+2(x\bmod4)$, když 
$x\bmod4\in \{0,1\}$, $h_2(x)=3+2(x\bmod4)$, když $x\bmod4\in 
\{2,3\}$. 
Množina je  $S=\{1,7,11,53,73,141,161\}$. Tato množina je uložena v 
levé tabulce. Aplikujme {\bf INSERT$(35)$}. Pak $h_2(35)=9$, tedy 
posloupnost pro $x=35$ je 
$$(5,4,3,2,1,0,9,8,7,6).$$
Výsledek je uložen v pravé tabulce. 
$$\vbox {\hbox{\vtop{\offinterlineskip\halign{\strut\vrule\ # & \vrule\hfil# \hfil\vrule\cr\noalign{\hrule}řádek & key \hfil\cr\noalign{\hrule}P(0) & 11 \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & \hfill \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 7 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 161 \cr\noalign{\hrule}P(8) & \hfill\cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}\qquad\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}řádek & key \hfil \cr\noalign{\hrule}P(0) & 11 \cr\noalign{\hrule}P(1) & 1 \cr\noalign{\hrule}P(2) & 35 \cr\noalign{\hrule}P(3) & 73 \cr\noalign{\hrule}P(4) & 141 \cr\noalign{\hrule}P(5) & 7 \cr\noalign{\hrule}P(6) & 53 \cr\noalign{\hrule}P(7) & 161 \cr\noalign{\hrule}P(8) & \hfill \cr\noalign{\hrule}P(9) & \hfill \cr\noalign{\hrule}}}}}$$

Tabulka vznikla posloupností operací:\newline 
{\bf INSERT$(1)$}, {\bf INSERT$(73)$}, {\bf INSERT$(53)$}, 
{\bf INSERT$(141)$}, {\bf INSERT$(161)$},\newline 
{\bf INSERT$(11)$}, {\bf INSERT$(7)$}. 

Analýza vyhledávání v dvojitém hašování.

\subsection{
Neúspěšný případ
}

 

Značení:  $q_i(n,m)$ -- když tabulka má $m$ řádků a 
je v ní obsazeno $n$ řádků, tak je to 
pravděpodobnost, že pro každé $j=0,1,\dots,i-1$ je 
řádek $h_1(x)+jh_2(x)$ obsazen. Pak $q_0(n,m)=1$, $q_1(n,m)=\frac 
nm$, 
$q_2(n,m)=\frac {n(n-1)}{m(m-1)}$ a obecně 
$$q_i(n,m)=\frac {\prod_{j=0}^{i-1}(n-j)}{\prod_{j=0}^{i-1}(m-j)}
.$$
$C(n,m)$ -- očekávaný počet testů v neúspěšném 
vyhledávání, když tabulka má $m$ řádků a $
n$ jich 
je obsazeno. Podle definice platí:
$$C(n,m)=\sum_{j=0}^n(j+1)(q_j(n,m)-q_{j+1}(n,m))=\sum_{j=0}^nq_j
(n,m).$$
Dále platí $C(0,m)=1$ pro každé $m$ a 
$q_j(n,m)=\frac nmq_{j-1}(n-1,m-1)$ pro všechna $j,n>0$ a $m>1$. 
Odtud
$$C(n,m)=\sum_{j=0}^nq_j(n,m)=1+\frac nm(\sum_{j=0}^{n-1}q_j(n-1,
m-1))=1+\frac nmC(n-1,m-1).$$

Indukcí ukážeme, že $C(n,m)=\frac {m+1}{m-n
+1}$. Když $n=0$, pak 
$C(0,m)=\frac {m+1}{m-0+1}=1$ a tvrzení platí. Předpokládáme, že tvrzení 
platí pro $n-1\ge 0$ a pro každé $m\ge n-1$ a dokážeme tvrzení 
pro $n$ a $m\ge n$. Platí
$$\align C(n,m)=&1+\frac nmC(n-1,m-1)=\\
&1+\frac {n((m-1)+1)}{m((m-1)-(n-1)+1)}=\\
&1+\frac n{m-n+1}=\frac {m+1}{m-n+1}.\endalign$$
Očekávaný počet dotazů při neúspěšném 
vyhledávání v tabulce s $m$ řádky, z nichž $n$ je obsazeno, 
je $\frac {m+1}{m-n+1}$.

\subsection{
\'Uspěšný případ
}

 

Použijeme metodu ze separujících řetězců. 
Počet dotazů při vyhledávání $x$ pro $x\in 
S$ je 
stejný jako byl počet dotazů při vkládání $
x$ do 
tabulky. Tedy očekávaný počet dotazů při 
úspěšném vyhledávání v tabulce s $m$ řádky, z nichž $
n$ je 
obsazeno, je
$$\align\frac 1n\sum_{i=0}^{n-1}C(i,m)=&\frac 1n\sum_{i=0}^{n-1}\frac {
m+1}{m-i+1}=\\
&\frac {m+1}n\big(\sum_{j=1}^{m+1}\frac 1j-\sum_{j=1}^{m-n+1}\frac 
1j\big)\approx\\
&\frac 1{\alpha}\ln(\frac {m+1}{m-n+1})\approx\frac 1{\alpha}\ln(\frac 
1{1-\alpha}).\endalign$$
Následující tabulka ukazuje tyto hodnoty v závislosti na 
velikosti $\alpha$. 
$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}hodnota $\alpha$ & 0.5 & 0.7 & 0.9 & 0.95 & 0.99 & 0.999 \hfill \cr\noalign{\hrule}$\frac 1{1-\alpha}$ & 2 & 3.3 & 10 & 20 & 100 & 1000 \cr\noalign{\hrule} $\frac 1{\alpha}\ln(\frac 1{1-\alpha})$ & 1.38 & 1.70 & 2.55 & 3.15 & 4.65 & 6.9 \cr\noalign{\hrule}}}$$

\section{Porovnání efektivity}

Pořadí metod hašování podle očekávaného počtu 
testů:
\subsection{
Neúspěšné vyhledávání
}

\phantom{---}Hašování s uspořádanými řetězci,\newline 
\phantom{---}Hašování s řetězci=Hašování s přemís\v továním,\newline 
\phantom{---}Hašování s dvěma ukazateli,\newline 
\phantom{---}VICH=LICH,\newline 
\phantom{---}EICH,\newline 
\phantom{---}LISCH=EISCH,\newline 
\phantom{---}Dvojité hašování,\newline 
\phantom{---}Hašování s lineárním přidáváním.

\subsection{
\'Uspěšné vyhledávání
}

\phantom{---}Hašování s uspořádanými řetězci=Hašování s 
řetězci=Hašo\-vá\-ní s přemís\v továním,\newline 
\phantom{---}Hašování s dvěma ukazateli,\newline 
\phantom{---}VICH,\newline 
\phantom{---}LICH,\newline 
\phantom{---}EICH,\newline 
\phantom{---}EISCH,\newline 
\phantom{---}LISCH,\newline 
\phantom{---}Dvojité hašování,\newline 
\phantom{---}Hašování s lineárním přidáváním.

Poznámka: Metoda VICH při neúspěšném vyhledávání pro 
$\alpha <0.72$ a při úspěšném vy\-hledávání pro $
\alpha <0.92$ 
vyžaduje menší očekávaný počet testů než 
metoda s dvěma ukazateli.

Při neúspěšném vyhledávání jsou metody VICH a LICH stejné a jsou o 8\% lepší než 
EICH a o 15\% než metody LISCH a EISCH. Při úspěšném vyhledávání 
je VICH nepatrně lepší než LICH a EICH o 3\% lepší než 
EISCH a o 7\% lepší než LISCH.

\subsection{
Očekávaný počet testů při úplně zaplněné 
tabulce
}

\phantom{---}Metoda s přemís\v továním: neúspěšné vyhledávání 1.5, úspěšné 
vyhledávání 1.4.\newline 
\phantom{---}Metoda s dvěma ukazateli: úspěšné i neúspěšné vyhledávání  1.6.\newline 
\phantom{---}VICH: neúspěšné vyhledávání 1.79, úspěšné vyhledávání 
1.67.\newline 
\phantom{---}LICH: neúspěšné vyhledávání 1.79, úspěšné vyhledávání 
1.69.\newline 
\phantom{---}EICH: neúspěšné vyhledávání 1.93, úspěšné vyhledávání 
1.69.\newline 
\phantom{---}EISCH: neúspěšné vyhledávání 2.1, úspěšné vyhledávání 
1.72.\newline 
\phantom{---}LISCH: neúspěšné vyhledávání 2.1, úspěšné vyhledávání 
1.8.

Metodu s lineárním přidáváním je dobré použít jen pro 
$\alpha <0.7$, metodu s dvojitým hašováním pro $\alpha 
<0.9$, pak 
čas pro neúspěšné vyhledávání rychle narůstá.

Vliv $\beta =\frac m{m'}$ při srůstajícím hašování.\newline 
Při 
úspěšném vy\-hledávání je optimální hodnota $
\beta =0.85$, při 
neúspěšném vy\-hledávání je optimální hodnota $
\beta =0.78$. 
V praxi se doporučuje použít hodnotu $\beta =0.86$ (uvedené 
výsledky byly pro tuto hodnotu $\beta ).$

Komentář: Metody se separujícími řetězci a 
srůstající hašování používají více paměti (při 
srůstajícím hašování součet adresovací a 
pomocné části). Metoda s přemís\v továním a metoda 
dvojitého hašování vyžadují více času -- na přemístění 
prvku a na výpočet druhé hašovací funkce.

\section{Další otázky}

Jak nalézt volný řádek.\newline 
Za nejlepší metodu se považuje mít seznam (zásobník) 
volných řádků a z jeho vrcholu brát volný řádek 
a po úspěšné operaci {\bf DELETE} tam zase řádek vložit 
(pozor při operaci {\bf DELETE} ve strukturách, které 
nepodporují {\bf DELETE}).

Jak řešit přeplnění.\newline 
Standardní model: Dána základní velikost tabulky $m$ a 
pracuje se s tabulkami s $2^im$ řádky pro vhodné 
$i=0,1,\dots$. Vhodné $i$ znamená, že faktor zaplnění $
\alpha$ je v 
intervalu $<\frac 14,1>$ (s výjimkou $i=0$, kde se uvažuje 
pouze horní mez). Při překro\-če\-ní meze se zvětší nebo 
zmenší $i$ a všechna data se přehašují do nové 
tabulky.\newline 
Výhoda: Po přehašování do nové tabulky je počet operací, 
které vedou k novému přehašová\-vá\-ní, roven alespoň polovině 
velikosti uložené množiny.\newline 
Praktické použití: Nedržet se striktně mezí, používat 
malé pomocné ta\-bul\-ky při přeplnění a posunout velké 
přehašování na dobu klidu (aby systém nenechal uživatele v 
normální době čekat).

Jak řešit {\bf DELETE} v metodách, které ho 
nepodporují.\newline 
Použít ideu tzv. `falešného {\bf DELETE}'. 
Odstranit prvek, ale řádek neuvolnit (i v klíči nechat 
nějakou hodnotu, která bude znamenat, že řádek je 
prázdný, položky podporující práci s tabulkami neměnit). 
Řádek nebude v seznamu volných řádků, ale 
operace {\bf INSERT}, když testuje tento řádek, tam 
může vložit nový prvek. Když je alespoň 
polovina použitých řádků takto blokována, je 
vhodné celou strukturu přehašovat. Prav\-děpodobnostní 
analýzu tohoto modelu neznám.

\subsection{
Otevřené problémy
}

Jak využít ideje z hašování s uspořádanými 
řetězci pro ostatní metody řešení kolizí 
(jmeno\-vitě pro srůstající hašování).

Jakou metodu použít pro operaci {\bf DELETE} ve 
srůstajícím hašování (problém je zachovat náhodnost 
uložené množiny a tím platnost odhadu na složitost operací). 

Jak nalézt druhou hašovací funkci pro metodu 
dvojitého hašo\-vá\-ní, aby vzniklé posloupnosti adres při operaci 
{\bf INSERT} se chovaly jako náhodné.

\subsection{
Závěr
}

Připomeňme si předpoklady pro předchozí uvedené 
výsledky o hašování:
\roster
\item
Hašovací funkce se rychle spočítá (v čase 
$O(1)$);
\item Hašovací funkce rovnoměrně rozděluje univerzum (to 
znamená, že pro dvě různé hodnoty $i$ a $j$ 
hašovací funkce platí $-1\le |h^{-1}(i)|-|h^{-1}(j)|\le 
1$); 
\item
Vstupní data jsou rovnoměrně rozdělená.
\endroster

Diskutujme splnitelnost těchto předpokladů.\newline 
Předpoklad 1) je jasný.\newline 
Předpoklad 2) -- je výhodné, 
když rozdělení univerza hašovací funkcí kopíruje známé 
rozděle\-ní vstupních dat. Toto se použilo při návrhu 
překladače pro FORTRAN (Lum 1971). V překladači byla použita metoda separovaných řetězců a hašovací funkce, 
která preferovala obvyklé názvy identifikátorů. Výsledky byly měřeny, když se překladač FORTRANu použil pro standardní výpočet. Získané výsledky se porovnávaly s teoretickými výpočty za našich předpokladů. V 
následující tabulce můžete porovnat výsledky 
získané teoretickými výpočty a naměřené hodnoty.
Porovnání výsledků:

$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}hodnota $\alpha$ & 0.5 & 0.6 & 0.7 & 0.8 & 0.9 \hfill \cr\noalign{\hrule}experiment & 1.19 & 1.25 & 1.28 & 1.34 & 1.38 \cr\noalign{\hrule}teorie & 1.25 & 1.30 & 1.35 & 1.40 & 1.45 \cr\noalign{\hrule}}}$$

Závěr: Podmínky 1) a 2) můžeme splnit, 
když známe rozložení vstupních dat, můžeme 
dosáhnout ještě lepších výsledků.

Nevýhoda: Rozložení vstupních dat 
nemůžeme ovlivnit a obvykle ho ani neznáme. Je 
reálné, že rozdělení vstupních dat bude nevhodné pro 
použitou hašovací funkci. Důsledek -- na počátku 
70. let se začalo ustupovat od hašování. Hledal se postup, 
který by se vyhnul uvedenému problému s bodem 3). Nalezenému 
řešení je věnován následující text.

\section{Univerzální hašování}

Řešení navrhli Carter a Wegman (1977), když přišli s 
metodou univerzálního hašování, která obchází poža\-davek 3).  
To vedlo k novému rozsáhlému používání hašování.  

Základní idea: Místo jedné funkce máme 
množinu $H$ funkcí z univerza do tabulky velikosti $m$ 
takových, že pro každou množinu $S\subseteq U$, $|S|\le 
m$ se 
většina funkcí chová dobře vůči $S$ (tj. hašovací funkce má jen málo kolizí v množině $S$). 
Hašovací funkci 
zvolíme náhodně z $H$ (s rovnoměrným rozdělením) a hašujeme  
pomocí takto zvo\-lené funkce. 

Modifikace ideje. Ověřování vlastností vyžaduje 
znalost velikosti množiny $H$. Rychlá vyčíslitelnost $
h(x)$ 
vyžaduje ana\-lytické zadání funkcí v $H$, ale zjištění rovnosti 
dvou analy\-ticky zadaných funkcí na univerzu $U$ je 
problematické. Řešením problému je použití indexové množiny. 
To znamená, že $H=\{h_i\mid i\in I\}$ a dvě funkce jsou různé, 
když mají různé indexy. Pak velikost systému bude 
velikost indexové množiny. Místo zvolení hašovací funkce 
budeme volit náhodně index s rovnoměrným rozložením a když 
zvolíme index $i$, pak budeme pracovat s hašovací funkcí $
h_i$. 
Očekávaná hodnota náhodné proměnné $f$ z množiny $
I$ do 
reálných čísel bude průměr přes $I$, tj. $\frac {
\sum_{i\in I}f(i)}{|I|}$.

Formálně: Nech\v t  $U$ je univerzum. Soubor  
funkcí $H=\{h_i\mid i\in I\}$ z univerza $U$ do množiny $\{
0,1,\dots,m-1\}$ se 
nazývá $c$-\emph{univerzální} ($c$ je kladné reálné číslo), 
když 
$$\forall x,y\in U,\,x\ne y\text{\rm\ platí }|\{i\in I\mid h_
i(x)=h_i(y)\}|\le\frac {c|I|}m.$$

Jako ekvivalentní definici lze použít toto tvrzení: systém funkcí $
H$ z univerza $U$ do množiny $\{0,1,\dots,m-1\}$ je $c$-univerzální,
když vybereme-li $h\in H$ s rovnoměrným rozděle\-ním, pak pro 
každá dvě různá $x,y\in U$ platí 
$$\Prob(h(x)=h(y))\le\frac cm.$$

Problémy: existence $c$-univerzálních 
systémů, \newline 
vlastnosti $c$-univerzálních systémů (zda splňují 
požadované ide\-je).

\subsection{
Existence univerzálních systémů
}

Univerzum $U=\{0,1,\dots,N-1\}$ pro prvočíslo $N$,\newline 
$H=\{h_{a,b}\mid (a,b)\in U\times U\}$,\newline 
kde $h_{a,b}(x)=((ax+b)\bmod N)\bmod m$\newline 
(tj. indexová množina je $U\times U$ a její velikost je $
N^2$).

Výhoda: funkce z množiny $H$ umíme rychle 
vyčíslit.

Zvolme $x,y\in U$ taková, že $x\ne y$. Chceme nalézt 
$(a,b)\in U\times U$ takové, že $h_{a,b}(x)=h_{a,b}(y)$. 

Musí existovat $i\in \{0,1,\dots,m-1\}$ a 
$r,s\in \{0,1,\dots,\lceil\frac Nm\rceil -1\}$ tak, že platí
$$\align(ax+b&\equiv i+rm)\bmod N\\
(ay+b&\equiv i+sm)\bmod N\endalign$$
Když $x$, $y$, $i$, $r$ a $s$ jsou konstanty a $a$ a $b$ jsou 
proměnné, je to systém lineárních rovnic v tělese 
$\Bbb Z/\bmod N$, kde $\Bbb Z$ jsou celá čísla. Matice soustavy  
$$\pmatrix x\quad 1\\
y\quad 1\endpmatrix $$
je regulární, protože $x\ne y$. Jelikož $\Bbb Z/\bmod N$ je těleso, tak 
 pro fixovaná $x$, $y$, $i$, $r$ a $s$ existuje právě jedno řešení této soustavy.
Pro daná $x$ a $y$, $i$ nabývá $m$ hodnot, $r$ a $s$ nabývají 
$\lceil\frac Nm\rceil$ hodnot. 

Závěr: pro každá $x,y\in U$ taková, že 
$x\ne y$, existuje $m\big(\lceil\frac Nm\rceil\big)^2$ dvojic $(a
,b)\in U\times U$ takových, že 
$h_{a,b}(x)=h_{a,b}(y)$.

\proclaim{Věta}Množina $H$ je $c$-univerzální pro 
$$c=\frac {\big(\lceil\frac Nm\rceil\big)^2}{\big(\frac Nm\big)^2}
.$$
\endproclaim

Skutečně, pro každé $x,y\in U$, $x\ne y$, je počet 
$(a,b)\in U\times U$ takových, že $h_{a,b}(x)=h_{a,b}(y)$, nejvýše roven
$$m\big(\lceil\frac Nm\rceil\big)^2=\frac {\big(\lceil\frac Nm\rceil\big
)^2}{\big(\frac Nm\big)^2}\frac {N^2}m=\frac {\big(\lceil\frac Nm
\rceil\big)^2}{\big(\frac Nm\big)^2}\frac {|I|}m.$$

Závěr: Dokázali jsme existenci $c$-univerzálních 
systémů pro $c$ blízké $1$. Stačí si uvědomit, že  každé univerzum můžeme 
považovat za univerzum tvaru $\{0,1,\dots,N-1\}$ pro nějaké 
$N$ a že mezi čísly $N$ a $2N$ vždy existuje nějaké 
prvočíslo.

\subsection{
Vlastnosti univerzálního hašování
}

Předpoklad: $H=\{h_i\mid i\in I\}$ je $c$-univerzální systém funkcí\newline 
Označení: Pro $i\in I$ a prvky $x,y\in U$ 
označme 
$$\delta_i(x,y)=\cases 1&\quad\text{\rm\ když }x\ne y\text{\rm\ a }
h_i(x)=h_i(y),\\
0&\text{\rm\ když }x=y\text{\rm\ nebo }h_i(x)\ne h_i(y).\endcases $$
Pro množinu $S\subseteq U$, $x\in U$ a $i\in I$ definujme
$$\delta_i(x,S)=\sum_{y\in S}\delta_i(x,y).$$

Pro fixovanou množinu $S\subseteq U$ a pro fixované $
x\in U$ sečteme
$\delta_i(x,S)$ přes všechna $i\in I$:
$$\align\sum_{i\in I}\delta_i(x,S)=&\sum_{i\in I}\sum_{y\in S}\delta_
i(x,y)=\sum_{y\in S}\sum_{i\in I}\delta_i(x,y)=\\
&\sum_{y\in S,y\ne x}|\{i\in I\mid h_i(x)=h_i(y)\}|\le\\
&\sum_{y\in S,y\ne x}c\frac {|I|}m=\cases (|S|-1)c\frac {|I|}m&\text{\rm\ když }
x\in S,\\
|S|c\frac {|I|}m&\text{\rm\ když }x\notin S.\endcases \endalign$$

Protože $\delta_i(x,S)$ dává odhad na velikost řetězce $
h_i(x)$ při 
repre\-zentaci množiny $S$ pomocí funkce $h_i$, dostáváme, že 
očekávaná délka řetězce pro fixovanou množinu  
$S\subseteq U$ a fixované $x\in U$ přes $i\in I$ s rovnoměrným 
rozdělením je nejvýše
$$\frac 1{|I|}\sum_{i\in I}\delta_i(x,S)\le\cases c\frac {|S|-1}m&\text{\rm\ když }
\quad x\in S,\\
c\frac {|S|}m&\text{\rm\ když }\quad x\notin S.\endcases $$

\proclaim{Věta}Očekávaný čas operací {\bf MEMBER}, {\bf INSERT }
a {\bf DE\-LETE} při $c$-univerzálním hašování je $
O(1+c\alpha )$, kde 
$\alpha$ je faktor napl\-nění (tj. $\alpha =\frac {|S|}m$).

Očekávaný čas pro pevnou posloupnost $n$ operací 
{\bf MEMBER}, {\bf INSERT} a {\bf DELETE} aplikovaných na prázdnou ta\-bulku 
pro $c$-univerzální hašování je $O((1+\frac c2\alpha 
)n)$, kde $\alpha =\frac nm$.  
\endproclaim

Význam výsledku:  Vzorec se jen o multiplikativní 
konstantu $c$ liší od vzorce pro hašování se separovanými 
řetězci.  Přitom $c$ může být jen o málo menší než $
1$ a 
ve všech známých příkla\-dech je $c\ge 1$.  Takže, co jsme 
dosáhli?  Rozdíl je v předpokla\-dech.  Zde je předpoklad 3) 
nahrazen předpokladem, že index $i\in I$ je vybrán s 
rovnoměrným rozdělením, a není žádný předpoklad na vstupní 
data.  {\bf Výběr indexu} $i$ {\bf můžeme ov\-liv\-nit, ale výběr 
vstupních dat nikoliv.}  Můžeme zajistit rovno\-měr\-né 
rozdělení výběru $i$ z $I$ nebo se k tomuto rozdělení hodně 
přiblížit.  

\subsection{
Markovova nerovnost
}

Předpoklady: Je dána množina $S\subseteq U$, prvek $
x\in U$. 
Očeká\-va\-ná velikost $\delta_i(x,S)$ je $\mu$ a $t\ge 
1$.

Ukážeme pro $t>1$, že pravděpodobnost, že $
\delta_i(x,S)\ge t\mu$ 
pro $i\in I$, je menší než $\frac 1t$ (předpokladáme, že $
i$ je z $I$ vybráno s 
rovnoměrným rozdělením).  

Označme $I'=\{i\in I\mid\delta_i(x,S)\ge t\mu \}$. Pak platí
$$\mu =\frac {\sum_{i\in I}\delta_i(x,S)}{|I|}>\frac {\sum_{i\in 
I'}\delta_i(x,S)}{|I|}\ge\frac {\sum_{i\in I'}t\mu}{|I|}=\frac {|
I'|}{|I|}t\mu$$

Odtud
$$|I'|<\frac {|I|}t.$$

Závěr: Pravděpodobnost, že $\delta_i(x,S)\ge 
t\mu$, je menší 
než $\frac 1t$, a odtud plyne požadované tvrzení. 

Poznámka: Toto tvrzení platí obecně a nazývá 
se Markovova nerovnost. Uvedený důkaz 
ilustruje jednoduché tvrzení pro ko\-neč\-ný případ.

\subsection{
Problémy
}

Hlavní problém: Zajištění rovnoměrného rozdělení 
výběru $i$ z $I$.

Provedení výběru: Zak\'odovat indexy z množiny $
I$ do 
čísel $0,1,\dots,|I|-1$. Zvolit náhodně číslo $
i$ z tohoto 
intervalu s rovnoměrným rozdělením a pak použít 
funkci s indexem, jehož k\'od je $i$. Abychom vybrali $i$, nalezneme 
nejmenší $j$ takové, že $2^j-1\ge |I|-1$. Pak čísla v 
intervalu $\{0,1,\dots,2^j-1\}$ jednoznačně korespondují s 
posloupnostmi $0$ a $1$ délky $j$. Budeme vybírat náhodně 
posloupnost $0$ a $1$ délky $j$. Když takto vybraná posloupnost neodpovídá prvku z $I$, tak vygenerujeme jinou posloupnost (a tuto vynecháme). Pokud použijeme náhodný generátor $0$ a $1$, pak takto získáme náhodný prvek z $I$. Tedy k výběru náhodné funkce potřebujeme  
náhodný generátor $0$ a $1$ s rovnoměrným rozděle\-ním.

Závada: Skutečný náhodný generátor pro 
rovnoměrné rozděle\-ní je prakticky nedosažitelný 
(některé fyzikální procesy). K dispozici je pouze 
pseudogenerátor. 

Jeho nevýhoda: \v Cím je $j$ větší, tím je 
posloupnost pravidelnější (tj. méně náhodná). 

Důsledky: Nalézt co nejmenší $c$-univerzální 
systémy. Nalézt dolní odhady na jejich velikost.

\subsection{
Dolní odhady na velikost
}

Předpoklady: Nech\v t $U$ je univerzum velikosti $N$ a nech\v t 
$H=\{h_i\mid i\in I\}$ je $c$-univerzální systém funkcí hašujících do tabulky velikosti 
$m$. Můžeme předpoklá\-dat, že 
$$I=\{0,1,\dots,|I|-1\}.$$

Indukcí definujme množiny $U_0,U_1,\dots$ tak, že: 
$U_0=U$.\newline 
Nech\v t $U_1$ je největší podmnožina $U_0$ vzhledem k počtu 
prvků taková, že $h_0(U_1)$ je jednoprvková 
množina. \newline 
Nech\v t $U_2$ je největší podmnožina $U_1$ vzhledem k počtu 
prvků taková, že $h_1(U_2)$ je jednoprvková 
množina. \newline 
Nech\v t $U_3$ je největší podmnožina $U_2$ vzhledem k počtu 
prvků taková, že $h_2(U_3)$ je jednoprvková 
množina. \newline 
Obecně, nech\v t $U_i$ je největší podmnožina $U_{
i-1}$ vzhledem k počtu 
prvků taková, že $h_{i-1}(U_i)$ je jednoprvková 
množina. 

Protože hašujeme do tabulky velikosti $m$, platí 
$|U_i|\ge\lceil\frac {|U_{i-1}|}m\rceil$. Protože $|U_0|=N$, dostáváme indukcí, že 
$|U_i|\ge\lceil\frac N{m^i}\rceil$ pro každé $i$. Zvolme $i=
\lceil\log_mN\rceil -1$. Pak $i$ je 
největší přirozené číslo takové, že $\frac 
N{m^i}>1$. Tedy $U_i$ má 
aspoň dva prvky, zvolme $x,y\in U_i$ taková, že $x\ne y$. Pak 
$h_j(x)=h_j(y)$ pro $j=0,1,\dots,i-1$. Tedy 
$$i\le |\{j\in I\mid h_j(x)=h_j(y)\}|\le\frac {c|I|}m.$$

\proclaim{Věta}Když $H=\{h_i\mid i\in I\}$ je $c$-univerzální systém pro 
univerzum $U$ o velikosti $N$ hašující do tabulky s $m$ řádky, pak 
$$|I|\ge\frac mc(\lceil\log_mN\rceil -1).$$
Posloupnosti $0$ a $1$ při náhodné volbě $i$ z $I$ musí mít 
délku alespoň $\lceil (\log m-\log c+\log\log N-\log\log m)\rceil$ (zde všechny logaritmy 
jsou o základu $2$).
\endproclaim

\subsection{
Malý univerzální systém
}

Zkonstruujeme $c$-univerzální systém takový, 
že logaritmus z velikosti jeho indexové množiny pro velká 
univerza je až na aditivní konstantu menší než 
$4(\log m+\log\log N)$, kde $N$ je velikost univerza a $m$ je počet 
řádků v tabulce.  

Nech\v t $p_1,p_2,\dots$ je rostoucí posloupnost všech 
prvočísel. Měj\-me velikost tabulky $m$ a univerzum $U=
\{0,1,\dots,N-1\}$ pro 
nějaké přirozené číslo $N$ (nemusí být prvočíslo). Nech\v t $
t$ je 
nejmenší číslo takové, že $t\ln p_t\ge m\ln N$. Definujme 
$$H_1=\{g_{c,d}(h_{\ell})\mid t<\ell\le 2t,\,c,d\in \{0,1,\dots,p_{
2t}-1\}\},$$
kde $h_{\ell}(x)=x\bmod p_{\ell}$ a 
$g_{c,d}(x)=((cx+d)\bmod p_{2t})\bmod m$.\newline 
Ukážeme, že když $m(\ln m+\ln\ln m)<N$, pak $H_1$ je $
3.25$-univerzální systém. 

Nejprve si připomeneme známou větu o velikosti prvočísel 
(zde $\ln$ je přirozený logaritmus, tj. o základu $e$).

\proclaim{Věta}Pro každé $i=1,2,\dots$ platí $p_i>i\ln 
i$ a pro $i\ge 6$ 
platí $p_i<i(\ln i+\ln\ln i)$. \qed
\endproclaim

Tedy pro $i\ge 6$ platí $p_i<2i\ln i$.

Velikost indexové množiny $H_1$.  Indexová množina $
H_1$ je 
$$I=\{(c,d,\ell )\mid c,d\in \{0,1,\dots,p_{2t}-1,\,t<\ell\le 2t\}
.$$
  
Tedy $|I|=tp_{2t}^2$.   
Odtud plyne $|I|\le 16t^3\ln^22t$ a tedy 
$$\log(|I|)\le 4+3\log t+2\log\log t.$$
Pro dostatečně velké $t$ (takové, že $\log t\ge 2\log\log 
t$, tj. $t\ge 16$) platí, 
že $\log(|I|)\le 4+4\log t$.  Z definice $t$ plyne, 
že $t\le m\ln N$, když $\ln p_t\ge 1$ (tj.  $p_t\ge 3$).\newline 
Závěr: $\log(|I|)\le 4+4(\log m+\log\log N)$. 

\subsection{
Univerzalita malého systému
}

Zvolme různá $x$ a $y$ z univerza $U$. 
Označme
$$\align G_1&=\{(c,d,\ell )\mid g_{c,d}(h_{\ell}(x))=g_{c,d}(h_{\ell}
(y)),\,h_{\ell}(x)\ne h_{\ell}(y)\},\\
G_2&=\{(c,d,\ell )\mid g_{c,d}(h_{\ell}(x))=g_{c,d}(h_{\ell}(y)),\,
h_{\ell}(x)=h_{\ell}(y)\}\endalign$$
a odhadneme velikost $G_1$ a $G_2$. 

Odhad velikosti $G_1$. Když $(c,d,\ell )\in G_1$, pak 
existují $r,s\in \{0,1,\dots,\lceil\frac {p_{2t}}m\rceil -1\}$ a $
i\in \{0,1,\dots,m-1\}$ 
taková, že 
$$\align(c(x\bmod p_{\ell})+d&\equiv i+rm)\bmod p_{2t}\\
(c(y\bmod p_{\ell})+d&\equiv i+sm)\bmod p_{2t}.\endalign$$
Když $c$ a $d$ považujeme za neznámé, pak je to  
soustava lineár\-ních rovnic s regulární maticí (protože 
$x\bmod p_{\ell}\ne y\bmod p_{\ell}$), a tedy pro každé $\ell$, $
i$, $r$ a $s$ 
existuje právě jedna taková dvojice $(c,d)$ (připomínáme, že $\Bbb Z/\bmod p_{2t}$ je těleso). Proto 
$$|G_1|\le tm(\lceil\frac {p_{2t}}m\rceil )^2\le\frac {tp_{2t}^2}
m(1+\frac m{p_{2t}})^2=\frac {|I|}m(1+\frac m{p_{2t}})^2.$$

Odhad velikosti $G_2$. Označme 
$L=\{\ell\mid t<\ell\le 2t,\,x\bmod p_{\ell}=y\bmod p_{\ell}\}$ a $
P=\prod_{\ell\in L}p_{\ell}$. 
Protože $P$ dělí $|x-y|$, dostáváme, že $P\le N$. Protože 
$p_t<p_{\ell}$ pro každé $\ell\in L$, dostáváme, že $
P>p_t^{|L|}$. Tedy 
$|L|\le\frac {\ln N}{\ln p_t}\le\frac tm$ z definice $t$. Protože $
(c,d,\ell )\in G_2$, právě 
když $\ell\in L$ a $c,d\in \{0,1,\dots,p_{2t}-1\}$, shrneme, že 
$$|G_2|\le |L|p_{2t}^2\le\frac {tp_{2t}^2}m=\frac {|I|}m.$$

Abychom odhadli $(1+\frac m{p_{2t}})^2$, ukážeme si nejdřív 
pomocné lem\-ma.

\proclaim{Lemma}Když $t\ge 6$ a $m(\ln m+\ln\ln m)<N$, pak $m<\frac {
p_t}{\ln t}$.
\endproclaim

\demo{Důkaz}Předpokládejme, že tvrzení neplatí. Pak $
m\ge\frac {p_t}{\ln t}$. Z Věty o velikosti 
prvo\-čí\-sel plyne $m\ge\frac {p_t}{\ln t}>\frac {t\ln 
t}{\ln t}=t$. Když použijeme, že 
$m(\ln m+\ln\ln m)<N$, tak dostaneme, že 
$$\ln m+\ln(\ln m+\ln\ln m)<\ln N,$$
a odtud plyne, že 
$$t\ln p_t<t\ln(t(\ln t+\ln\ln t))\le m(\ln m+\ln(\ln m+\ln\ln m)
)<m\ln N$$
a to je spor s definicí $t$. Tedy $m<\frac {p_t}{\ln t}$. \qed
\enddemo

Nyní zkombinujeme Větu o odhadu velikosti prvočísel, 
před\-cho\-zí Lemma a fakt, že 
$$\ln2t\ge\ln t\ge\ln\ln t\qquad\text{pro všechna }t\ge 1$$
a dostaneme, že
$$\frac m{p_{2t}}\le\frac {\frac {p_t}{\ln t}}{2t\ln2t}<\frac {t(\ln 
t+\ln\ln t)}{2t\ln t\ln2t}<\frac 1{\ln2t}(1+\frac {\ln\ln t}{\ln 
t}).$$
Je zřejmé, že tento výraz je menší než $\frac 
12$, 
a když $t$ konverguje k $+\infty$, pak tento výraz konverguje k $
0$.

Z toho plyne, že $(1+\frac m{p_{2t}})^2\le 1.5^2=2.2
5$, a tedy 
$$\align|\{i\in I&\mid h_i(x)=h_i(y)\}|=|G_1|+|G_2|\le\\
&\frac {|I|}m(1+\frac m{p_{2t}})^2+\frac {|I|}m\le\frac {|I|}m(1+
2.25)=3.25\frac {|I|}m.\endalign$$

Shrnutí: Když $t\ge 6$ a $m\ln m\ln\ln m<N$, pak $
H_1$ je 
$3.25$-univerzální. Bez jakýchkoliv předpokladů lze 
ukázat, že $H_1$ je $5$-univerzální.

\subsection{
Odhad na velikost $c$
}

\proclaim{Věta}Když $H$ je $c$-univerzální 
systém univerza $U$ o velikosti $N$ hašující do tabulky s $
m$ řádky, 
pak $c\ge 1-\frac mN$.
\endproclaim

Nejprve dokážeme technické lemma.

\proclaim{Lemma}Mějme reálná čísla $b_i$ pro $i=0,1
,\dots,m-1$ a 
nech\v t $b=\sum_{i=0}^{m-1}b_i$. Pak 
$$\sum_{i=0}^{m-1}b_i(b_i-1)\ge b(\frac bm-1).$$
\endproclaim

\demo{Důkaz lemmatu}Z Cauchyho-Schwarzovy nerovnosti 
$$(\sum_{i=0}^{m-1}x_iy_i)^2\le (\sum_{i=0}^{m-1}x^2_i)(\sum_{i=0}^{
m-1}y_i^2)$$
plyne $(\sum_{i=0}^{m-1}b_i)^2=b^2\le m(\sum_{i=0}^{m-1}b_i^2)$, stačí položit 
$x_i=b_i$ a $y_i=1$, a tedy $\frac {b^2}m\le\sum_{i=0}^{m-1}b_i^2$. Odtud
$$\sum_{i=0}^{m-1}b_i(b_i-1)=\sum_{i=0}^{m-1}b_i^2-\sum_{i=0}^{m-
1}b_i=\sum_{i=0}^{m-1}b_i^2-b\ge\frac {b^2}m-b=b(\frac bm-1)$$
a lemma je dokázáno. \qed
\enddemo

\demo{Důkaz Věty}Mějme funkci $f:U@>>>T$, kde $U$ má 
velikost $N$ a $T$ má velikost $m$. Označme $A$ množinu 
uspořádaných dvojic $u,v\in U$ takových, že $u\ne v$ a $
f(u)=f(v)$.
Když pro $t\in T$ označíme $k_t=|f^{-1}(t)|$, pak $|A|=
\sum_{t\in T}k_t(k_t-1)$.
Z lemmatu plyne, že 
$$|A|=\sum_{t\in T}k_t(k_t-1)\ge N(\frac Nm-1)=N(\frac {N-m}m),$$
protože $\sum_{t\in T}k_t=N$.\newline 
Když $H=\{h_i\mid i\in I\}$ je $c$-univerzální systém funkcí z univerza $
U$ o 
velikosti $N$ do tabulky o velikosti $m$, pak pomocí 
lemmatu dostáváme 
$$\align&|I|N(\frac {N-m}m)\le\\
&\sum_{i\in I}|\{(x,y)\in U\times U\mid h_i(x)=h_i(y),\,x\ne y\}|
=\\
&\sum_{(x,y)\in U\times U,\,x\ne y}|\{i\in I\mid h_i(x)=h_i(y)\}|
\le\\
&\sum_{(x,y)\in U\times U,x\ne y}c\frac {|I|}m=N(N-1)c\frac {|I|}
m.\endalign$$
Odtud plyne, že $N-m\le c(N-1)$, a tedy 
$$c\ge\frac {N-m}{N-1}>\frac {N-m}N=1-\frac mN.\qed$$
\enddemo

\subsection{
Problémy univerzálního hašování
}

Použít jiné metody na řešení kolizí než 
separované řetězce. Jak to ovlivní použitelnost 
univerzálního hašování? Platí podobné vztahy jako pro 
pevně danou hašovací funkci? Jaký vliv na efektivnost 
má nepřítomnost operace {\bf DELETE}?

Existuje $c$-univerzální hašovací systém pro 
$c<1$? Jaký je vztah mezi velikostí $c$-univerzální\-ho 
hašovacího systému a velikostí $c$? Lze zkonstruovat 
malý $c$-univerzální systém pro $c<3.25$? Zde hraje roli 
fakt, že při $c=3.25$ se očekávaná délka řetězce 
může pohybovat až kolem hodnoty $7$.

Použití \v Cebyševovy nerovnosti místo 
Markovovy nerovnosti dává kvadratický odhad 
prav\-dě\-podobnosti, že délka řetězce je o $t$ větší než 
očekávaná hodnota. Za jakých okolností dává lepší 
odhad? Lze použít i vyšších momentů?

Jak použít Markovou nerovnost a očekávanou 
délku maximál\-ní\-ho řetězce pro odhad očeká\-va\-ného 
počtu voleb hašovací funk\-ce? 
Pro jaké parametry lze použít následující model?

Je dána základní velikost tabulky $m$ a dále pro $
j=0,1,\dots$ 
čísla (parametry) $l_j$ a $c$-univer\-zál\-ní hašovací systémy 
$H_j=\{h_i\mid i\in I_j\}$ z univerza do tabulky s $m2^j$ řádky.\newline 
Množina $S\subseteq U$ je reprezentována následovně:  je dáno $
j$ 
tako\-vé, že když $j>0$, pak $m2^{j-2}\le |S|\le m2^j$, když $
j=0$, pak 
$|S|\le m$, a je zvolen index $i\in I_j$.  Dále máme prosté řetězce 
$r_0,r_1,\dots,r_{m2^j-1}$, jejichž délky jsou nejvýše $
l_j$, a řetězec $r_k$ 
obsahuje prvky $\{s\in S\mid h_i(s)=k\}$.\newline 
Operace {\bf INSERT$(x)$} prohledá řetězec $r_{h_i(x)}$ a když tento 
ře\-tě\-zec neobsahuje prvek $x$, pak ho přidá.  Když 
$m2^{j-2}\le |S|\le m2^j$ a délka řetězce $r_{h_i}(x)$ je nejvýše $
l_j$, pak 
operace končí.  Když $|S|>m2^j$, tak se nejdříve zvětší $
j$ o $1$.  
Pak se náhodně zvolí $i\in I_j$ a zkonstruují se řetězce 
reprezentující $S$.  Když některý z nich má délku větší než $
l_j$, 
tak se volba a konstrukce řetězců opakuje tak dlouho, 
dokud se nepovede zvolit $i\in I_j$ takové, že všechny 
zkonstruované řetězce mají délku nejvýše $l_j$.  Operace {\bf DELETE }
se řeší analogicky.\newline 
Problém:  Jak volit parametry $l_i$?  

V případě řešení 
kolizí dvojitým hašováním nebo hašováním s 
lineárním přidáváním je třeba dát silnější podmínky na velikost $
|S|$. V poslední době se této tématice 
věnuje pozornost a byla dosažena řada zajímavých výsledků.

\section{Perfektní hašování}

Jiné řešení kolizí je perfektní hašování. Idea 
je nalézt pro danou množinu hašovací funkci, která 
nevytváří kolize.

Nevýhoda: Metoda nepřipouští operaci {\bf INSERT }
(pro nový vstup nemůžeme zaručit, že nevznikne  
kolize). Metodu lze prakticky použít pro úlohy, kde lze 
očekávat hodně operací {\bf MEMBER} a operace {\bf INSERT} se 
téměř nevyskytuje (kolize se řeší pomocí malé pomocné 
tabulky, kam se ukládají kolidují\-cí data). Tato metoda se 
používá při navrhování kompilátorů.

Zadání úlohy: Pro danou množinu $S\subseteq 
U$ chceme 
nalézt hašo\-va\-cí funkci $h$ takovou, že
\roster
\item
pro $s,t\in S$ takové, že $s\ne t$, platí $h(s)\ne h(t)$ (tj. $
h$ je \emph{perfektní} \emph{hašovací} \emph{funkce} pro 
$S$); 
\item
$h$ hašuje do tabulky s $m$ řádky, kde $m$ je přibližně 
stejně velké jako $|S|$ (není praktické hašovat do příliš 
velkých tabulek -- ztrácí se jeden ze základních 
důvodů pro hašování); 
\item
$h$ musí být rychle spočitatelná -- jinak hašování 
není rychlé;
\item
uložení $h$ nesmí vyžadovat moc paměti, 
nejvýhodnější je ana\-lytické zadání (když zadání $
h$ bude 
vyžadovat moc paměti, např. když by byla dána tabulkou, 
pak se ztrácí důvod k použití stejně jako v 
bodě 2).
\endroster

Kompenzace: Nalezení hašovací funkce 
může spotřebovat více času. Provádí se jen na 
začátku úlohy. 

Uvedené požadavky motivují zavedení 
následujícího pojmu.\newline 
Mějme univerzum $U=\{0,1,\dots,N-1\}$. Soubor funkcí $H$ z 
$U$ do množiny $\{0,1,\dots,m-1\}$ se nazývá 
$(N,m,n)$-\emph{perfektní}, když pro každou $S\subseteq 
U$ 
takovou, že $|S|=n$, existuje $h\in H$ perfektní pro $S$ (tj. 
$h(s)\ne h(t)$ pro každá dvě různá $s,t\in S$).

Protože nevíme, zda taková $h$ existují, nejprve 
vyšetříme mno\-ži\-ny perfektních hašovacích 
funkcí. Vyšetříme vlastnosti $(N,m,n)$-perfektních 
souborů funkcí.

\subsection{
Dolní odhady na velikost $(N,m,n)$-perfektního souboru
}

Předpokládejme, že $H$  je $(N,m,n)$-perfektní 
systém pro $U=\{0,1,\dots,N-1\}$ a nejprve nalezneme dolní 
odhady na velikost $|H|$.

Mějme funkci $h$ z $U$ do množiny $\{0,1,\dots,m-
1\}$. 
Nalezneme počet množin $S\subseteq U$ takových, že  
$h$ je perfektní funkce pro $S$ a $|S|=n$. Funkce $h$ je perfektní pro 
$S\subseteq U$, právě když pro každé $i=0,1,\dots,m-
1$ je 
$|h^{-1}(i)\cap S|\le 1$. Odtud počet těchto množin je
$$\sum \{\prod_{j=0}^{n-1}|h^{-1}(i_j)|\mid 0\le i_0<i_1<\dots<i_{
n-1}<m\}.$$

Vysvětlení: $h(S)=\{i_j\mid j=0,1,\dots,n-1\}$.

Toto číslo je maximální, když $|h^{-1}(
i)|=\frac Nm$ pro každé $i$. 
Tedy $h$ může být perfektní nejvýše pro $\binom 
mn(\frac Nm)^n$ 
množin (číslo $\binom mn$ určuje počet posloupností 
$0\le i_0<i_1<\dots<i_{n-1}<m$). Protože $n$-prvkových 
podmnožin universa je $\binom Nn$, dostáváme, že 
$$|H|\ge\frac {\binom Nn}{\binom mn(\frac Nm)^n}.$$

Jiný odhad velikosti $(N,m,n)$-perfektního souboru.

Předpokládejme, že $H=\{h_1,\dots,h_t\}$ je 
$(N,m,n)$-perfektní soubor funkcí.  Definujme indukcí 
soubor množin $U_i$:\newline 
$U_0=U$ a pro 
$i>0$ je $U_i$ největší podmnožina $U_{i-1}$, co do počtu 
prvků, 
taková, že $h_i$ je konstantní na $U_i$.  Pak $|U_i|\ge\frac {
|U_{i-1}|}m$ 
pro všechna $i>0$.  Z $|U_0|=N$ plyne $|U_i|\ge\frac N{m^i}$.  Pro každé 
$i=1,2,\dots,t$ je $h_j(U_i)$ jednobodová množina pro každé 
$j\le i$.  Proto žádná $h_j$ pro $j\le i$ není perfektní pro 
množinu $S\subseteq U$ takovou, že $|S\cap U_i|\ge 2$.  Protože $
H$ je 
$(N,m,n)$-perfektní, musí být $|U_t|\le 1$, a tedy $\frac 
N{m^t}\le 1$.  Proto 
$t\ge\frac {\log N}{\log m}$.    

\proclaim{Věta}Když $H$ je $(N,m,n)$-perfektní soubor 
funkcí, pak 
$$|H|\ge\max\{\frac {\binom Nn}{\binom mn(\frac Nm)^n},\frac {\log 
N}{\log m}\}.$$
\endproclaim

\subsection{
Existence $(N,m,n)$-perfektního souboru
}

Mějme univerzum $U=\{0,1,\dots,N-1\}$ a soubor 
funkcí $H=\{h_1,h_2,\dots,h_t\}$ z univerza $U$ do množiny 
$\{0,1,\dots,m-1\}$.  Reprezentujeme tento soubor pomocí 
matice $M(H)$ typu $N\times t$ s hodnotami $\{0,1,\dots,m-1\}$ tak, 
že pro $x\in U$ a $i=1,2,\dots,t$ je 
v $x$-tém řádku a $i$-tém sloupci matice $M(H)$ 
hodnota $h_i(x)$. Pak žádná funkce z $H$ 
není perfektní pro množinu $S=\{s_1,s_2,\dots,s_n\}\subseteq 
U$, 
právě když podmatice $M(H)$ tvoře\-ná 
řádky $s_1$, $s_2$, až $s_n$ a všemi sloupci nemá prostý sloupec. 
Ta\-ko\-vých matic je nejvýše 
$$(m^n-\prod_{i=0}^{n-1}(m-i))^tm^{(N-n)t}.$$

Vysvětlení:  $m^n$ je počet všech funkcí z $
S$ do 
$\{0,1,\dots,m-1\}$, $\prod_{i=0}^{n-1}(m-i)$ je počet prostých funkcí z $
S$ 
do $\{0,1,\dots,m-1\}$, a tedy počet všech podmatic s $n$ 
řádky takových, že žádný jejich sloupec není prostý, je 
$(m^n-\prod_{i=0}^{n-1}(m-i))^t$.  Tyto podmatice můžeme 
libovolně doplnit na matici typu $N\times n$ a pro každou 
matici je těchto doplnění $m^{(N-n)t}$.  

Podmnožin $U$ velikosti $n$ je $\binom Nn$, tedy počet všech 
matic, které nereprezentují $(N,m,n)$-perfektní systém, je 
menší nebo roven  
$$\binom Nn(m^n-\prod_{i=0}^{n-1}(m-i))^tm^{(N-n)t}.$$

Všech matic je $m^{Nt}$ a když 
$$\binom Nn(m^n-\prod_{i=0}^{n-1}(m-i))^tm^{(N-n)t}<m^{Nt},\tag *$$

pak nutně existuje $(N,m,n)$-perfektní systém. 
Následující vý\-ra\-zy jsou ekvivalentní s ne\-rov\-ností 
\thetag{$*$}
$$\binom Nn\big(1-\frac {\prod_{i=0}^{n-1}(m-i)}{m^n}\big)^t<1\,\Leftrightarrow\,
t\ge\frac {\ln\binom Nn}{-\ln(1-\frac {\prod_{i=0}^{n-1}(m-i)}{m^
n})}.$$
Protože $\ln\binom Nn\le n\ln N$ a protože $-\ln(1-x)\ge x$ pro $
x\in (0,1)$, dostáváme
$$\align-\ln(1-\frac {\prod_{i=0}^{n-1}(m-i)}{m^n})\ge&\prod_{i=0}^{
n-1}(1-\frac im)=e^{\sum_{i=0}^{n-1}\ln(1-\frac im)}\ge\\
&e^{\int_0^n\ln(1-\frac xm)dx},\endalign$$
kde integrál můžeme odhadnout 
$$m[(1-\frac nm)(1-\ln(1-\frac nm))-1]\ge m[(1-\frac nm)(1+\frac 
nm)-1]=-\frac {n^2}m.$$
Odtud dostáváme, že když $t\ge n(\ln N)e^{\frac {n^2}m}$, pak \thetag{*} platí, a tedy 
existuje $(N,m,n)$-perfektní soubor funkcí. 

Existence $(N,m,n)$-perfektního souboru funkcí ale 
nezaručuje splnění požadavků 2), 3) a 4).  
Abychom uspěli, použijeme ideu z metody univerzálního 
hašování.  

\subsection{
Konstrukce perfektní hašovací funkce
}

Předpoklady:  $U=\{0,1,\dots,N-1\}$, kde $N$ je 
prvočíslo.  Mějme $S\subseteq U$ o velikosti $n$.  Budeme 
uvažovat funkce 
$$h_k(x)=(kx\bmod N)\bmod m\qquad\text{\rm\ pro }k=1,2,\dots,N-1.$$
Pro $i=0,1,\dots,m-1$ a $k=1,2,\dots,N-1$ označme 
$$b_i^k=|\{x\in S\mid (kx\bmod N)\bmod m=i\}|.$$

Význam $b_i^k$: Hodnoty $b_i^k$ lze považovat za 
veličiny, které ukazují odchylku od perfektnosti. 
Všimněme si, že 
$$\text{\rm když }b_i^k\ge 2,\text{\rm\ pak }(b_i^k)^2-b_i^k\ge 
2,$$

protože $a^2-a\ge 2$, když $a\ge 2$. Na druhou stranu 
$$b_i^k\le 1\text{\rm\ implikuje }(b_i^k)^2-b_i^k=0.$$

Tedy z $\sum_{i=0}^{m-1}b_i^k=n$ plyne 

\proclaim{Věta}Funkce $h_k$ je perfektní, právě když 
$\sum_{i=0}^{m-1}(b_i^k)^2-n<2$.
\endproclaim

Nyní odhadneme výraz $\sum_{k=1}^{N-1}\big((\sum_{
i=0}^{m-1}(b_i^k)^2)-n\big)$.
$$\align\sum_{k=1}^{N-1}\big(&(\sum_{i=0}^{m-1}(b_i^k)^2)-n\big)=\\
&\sum_{k=1}^{N-1}\big((\sum_{i=0}^{m-1}|\{x\in S\mid h_k(x)=i\}|^
2)-n\big)=\\
&\sum_{k=1}^{N-1}|\{(x,y)\mid x,y\in S,\,x\ne y,\,h_k(x)=h_k(y)\}
|=\\
&\sum_{x,y\in S,x\ne y}|\{k\mid 1\le k<N,\,h_k(x)=h_k(y)\}|.\endalign$$
Zvolme $x,y\in S$ taková, že $x\ne y$. Pak $h_k(x)=h_k(y)$, 
právě když existuje $i=0,1,\dots,m-1$ a $r,s=0,1,\dots,\lfloor\frac 
Nm\rfloor$ 
taková, že $kx\equiv i+rm\bmod N$ a $ky\equiv i+sm\bmod N$ a $
i+rm,i+sm<N$. Odtud dostáváme, že $h_k(x)=h_k(y)$ implikuje $
kx-ky\equiv (r-s)m\bmod N$.
Protože $0<k<n$ a $x\ne y$, dostáváme, že $kx-ky\ne 0$, a tedy 
$h_k(x)=h_k(y)$ implikuje existenci 
$q=-\lfloor\frac Nm\rfloor ,-\lfloor\frac Nm\rfloor +1,\dots,-1,1
,2,\dots,\lfloor\frac Nm\rfloor$ takového, že 
$kx-ky\equiv qm\bmod N$,
a to je 
ekvivalentní s tím, že $k(x-y)\equiv qm\bmod N$ pro nějaké 
$q=-\lfloor\frac Nm\rfloor ,-\lfloor\frac Nm\rfloor +1,\dots,-1,1
,2,\dots,\lfloor\frac Nm\rfloor$.

Pro $x>y$ a pro jedno $q=0,1,\dots,\lfloor\frac Nm\rfloor$ e\-xis\-tuje 
právě jedno $k$ takové, že $k(x-y)\equiv qm\bmod N$, protože 
$\Bbb Z_N$ je těleso (tato rovnice má jediné řešení). 
Protože pro $q=-\lfloor\frac Nm\rfloor ,\dots,-1,0$ je rovnice $
k(x-y)\equiv qm\bmod N$ 
ekvivalentní s rovnicí $k(x-y)\equiv N+qm\bmod N$, tak 
dostáváme, že pro $x,y\in S$, $x>y$, existuje nejvýše 
$2\lfloor\frac Nm\rfloor =2\lfloor\frac {N-1}m\rfloor$ různých $
k=1,2,\dots,N-1$, že $h_k(x)=h_k(y)$ (obecně není pravda, že když 
$k$ splňuje rovnici $k(x-y)\equiv qm\bmod N$ pro nějaké 
$q=-\lfloor\frac Nm\rfloor ,\dots,-1,1,\dots,\lfloor\frac Nm\rfloor$, 
pak $h_k(x)=h_k(y)$). Stejný odhad analogicky dostaneme, když $
x<y$ 
(ale dostáváme jiná řešení). Odtud 
$$\sum_{k=1}^{N-1}\big((\sum_{i=0}^{m-1}(b_i^k)^2)-n\big)\le\sum_{
x,y\in S,x\ne y}2(\frac {N-1}m)=2(N-1)\frac {n(n-1)}m.$$

Tedy existuje $k$ takové, že $\sum_{i=0}^{m-1}(b_i^
k)^2\le 2\frac {n(n-1)}m+n$. 

Ukážeme, že existuje více než $\frac {N-
1}4$ takových 
$k$, že platí
$$\sum_{i=0}^{m-1}(b_i^k)^2<3\frac {n(n-1)}m+n.$$
V opačném případě dostáváme, že 
$$\align\sum_{k=1}^{N-1}\big((\sum_{i=0}^{m-1}(b_i^k)^2)-n\big)\ge&\frac {
3(N-1)}4\frac {3n(n-1)}m=\\
&\frac {9(N-1)n(n-1)}{4m}>\\
&\frac {2(N-1)n(n-1)}m,\endalign$$
a to je spor s předchozím výsledkem. Tedy při náhodném rovnoměrném 
výběru $k$ je 
$$\Prob\{\sum_{i=0}^{m-1}(b_i^k)^2<\frac {3n(n-1)}m+n\mid k\in \{
1,2,\dots,N-1\}\}\ge\frac 14.$$

\proclaim{Tvrzení}Když $n=m$, pak 
\roster
\item"{(a)}"
existuje deterministický algoritmus, jenž v čase $O(nN)$ 
nalezne $k$ takové, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2<3n;$$
\item"{(b)}"
existuje pravděpodobnostní algoritmus, který 
nalezne v čase $O(n)$ takové $k$, že $\sum_{i=0}^{m-1}(b_
i^k)^2<4n$ -- očekávaný počet iterací výpočtu je nejvýše $
4$.
\endroster
Dále 
\roster
\item"{(c)}"
existuje deterministický algoritmus, jenž v čase $O(nN)$ pro 
$m=n(n-1)+1$ nalezne takové $k$, že $h_k$ je 
perfektní;
\item"{(d)}"
existuje pravděpodobnostní algoritmus, který pro 
$m=2n(n-1)$ v čase $O(n)$ nalezne $k$ takové, že $h_k$ je 
perfektní -- očekávaný počet iterací výpočtu 
je nejvýše $4$.
\endroster
\endproclaim

\demo{Důkaz}Mějme $n=m$. Protože spočítání 
$\sum_{i=0}^{m-1}(b_i^k)^2$ pro pevné $k$ vyžaduje čas $O
(n)$, prohledáním 
všech možností nalez\-ne\-me $k$ takové, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2\le\frac {2n(n-1)}n+n=3n-2<3n,$$
v čase $O(nN)$. Tím je 
dokázáno a). Pravděpodobnostní algoritmus dokazující b) volí 
náhodně $k$ a v čase $O(n)$ ověří, zda 
$\sum_{i=0}^{m-1}(b_i^k)^2\le 3\frac {n(n-1)}n+n=4n-3<4n$. Tuto akci opakuje, dokud 
požadavek není splněn. Protože pravděpodobnost, že $
k$ splňuje 
požadavek, je alespoň $\frac 14$, tak očekávaný počet ite\-rací 
akce je nejvýše 
$$\sum_{i=0}^{\infty}i(\frac 34)^{i-1}\frac 14=\frac 14\frac 1{(1
-\frac 34)^2}=4$$
a odtud plyne b). 

Když $m=n(n-1)+1$, pak prohledáním všech možností 
nalezne\-me $k$ takové, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2\le\frac {2n(n-1)}{n(n-1)+1}+n<n+2,$$
 v 
čase $O(nN)$ a c) plyne z předchozí věty. Když 
$m=2n(n-1)$, pak pro náhodně zvolené $k$ platí s 
pravděpodobností $\le\frac 14$, že 
$$\sum_{i=0}^{m-1}(b_i^k)^2\le\frac {3n(n-1)}{2n(n-1)}+n<n+2.$$
Algoritmus splňující tvrzení d) je stejný jako 
v případě b) (jen $m=2n(n-1)$). \qed
\enddemo

Takto zkonstruované perfektní hašovací funkce 
nesplňují poža\-davek 2) (platí $m=\Theta (n^2)$).  Použijeme následující 
postup. 

1) Nalezneme $k$ takové, že pro $m=n$ platí 
$\sum_{i=0}^{m-1}(b_i^k)^2<3n$ (respektive $\sum_{i=0}^{m-1}(b_i^
k)^2<4n$).  Pro 
$i=0,1,\dots,m-1$ nalezneme množiny 
$S_i=\{s\in S\mid h_k(s)=i\}$;\newline 
2) Pro každé $i=0,1\dots,m-1$ takové, že $S_i\ne\emptyset$, 
nalezneme pro $m=1+|S_i|(|S_i|-1)$ (respektive $m=1+2|S_i|(|S_i|-
1)$) 
takové $k_i$, že $h_{k_i}$ je perfektní na $S_i$. Definujme 
$c_i=1+|S_i|(|S_i|-1)$ (respektive $c_i=2|S_i|(|S_i|-1)$), když 
$S_i\ne\emptyset$, a $c_i=0$, když 
$S_i=\emptyset$.\newline 
3) Pro $i=0,1,\dots,m$ definujme $d_i=\sum_{j=0}^{i-1}c_j$ a pro $
x\in U$ 
označme $h_k(x)=l$. Pak položíme $g(x)=d_l+h_{k_l}(x)$.

\proclaim{Věta}Zkonstruovaná funkce $g$ je perfektní, 
hodnota $g(x)$ se pro každé $x\in U$ spočítá v čase $
O(1)$, 
v deterministickém přípa\-dě hašuje do tabulky velikosti 
$<3n$ a je nalezena v čase $O(nN)$, v pravděpodobnostním 
přípa\-dě hašuje do tabulky velikosti $<6n$ a je nalezena 
v čase $O(n)$. Pro její zak\'odování jsou třeba hodnoty $
k$ a 
$k_i$ pro $i=0,1,\dots,m-1$. Tyto hodnoty jsou v rozmezí 
$1,2,\dots,N-1$, a tedy vyžadují $O(n\log N)$ paměti.
\endproclaim

\demo{Důkaz}Protože $g(S_i)$ pro $i=0,1,\dots,m-1$ 
jsou navzájem disjunktní a $h_{k_i}$ je perfektní na $S_
i$, 
dostáváme, že $g$ je perfektní. Pro výpočet hodnoty $
g(x)$ 
jsou třeba dvě násobení, dvojí výpočet zbytku při 
dělení a jedno sčítání (hodnoty $d_i$ jsou uloženy v 
paměti). Proto výpočet $g(x)$ vyžaduje čas $O(1)$. Dále 
$d_m$ je horní odhad na počet řádků v tabulce. 
Protože pro $S_i\ne\emptyset$ máme $|S_i|(|S_i|-1)+1\le |S_
i|^2=(b_i^k)^2$, 
dostáváme v deterministickém případě 
$d_m=\sum_{i=0}^{m-1}c_i\le\sum_{i=0}^{m-1}(b_i^k)^2<3n$ a $k$ nalezneme v čase 
$O(nN)$. Protože $k_i$ nalezneme v čase $O(|S_i|N)$, lze $g$ 
zkonstruovat v čase 
$O(nN+\sum_{i=0}^{m-1}|S_i|N)=O(nN+N\sum_{i=0}^{m-1}|S_i|)=O(2nN)
=O(nN)$. 
V pravděpodob\-nostním případě je 
$$d_m=\sum_{i=0}^{m-1}c_i\le\sum_{i=0}^{m-1}(2|S_i|^2-2|S_i|)=2\sum_{
i=0}^{m-1}(b_i^k)^2-2\sum_{i=0}^{m-1}b_i^k<8n-2n=6n$$
(protože $|S_i|=b_i^k$ a $\sum_{i=0}^{m-1}b_i^k=n$). Protože $
k$ nalezneme v čase $O(n)$ a $k_i$ v čase $O(|S_i|)$, dostaneme, že 
že $g$ nalezneme v čase $O(n)$. Zbytek je jasný. \qed
\enddemo

Tedy zkonstruovaná hašovací funkce splňuje požadavky 
1), 2) a 3), ale požadavek 4) není splněn. 

Mějme přirozené číslo $m$ a nech\v t $q$ je počet všech prvočísel 
dělících $m$ ($p_1,p_2,\dots$ je rostoucí posloupnost všech 
prvočísel). Pak
$$m\ge\prod_{i=1}^qp_i>q!=e^{\sum_{i=1}^q\ln i}\ge e^{\int_1^q\ln 
xdx}=e^{q\ln(\frac qe)+1}\ge (\frac qe)^q.$$
Proto existuje konstanta $c$, že $q\le c\frac {\ln m}{\ln\ln m}$ (viz Lemma v odstavci Očekávaný 
nejhorší případ na stránce 6). Platí tedy  
\proclaim{Věta}Nech\v t $\delta (m)=$počet prvočísel, která dělí 
$m$. Pak $\delta (m)=O(\frac {\log m}{\log\log m})$.
\endproclaim

Mějme $S=\{s_1<s_2<\dots<s_n\}\subseteq U$. Označme 
$d_{i,j}=s_j-s_i$ pro $1\le i<j\le n$. Pak $s_i\bmod p\ne s_j\bmod 
p$, 
právě když $d_{i,j}\ne 0\bmod p$. Označme 
$D=\prod_{1\le i<j\le n}d_{i,j}\le N^{(n^2)}$. Pak počet prvočíselných 
dělitelů čísla $D$ je nejvýše $c\frac {\ln 
D}{\ln\ln D}$, a tedy mezi 
prvními $1+c\frac {\ln D}{\ln\ln D}$ prvočísly existuje prvočíslo $
p$ 
takové, že $s_i\bmod p\ne s_j\bmod p$ pro každé $1\le i
<j\le n$. 
To znamená, že funkce $\phi_p(x)=x\bmod p$ je perfektní pro 
$S$. Podle věty o velikosti prvočísel $p_t\le 2t\ln t$ pro každé $
t\ge 6$, tedy
$$\align p\le&2(1+c\frac {\ln D}{\ln\ln D})\ln(1+c\frac {\ln D}{\ln\ln 
D})\le\\
&4c\frac {\ln D}{\ln\ln D}\ln(2c\frac {\ln D}{\ln\ln D})\le\\
&4c(\ln2c)\frac {\ln D}{\ln\ln D}+4c\frac {\ln D}{\ln\ln D}\ln(\frac {\ln 
D}{\ln\ln D})=\\
&4c\ln D+o(\ln D)=O(\ln D)=O(n^2\ln N).\endalign$$

\proclaim{Věta}Pro každou $n$-prvkovou množinu $S\subseteq 
U$ 
existuje prvo\-čís\-lo $p$ o velikosti $O(n^2\ln N)$ takové, že 
funkce $\phi_p(x)=x\bmod p$ je perfektní pro $S$.  
\endproclaim

Test, zda funkce $\phi_p(x)=x\bmod p$ je perfektní 
pro $S$, 
vyžaduje čas $O(n\log n)$. Tedy systematické hledání 
nejmenšího $p$, že $\phi_p$ je perfektní pro $S$, vyžaduje čas 
$O(n^3\log n\log N)$. Nejmenší $p$ takové, že $\phi_p$ je perfektní 
pro $S$, 
je prvočíslo. Navrhneme pravděpodob\-nostní algoritmus 
pro nalezení $p$. Pro dostatečně velké $n$ mezi 
prvními $9c\ln D$ čísly je alespoň polovina tako\-vých 
prvočísel $p$, že $\phi_p$ je perfektní pro $S$. Algoritmus pak 
opakuje následující krok, dokud nenalezne perfektní funkci
\roster
\item"{}"
vyberme náhodně číslo $p$ mezi prvními $9cn^2\ln 
N$ 
čísly a otestujme, zda $p$ je prvočíslo a $\phi_p$ je perfektní
\endroster

Odhad očekávaného počtu neúspěšných kroků.\newline 
Náhodně zvolené číslo $p\le 9cn^2\ln N$ je prvočíslo s 
pravděpo\-dob\-ností $\Theta (\frac 1{\ln(9cn^2\ln N)})$ 
(použi\-je\-me Rabin-Millerův pravděpdobnostní algoritmus na testovéní prvočísel) a pro prvočíslo $
p$ je $\phi_p$ 
perfektní s prav\-dě\-po\-dob\-ností $\ge\frac 12$. Tedy náhodně zvolené 
číslo $p\le 9cn^2\ln N$ splňuje test s pravdě\-po\-dob\-ností 
$\Theta (\frac 1{\ln(9cn^2\ln N)})$, a proto očeká\-va\-ný počet neúspěšných 
testů je $O(\ln(9cn^2\ln N))$. Tedy očeká\-vaný čas 
algoritmu je $O(n\log n(\log n+\log\log N))$.

\proclaim{Věta}Pro danou množinu $S\subseteq U$ takovou, že 
$|S|=n$, deterministický algoritmus nalezne prvočíslo 
$p=O(n^2\log N)$ takové, že $\phi_p(x)=x\bmod p$ je perfektní 
pro $S$, a pracuje v čase $O(n^3\log n\log N)$. Pravděpodobnostní 
algoritmus nalezne pr\-vočíslo $p=O(n^2\log N)$ takové, že 
$\phi_p$ je perfektní, v očekáva\-ném čase 
$O(n\log n(\log n+\log\log N))$.
\endproclaim

Deterministický algoritmus nalezne nejmenší prvočíslo s 
po\-ža\-dovanou vlastností.  Prav\-dě\-podobnostní algoritmus 
nalezne prvočíslo, které může být podstatně 
větší, ale jeho velikost je omezena $9cn^2\log N$. 

Nyní navrhneme postup na konstrukci perfektní 
hašovací funk\-ce pro množinu $S\subseteq U$.

\roster
\item
Nalezneme prvočíslo $q_0\in O(n^2\log N)$ takové, že 
$\phi_{q_0}(x)=x\bmod q_0$ je perfektní funkce pro $S$. Položme 
$S_1=\{\phi_{q_0}(s)\mid s\in S\}$.
\item
Nalezneme prvočíslo $q_1$ takové, že 
$n(n-1)<q_1\le 2n(n-1)$. Pak existuje 
$l\in \{1,2,\dots,q_0-1\}$ takové, že $h_l(x)=((lx)\bmod q_0
)\bmod q_1$ 
je perfektní pro $S_1\subseteq \{0,1,\dots,q_0-1\}$. Položme 
$S_2=\{h_l(s)\mid s\in S_1\}$.
\item
Dále zkonstruujme perfektní hašovací funkci 
$g$ pro množinu 
$S_2\subseteq \{0,1,\dots,q_1-1\}$ do tabulky s méně než $
3n$ řádky. 
Položme $f(x)=g(h_l(\phi_{q_0}(x)))$. Konstruovaná hašovací 
funkce je $f$.
\endroster

Výsledek: $f$ je perfektní hašovací funkce pro $
S$, protože 
složení perfektních hašovacích funkcí je zase perfektní 
funkce, a tedy požadavek 1) je splněn. \newline 
$f$ hašuje $S$ do tabulky s méně než $3n$ řádky, a tedy 
splňuje požadavek 2). \newline 
Protože každá z funkcí $g$, $h_l$, $\phi_{q_0}$ se vyčíslí v čase $
O(1)$, 
i vyčíslení funkce $f$ vyžaduje čas $O(1)$ a požadavek 3) je 
splněn.\newline 
Funkce $\phi_{q_0}$ je jednoznačně určena číslem $
q_0\in O(n^2\log N)$. 
Funkce $h_l$ je určena čísly $q_1\in O(n^2)$ a $l\in O(
q_0)$. Funkce $g$ 
je určena $n+1$ čísly velikosti $O(q_1)$. Tedy zadání $
f$ 
vyžaduje pamě\v t o velikosti 
$$O(\log n+\log\log N+n\log n)=O(n\log n+\log\log N).$$
Lze říct, že požadavek 4) je splněn. 

Výpočet $\phi_{q_0}$ vyžaduje čas $O(n^3\log 
n\log N)$. Výpočet $h_l$ 
vyža\-du\-je čas $O(n(n^2\log N))=O(n^3\log N)$ (použité univerzum je 
$\{0,1,\dots,q_0\}$). Výpočet $g$ vyžaduje čas $O(nn^2
)=O(n^3)$ 
(zde univerzum je $\{0,1,\dots,q_1\}$). Celkově 
výpočet $f$ vyžaduje čas $O(n^3\log n\log N)$.

Lze použít i pravděpodobnostní algoritmy pro nalezení 
$g$, $h_l$ a $\phi_{q_0}$. Pak hašujeme do tabulky s méně než $
6n$ 
řádky, ale očekávaný čas pro nalezení $f$ je 
$O(n\log n(\log n+\log\log N))$.


Tuto metodu navrhli Fredman, Koml\'os a Szemerédi.

\subsection{
Univerzální a perfektní hašování
}

Předchozí hlavní konstrukce perfektní hašovací funkce 
vycházela z idejí použitých v univerzálním hašování.  Ukážeme, 
že to není náhodná shoda. Dokážeme, že každý $
c$-univerzální 
systém funkcí umožňuje základní konstrukci perfektní hašovací 
funkce.  Pro každé $m$ nech\v t $\Cal H_m=\{h_i\mid i\in I\}$ je $
c$-univerzální 
systém funkcí hašujících do ta\-bulky velikosti $
m$. Pro 
libovolnou, ale pevnou podmnožinu $S\subseteq U$ o velikosti $
n$ definujme 
$b_j^i=\{s\in S\mid h_i(s)=j\}$ pro každé $j=0,1,\dots,m-1$ a $
i\in I$. Když 
$b^i_j\ge 2$, pak $(b^i_j)^2-b^i_j\ge 2$, a když $b^i_j\le 1$, pak $
(b^i_j)^2-b^i_j=0$. Odtud 
dostáváme přirozené zobecnění důsledku z předchozí 
sekce, které využijeme stejným způsobem jako v 
předchozí sekci:

\proclaim{Důsledek}Když $\sum_{j=0}^{m-1}(b^i_j)^2\ge n+2$, pak $h_i$ není 
perfektní pro $S$, když $\sum_{j=0}^{m-1}(b^i_j)^2<n+2$, pak $h_i$ je perfektní 
hašovací funkce pro $S$.
\endproclaim

Stejně jako v předchozí sekci spočítáme  
$$\align\sum_{i\in I}&\big(\sum_{j=0}^{m-1}(b^i_j)^2-n\big)=\sum_{
i\in I}|\{(s,t)\mid s,t\in S,\,s\ne t,\,h_i(s)=h_i(t)\}|=\\
&\sum_{s,t\in S,s\ne t}|\{i\in I\mid h_i(s)=h_i(t)\}|\le\sum_{s,t
\in S,s\ne t}\frac {c|I|}m=\frac {cn(n-1)|I|}m.\endalign$$

Proto existuje $i\in I$ takové, že $\sum_{j=0}^{m-
1}(b^i_j)^2\le\frac {cn(n-1)}m+n$. Nyní 
spočítáme analogické odhady, které tvoří základ pro 
pravděpodobnostní algoritmus. Mějme kladné číslo $
a>0$ a 
označme $I'$ množinu těch $i\in I,$ že  
$$\sum_{j=0}^{m-1}(b^i_j)^2>\frac {(c+a)n(n-1)}m+n.$$
Dále předpokládejme, že $|I'|\ge b|I|$ pro 
nějaké kladné číslo $b$. Pak platí 
$$\align\frac {cn(n-1)|I|}m&\ge\sum_{i\in I}\big(\sum_{j=0}^{m-1}
(b^i_j)^2-n\big)\ge\sum_{i\in I'}\big(\sum_{j=0}^{m-1}(b^i_j)^2-n\big
)>\\
&\sum_{i\in I'}\frac {(c+a)n(n-1)}m\ge\frac {(c+a)n(n-1)b|I|}m.\endalign$$
Odtud plyne, že $c>(c+a)b$, a proto $b<\frac c{c+a}$. Když tedy vybíráme  
$h_i\in \Cal H_m$ náhodně s rovnoměrným rozdělením (vzhledem k $
i\in I$), pak 
pravděpo\-dobnost, že bude platit $\sum_{j=0}^{m-1}(b^i_j)^
2>\frac {(c+a)n(n-1)}m+n$, je 
menší než $\frac c{c+a}$. Stejně jako v předchozí sekci shrneme tato fakta do tvrzení 

\proclaim{Tvrzení}Pro přirozené číslo $m$ mějme $
c$-univerzální systém funkcí $\Cal H_m=\{h_i\mid i\in 
I\}$ hašujících do tabulky o velikosti 
$m$. Pro $m=n$ existuje deterministický algoritmus, 
který v čase $O(|I|n)$ nalezne $h_i\in \Cal H_m$ takovou, že $
\sum_{j=0}^{m-1}(b^i_j)^2\le c(n-1)+n$, 
a existuje pravděpodobnostní algoritmus, který pro kladné číslo 
$a$ v čase $O(n)$ nalezne $h_i\in \Cal H_m$ takové, že 
$$\sum_{j=0}^{m-1}(b^i_j)^2<(c+a)(n-1)+n,$$
a očekávaný počet iterací při hledání $h_i$ je menší než $\frac {
c+a}a$.   

Pro $m=\frac {cn(n-1)}2+1$ existuje deterministický algoritmus, 
který nalezne perfektní hašovací funkci  $h\in \Cal H_
m$ pro množinu $S$ 
velikosti $n$ v čase $O(n|I|)$.

Pro $a>0$ a pro $m=\frac {(c+a)n(n-1)}2+1$ existuje 
pravděpodobnostní algoritmus, který nalezne perfektní hašovací 
funkci $h\in \Cal H_m$ pro množinu $S$ v čase $O(n)$ a očekávaný počet 
iterací je menší než $\frac {c+a}a$.  
\endproclaim

\demo{Důkaz}Když $n=m$, pak v čase $O(n)$ pro  
hašovací funkci ověříme, zda $\sum_{j=0}^{m-1}(b^
i_j)^2\le c(n-1)+n$, respektive 
$\sum_{j=0}^{m-1}(b^i_j)^2\le (c+a)(n-1)+n$.  V prvním případě víme, že taková 
funkce v souboru $\Cal H_m$ existuje, a systematickým prohledáváním 
všech funkcí v daném $c$-univerzálním systému $\Cal H_
m$ ji nalezneme 
v čase $O(n|I|)$.  Pro pravděpodobnostní algoritmus budeme 
vybírat funkci ze souboru $\Cal H_m$ náhodně s rovnoměrným 
rozdělením.  Pak očekávaný počet iterací než uspějeme je 
$$\align\sum_{i=1}^{\infty}&i(\frac c{c+a})^{i-1}(1-\frac c{c+a})
\le\sum_{i=1}^{\infty}i(\frac c{c+a})^{i-1}-\sum_{i=1}^{\infty}i(\frac 
c{c+a})^i=\\
&\sum_{i=0}^{\infty}(\frac c{c+a})^i=\frac 1{1-\frac c{c+a}}=\frac {c
+a}a.\endalign$$

Pro hledání perfektní hašovací funkce opět použijeme 
syste\-ma\-tické prohledávání $c$-univer\-zál\-ního systému, protože 
víme, že existuje funkce $h_i\in \Cal H_m$ taková, že 
$\sum_{j=1}^{m-1}(b^i_j)^2\le\frac {cn(n-1)}{\frac {cn(n-1)}2+1}+
n<n+2$, a tedy je tato funkce perfektní. 
To vyžaduje čas $O(n|I|)$. 

Když máme $a>1$ a $m=\frac {(c+a)n(n-1)}2+1$ 
a když budeme volit funkce z $\Cal H_m$ 
náhodně s rovnoměrným rozdělením, pak s pravděpodobností 
$\frac a{c+a}$ do\-sta\-ne\-me funkci $h_i$ takovou, že 
$$\sum_{j=0}^{m-1}(b^i_j)^2\le\frac {(c+a)n(n-1)}{\frac {(c+a)n(n
-1)}2+1}+n<2+n.$$
Z důsledku plyne, že $h_i$ je perfektní.  Analýza 
očekávaného počtu iterací je stejná jako u předchozího tvrzení 
pro pravděpodobnostní algoritmus.  \qed
\enddemo

Další postup konstrukce perfektní hašovací funkce už 
nesouvisí s $c$-univerzálními systémy. 

\subsection{
Dynamické perfektní hašování
}

Jedna z velkých nevýhod perfektního hašovaní je 
neznalost efektivních aktualizačních ope\-rací. Existují sice 
obecné meto\-dy na dynamizaci deterministických operací -- viz 
letní přednáš\-ka, ale tato metoda v tomto případě neposkytuje 
efektivní dynamizační operace, protože deterministický 
algoritmus pro ře\-še\-ní perfektního hašování je pro 
aktualizační ope\-race příliš pomalý. To vedlo k návrhu, 
který kombinuje pravděpodobnostní algoritmus pro perfektní 
hašování s obecnou metodou dynami\-za\-ce a tyto metody jsou 
upraveny pro konkrétní situaci. 

Nejprve uvedeme modifikaci výsledků z 
předchozí části, na kterých je tato metoda založena.
Předpokládáme, že $U=\{0,1,\dots,N-1\}$ je univerzum, kde $
N$ je 
prvočíslo, a že je dáno číslo $s<N$. Označme 
$\Cal H_s=\{h_k\mid k=1,2,\dots,N-1\}$ množinu funkcí z $U$ do 
$\{0,1,\dots,s-1\}$, kde $h_k(x)=(kx\bmod N)\bmod s$ pro každé $
x\in U$. 
Když zvolíme náhodně $k=1,2,\dots,N-1$, pak s pravděpodobností 
ales\-poň $\frac 12$ platí 
$$\sum_{i=0}^{s-1}(b_i^k)^2<\frac {4n^2}s+n.$$
Skutečně, když pro méně než $\frac{N-1}2$ hodnot $k$ platí $\sum_{i=0}^m-1(b^k_i)^2\le\frac{4n}m$, pak 
$$\sum_{k=1}^{N-1}\left((\sum_{i=0}^{m-1}(b^k_i)^2)-n\right)\ge2(N-1)\frac{n^2}m$$ 
a to je spor. Budeme předpokládat, 
že takové $k$ máme, a pak pro každé $i=0,1,\dots,s-1$ 
předpokládáme, že náhodně zvolíme $j_i\in \Cal H_{
2(b_i^k)^2}$ takové, že 
$h_{j_i}$ je prostá na množině $S_i=\{s\in S\mid h_k(s)=i
\}$ (z předchozího textu víme, že když zvolíme náhodně 
$j_i=0,1,\dots,N-1$, pak s pravděpodobností ales\-poň $\frac 
14$ je $h_{j_i}$ prostá na $S_i$). Pro jednoduchost předpokládáme, že množiny $
S_i$ 
pro $i=0,1,\dots,s-1$ uložíme do tabulek $T_i$ a tabulky 
$T_0,T_1,\dots,T_{s-1}$ budou uloženy v tabulce $T$. Když $
s=O(|S|)$, 
pak tato metoda vyžaduje $O(|S|)$ prostoru. Abychom určili $
s$, 
zvolme $c>1$ a položme $s=\sigma (|S|)$, kde $\sigma (n)=\frac 
43\sqrt 6(1+c)n$ pro 
každé $n$. Nyní popíšeme algoritmy. Zde $n$ je velikost reprezentované množiny, $s=\sigma(n)$ a $2m(j)$ je velikost tabulky $T_j$ pro $j=0,1,\dots,s-1$.

\subsection{
Algoritmy
}


{\bf INSERT$(x)$}: \newline 
$n:=n+1$ \newline 
{\bf if} $n\le s$ {\bf then}\newline 
\phantom{---}$j:=h(x)$, $|S_j|:=|S_j|+1$\newline 
\phantom{---}{\bf if} $|S_j|\le m(j)$ a pozice $h_j(x)$ v $T_j$ je prázdná {\bf then}\newline 
\phantom{------}vložíme $x$ do tabulky $T_j$  na pozici $
h_j(x)$\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf if} $|S_j|\le m(j)$ a pozice $h_j(x)$ v $T_
j$ je obsazená {\bf then}\newline 
\phantom{---------}vytvoříme seznam $S_j$ prvků v tabulce $
T_j$\newline 
\phantom{---------}vyprázdníme tabulku $T_j$\newline 
\phantom{---------}zvolíme náhodně funkci $h_j\in \Cal H_{
m(j)^2}$\newline 
\phantom{---------}{\bf while} $h_j$ není prostá na množině $
S_j$ {\bf do}\newline 
\phantom{------------}zvolíme náhodně funkci $h_j
\in \Cal H_{m(j)^2}$\newline 
\phantom{---------}{\bf enddo}\newline 
\phantom{---------}{\bf for every} $y\in S_j$ {\bf do} vložíme $
y$ do $T_j$ na pozici $h_j(y)$ {\bf enddo}\newline 
\phantom{------}{\bf else}\newline 
\phantom{---------}$m(j):=2m(j)$\newline 
\phantom{---------}{\bf if} není dost prostoru pro tabulku $
T_j$ nebo 
$$\sum_{i=0}^{\sigma (m)-1}(m(i))^2\ge\frac {4n^2}{\sigma (n)}+n$$
\phantom{---------}{\bf then}\newline 
\phantom{------------}{\bf RehashAll}\newline 
\phantom{---------}{\bf else}\newline 
\phantom{------------}alokujeme prostor pro novou prázdnou tabulku $
T_j$ \newline 
\phantom{------------}vytvoříme seznam $S_j$ prvků ze staré tabulky $
T_j$ a zrušíme ji\newline 
\phantom{------------}zvolíme náhodně funkci $h_j\in \Cal H_{
m(j)^2}$\newline 
\phantom{------------}{\bf while} $h_j$ není prostá na množině $
S_j$ {\bf do}\newline 
\phantom{---------------}zvolíme náhodně funkci $
h_j\in \Cal H_{m(j)^2}$\newline 
\phantom{------------}{\bf enddo}\newline 
\phantom{------------}{\bf for every} $y\in S_j$ {\bf do} vložíme $
y$ do $T_j$ na pozici $h_j(y)$ {\bf enddo}\newline 
\phantom{---------}{\bf endif}\newline 
\phantom{------}{\bf endif}\newline 
\phantom{---}{\bf else}\newline 
\phantom{------}{\bf RehashAll}\newline 
\phantom{---}{\bf endif\newline 
endif}


{\bf RehashAll}:\newline 
projdeme tabulku $T$ a tabulky $T_i$ a vytvoříme seznam 
prvků z množiny $S$\newline 
$s:=\sigma(n)$\newline 
zvolme náhodně $h\in \Cal H_s$ \newline 
{\bf for every} $i=0,1,\dots,s-1$ {\bf do} $S_i:=\{x\in 
S\mid h(x)=i\}$ {\bf enddo\newline 
while} $\sum_{i=0}^{s-1}2(|S_i|)^2>\frac {8n^2}s+2n$ {\bf do}\newline 
\phantom{---}zvolme náhodně $h\in \Cal H_s$ \newline 
\phantom{---}{\bf for every} $i=0,1,\dots,s-1$ {\bf do} $
S_i:=\{x\in S\mid h(x)=i\}$ {\bf enddo}\newline 
{\bf enddo}\newline
Komentář: zde $S_i$ jsou množiny vytvořené náhodně zvolenou 
funkcí $h$ \newline 
$n:=0$ \newline 
{\bf for every} $i=0,1,\dots,s-1$ {\bf do}\newline 
\phantom{---}$m(i):=2|S_i|$\newline 
\phantom{---}zvolíme náhodně $h_i\in \Cal H_{m(i
)^2}$\newline 
\phantom{---}{\bf while} $h_i$ není prostá na množině $
S_i$ {\bf do}\newline 
\phantom{------}zvolíme náhodně $h_i\in \Cal H_{m(i)^2}$\newline 
\phantom{---}{\bf enddo\newline 
enddo\newline 
for every} $x\in S$ {\bf do INSERT$(x)$ enddo}


{\bf DELETE$(x)$}:\newline 
$j:=h(x)$, $n:=n-1$, $|S_j|:=|S_j|-1$\newline 
odstraníme $x$ z pozice $h_j(x)$ v tabulce $T_j$, pozice bude prázdná \newline 
{\bf if} $n<\frac m{1+2c}$ {\bf then RehashAll endif}


{\bf MEMBER$(x)$}: \newline 
$j:=h(x)$\newline 
{\bf if} $x$ je na $h_j(x)$-té pozici v tabulce $T_j$ {\bf then}\newline 
\phantom{---}{\bf Výstup}: $x$ je prvek $S$ \newline 
{\bf else}\newline 
\phantom{---}{\bf Výstup}: $x$ není prvkem $S$\newline 
{\bf endif}


Algoritmy předpokládají, že při operaci {\bf INSERT$
(x)$} prvek $x$ nepatří do $S$ a při operaci {\bf DELETE$(x)$} $
x$ je prvkem $S$. Velikost reprezentované množiny je $n$. 

Uvedu složitost této metody bez důkazu.

\proclaim{Věta}Popsaná metoda vyžaduje lineární pamě\v t 
(neuvažuje se pamě\v t potřebná pro zak\'odo\-vá\-ní hašovacích funkcí), operace {\bf MEMBER }
v nej\-horším případě vyžaduje čas $O(1)$ a očekávaná 
amortizovaná složitost operací {\bf INSERT} a {\bf DELETE} je také $
O(1)$.
\endproclaim

Toto zobecnění Fredman-Koml\'os-Szemerédiho metody navrhli 
Dietzfelbinger, Karlin, Mehl\-horn, Meyer auf der Heide, Rohnert 
a Tarjan.


Další nevýhoda Fredman-Koml\'os-Szemerédiho metody:\newline 
Navržená metoda pracuje pro $m<3n$, ale nezajistí $m=n$. 
Lze říct, že pamě\v t je efektivně využita? Existuje 
metoda, která by umožnila návrh perfektní hašovací 
funkce pro $m=n$? Z výsledků pro 
$(N,m,n)$-perfektní soubory funkcí plyne existence 
$(N,n,n)$-perfektního souboru pro $n^N>e^{n+ln(n)}\ln(N)$. 
Zmíníme se orientačně o parametrizované metodě, která 
navr\-huje perfektní hašovací funkci pro $S\subseteq U$ a pro 
$|S|=n$. Parametr bude přirozené číslo $r$, které určuje, 
jaké hypergrafy jsou užity při konstrukci funkce. Proto 
nejdříve připomeneme několik definic.

Dvojice $(X,E)$, kde $X$ je množina a $E$ je systém 
$r$-prvkových podmnožin $X$, se nazývá $r$-\emph{hypergraf}.  
Prvky v $E$ se nazývají \emph{hrany} $r$-hypergrafu.  
\emph{Cyklus} je hypergraf $(X,E)$, kde každý vrchol leží 
alespoň ve dvou různých hranách.  Naopak 
$r$-hypergraf $(X,E)$ se nazývá \emph{acyklický}, když 
žádný jeho podhypergraf není cyklus.  

Nyní popíšeme metodu, která je rozdělena do 
dvou kroků. Je dáno $S\subseteq U$ takové, že 
$|S|=n$.

Krok 1) Mějme $r$-hypergraf $(V,E)$, kde $|E|=n$.  Nalezneme 
zobrazení 
$$g:V@>>>\{0,1,\dots,n-1\}$$
takové, že funkce 
$h:E@>>>\{0,1,\dots,n-1\}$ definovaná $h(e)=\sum_{i=1}^rg(v_i)\bmod 
n$, 
kde $e=\{v_1,v_2,\dots,v_r\}$, je prostá (místo sčítání modulo $
n$ 
můžeme použít libovolnou grupovou operaci na 
množině $\{0,1,\dots,n-1\}$).  Pro acyklický $r$-hypergraf lze 
funkci $g$ zkonstruovat násle\-dujícím postupem.  Zvolíme 
bijekci $h:E@>>>\{0,1,\dots,n-1\}$ a pak definujeme $g$ 
následovně:  když $e=\{v_1,v_2,\dots,v_r\}$ a $g(v_i)$ je 
definováno pro $i=2,3,\dots,r$, pak 
$$g(v_1)=h(e)-\sum_{i=2}^rg(v_i)\bmod n.$$
Protože pro každý acyklický $r$-hypergraf existuje vrchol, který 
leží v jediné hraně, lze tento postup použít ke konstrukci $
g$ 
pomocí indukce (a tedy máme algoritmus pro konstrukci $g$).  

Krok 2) Nalezneme $r$ funkcí $f_1,f_2,\dots,f_r:U@>>>
V$ takových, že 
$(V,E)$, kde 
$$E=\{\{f_1(x),f_2(x),\dots,f_r(x)\}\mid x\in S\},$$
 je acyklický 
$r$-hypergraf.  Pak hašovací funkce $f$ je definována 
$f(x)=\sum_{i=1}^rg(f_i(x))$ pro každé $x\in U$.  Z konstrukce 
vyplývá, že je perfektní na množině $S$.  

Autoři dokázali, že 
nejvhodnější alternativa je, když zobrazení $f_1
,f_2,\dots,f_r$ 
jsou náhodná zob\-razení náhodně zvolená. Bohu\-žel taková 
zobrazení neumíme zkonstruovat, ale autoři ukázali, že 
pro tyto účely lze použít náhodný výběr funkcí z 
nějakého $c$-univerzálního souboru funk\-cí. 

Autoři ukázali, že jejich algoritmus vyžaduje $
O(rn+|V|)$ 
času a $O(n\log n+r\log|V|)$ paměti. 

Tento metapostup navrhli Majewski, Wormald, Havas a Czech (1996).

Pro praktické použití je problematická 
reprezentace $r$-hyper\-gra\-fu a i náhodná volba funkcí 
$f_1,f_2,\dots,f_r$ (viz předchozí diskuze o $c$-univerzalitě).  Z 
požadavků na perfektní hašovací funkci je opět 
problémem splnění poža\-davku 4).  Nevím, jak je uvedená 
metoda prakticky pou\-ži\-telná a zda se někde používá.  

\section{Externí hašování}

Navržený postup je také znám pod názvem Faginův algoritmus. Tímto problémem se jako první asi zabýval Larsson.

Řešíme jiný problém -- uložení dat v externí 
pamě\v ti. Hlavní problém -- minimalizovat přístupy na 
externí pamě\v t. 

Předpoklady:  Externí pamě\v t je rozdělena na 
stránky, každá stránka obsahuje $b$ položek (dat) 
(předpokládáme, že $b>1$, jinak to nemá smysl).  Vždy v 
jednom kroku načteme celou stránku do interní paměti 
nebo celou stránku v interní paměti v jednom kroku 
zapíšeme na externí medium.  Tyto operace jsou řádově 
pomalejší než operace v interní paměti.  

Podobný problém se také řeší pri práci s cache-pamětí. V tom případě však 
neovlivňujeme, která stránka se bude načítat, kdežto v případě externí paměti to právě musíme řešit.

Náš cíl:  
Nalézt způsob ukládání dat do stránek externí 
paměti, aby se minimalizoval počet operací s externí 
pamětí.  

Předpokládejme, že $h:U@>>>\{0,1\}^{*}$ je prosté 
zobrazení takové, že délka $h(u)$ je stejná pro všechny prvky 
univerza $U$.  Označme $k$ délku $h(u)$ pro $u\in U$. Pak $
h$ je 
hašovací funkce (to znamená, že hašovací funkce je přejmenování prvků).  Nech\v t $S\subseteq U$, pak pro slovo $
\alpha$ délky 
menší než $k$ definujme 
$$h^{-1}_S(\alpha )=\{s\in S\mid\alpha\text{\rm\ je prefix }h(s)\}
.$$
Řekneme, že $\alpha$ je \emph{kritické} \emph{slovo}, když 
$0<|h^{-1}_S(\alpha )|\le b$ a pro každý vlastní prefix $
\alpha'$ slova $\alpha$ platí 
$|h^{-1}_S(\alpha')|>b$.  Pro každé $s\in S$ existuje právě jedno 
kritické slovo $\alpha$, které je prefixem $h(s)$.  Definujme $
d(s)$ 
pro $s\in S$ jako délku kritického slova, které je prefixem 
$h(s)$ a 
$$d(S)=\max\{\text{\rm délka}(\alpha )\mid\alpha\text{\rm\ je kritické slovo}
\}=\max\{d(s)\mid s\in S\}.$$
Množinu $S$ reprezentujeme tak, že je jednoznačná 
korespondence mezi kritickými slovy a stránkami externí 
paměti slouží\-cí\-mi k reprezentaci $S$.  Na stránce 
příslušející kritickému slovu $\alpha$ je reprezentován soubor 
$h^{-1}_S(\alpha )$.  

Problém: jak nalézt stránku kritického slova 
$\alpha$?\newline 
Řešení: Adresář je funkce, která každému slovu $
\alpha$ o 
délce $d(S)$ přiřadí adresu stránky předpisem
\roster
\item"{}"když kritické slovo $\beta$ je prefixem $\alpha$, pak k $
\alpha$ je 
přiřazena strán\-ka korespondující s $\beta$, jinak je k $
\alpha$ 
přiřazena strán\-ka $NIL$ -- speciální prázdná stránka.
\endroster

Korektnost: Pro různá kritická slova 
$\beta$ a $\gamma$ platí $h^{-1}_S(\beta )\cap h^{-1}_S(\gamma 
)=\emptyset$, a tedy pro každé slovo $\alpha$ 
délky $d(S)$ existuje nejvýše jedno kritické slovo, které 
je prefixem $\alpha$. Když $\alpha$ je slovo délky $d(S)$, pak nastane 
jeden z těchto tří případů:
\roster
\item
$h^{-1}_S(\alpha )\ne\emptyset$, pak $0<|h^{-1}_S(\alpha )|\le b$ a existuje právě jedno kritické slovo $
\beta$, 
které je prefixem $\alpha$; 
\item
$h^{-1}_S(\alpha )=\emptyset$ a existuje prefix $\alpha'$ slova $
\alpha$ takový, že 
$0<|h^{-1}_S(\alpha')|\le b$, pak existuje právě jedno kritické slovo, které je 
prefixem $\alpha'$ (a tedy také prefixem $\alpha$);
\item
$h^{-1}_S(\alpha )=\emptyset$ a pro každý prefix $\alpha'$ slova $
\alpha$ platí buď 
$h^{-1}_S(\alpha')=\emptyset$ nebo $|h^{-1}_S(\alpha')|>b$ (pak k $
\alpha$ je přiřazena 
stránka $NIL$).
\endroster

Mějme slovo $\alpha$ o délce $d(S)$. Označme $c
(\alpha )$ nejkratší 
prefix $\alpha'$ slova $\alpha$ takový, že každému slovu $\beta$ o délce $d(S)$, které má $\alpha'$ 
za prefix, je přiřazená stejná stránka jako slovu $\alpha$. Všimněme si, že když $h^{
-1}_S(\alpha )\ne\emptyset$, pak $c(\alpha )$ je 
kritické slovo. Platí silnější tvrzení, které tvrdí, že 
následující podmínky jsou ekvivalentní:
\roster
\item
stránka přiřazená slovu $\alpha$ je různá od $
NIL$;
\item
$c(\alpha )$ je kritické slovo;
\item
nějaký prefix $\alpha$ je kritické slovo.
\endroster
Všimněme si, že znalost adresáře umožňuje nalézt slovo 
$c(\alpha )$ pro každé slovo o délce $d(S)$.

Lineární uspořádání na slovech délky $
n$ nazveme 
\emph{lexikografické}, když $\alpha <\beta$, právě když 
$\alpha =\gamma 0\alpha'$ a $\beta =\gamma 1\beta'$ pro nějaká slova $
\gamma$, $\alpha'$ a $\beta'$. 
Lexikografické uspořádání vždy existuje a je 
jednoznačné.

Reprezentace adresáře: Je to seznam adres 
stránek o délce $2^{d(S)}$ takový, že adresa na $i$-tém místě 
odpovídá $i$-tému slovu délky $d(S)$ v lexikografickém 
uspořádání.

Příklad: $U$ je množina všech slov nad $\{
0,1\}$ o 
délce $5$, $h$ 
je identická funkce a $b=2$. Reprezentujme množinu  
$S=\{00000,\,00010,\,01000,\,10000\}$. Pak 
$d(00000)=d(00010)=d(01000)=2$, $d(10000)=1$, kritická slova 
jsou $00$, $01$ a $1$ a adresář je (místo adresy stránky 
uvedeme množinu, která je na této stránce uložena)
$$00\mapsto \{00000,00010\},\quad 01\mapsto \{01000\},\quad 10\mapsto 
11\mapsto \{10000\}.$$
Tedy $c(00)=00$, $c(01)=01$ a $c(10)=c(11)=1$.
Když odstraníme prvek $10000$, pak $1$ přestane být kritické 
slovo a adresář bude mít tvar
$$00\mapsto \{00000,00010\},\quad 01\mapsto \{01000\},\quad 10\mapsto 
11\mapsto NIL.$$
Opět platí $c(00)=00$, $c(01)=01$ a $c(10)=c(11)=1$.
V adresáři je také uloženo $d(S)$.

\subsection{
Algoritmy
}


Uvedeme zde jen slovní popis operací. Předpokládáme, že adresář 
je uložen v externí paměti na jedné stránce.

{\bf MEMBER$(x)$}\newline 
1) Spočítáme $h(x)$ a {\bf načteme} adresář do interní paměti. 
Vez\-me\-me prefix $\alpha$ slova $h(x)$ o délce $d(S)$ a nalezneme 
adresu stránky příslušející k $\alpha$. Když je to stránka 
$NIL$, pak $x\notin S$ a konec, jinak pokračujeme krokem 
2).\newline 
2) {\bf Načteme} stránku příslušející k $\alpha$ do interní 
paměti. Prohle\-dá\-me ji a pokud neobsahuje $x$, pak $x\notin 
S$ a 
konec. Když obsahuje $x$, pak provedeme požadované 
změny a stránku {\bf ulo\-ží\-me} do externí paměti na její 
původní místo. Konec.

{\bf INSERT$(x)$}\newline 
1) Spočítáme $h(x)$ a {\bf načteme} adresář do interní paměti. 
Vez\-me\-me prefix $\alpha$ slova $h(x)$ o délce $d(S)$ a nalezneme 
adresu stránky příslušející k $\alpha$ a slovo $
c(\alpha )$. 
Když stránka přiřazená k $\alpha$ je $NIL$, pokraču\-je\-me krokem 
3), v opačném případě pokraču\-je\-me krokem 2).\newline 
2) {\bf Načteme} stránku přiřazenou slovu $\alpha$. Když $
x$ je 
uloženo na této stránce, pak skončíme. Když $x$ není na 
této stránce, pak tam přidáme slovo $x$. Pokud na stránce 
je nejvýše $b$ prvků, pak {\bf uložíme} stránku 
na její původní místo a skončíme. Když na 
stránce je více než $b$ prvků, pak nalezneme nová 
kritická slova, 
která nám stránku rozdělí, a vytvoříme dvě stránky -- 
jednu {\bf uložíme} na místo původní stránky a 
druhou {\bf uložíme} na novou stránku. Pokračujeme krokem 
4).\newline 
3) Vytvoříme v interní paměti novou stránku, která 
obsahuje $x$, nalezneme novou stránku v externí paměti a 
tam {\bf uložíme} vytvořenou stránku (všem slovům, 
která mají $c(\alpha )$ za prefix, bude přiřazena tato stránka) a 
pokračujeme krokem 4).\newline 
4) {\bf Načteme} opět adresář do interní paměti, 
aktualizujeme adresy přiřazených stránek a případně 
zvětšíme adresář (to nastane, když nějaké nové kritické 
slovo má délku větší než $d(S)$, pak nové $d(S
)$ je právě 
délka tohoto slova -- obě kritická slova vzniklá v kroku 
2) mají stejnou délku). Aktualizovaný adresář {\bf uložíme} do 
externí paměti. Konec.

{\bf DELETE$(x)$}\newline 
1) Spočítáme $h(x)$ a {\bf načteme} adresář do interní paměti. 
Vez\-me\-me prefix $\alpha$ slova $h(x)$ o délce $d(S)$ a nalezneme 
adresu stránky příslušející k $\alpha$ a slovo $
c(\alpha )$. 
Když stránka přiřazená k $\alpha$ je $NIL$, pak skončíme. 
Označme $\beta'$ slovo, které má stejnou délku jako $c(\alpha 
)$ a 
liší se od $c(\alpha )$ pouze v posledním bitu. Když existuje 
slovo $\beta$ délky $d(S)$ takové, že $c(\beta )=\beta'$, pak stránka 
přiřazená k $\beta$ je \emph{kandidát}.\newline 
2) {\bf Načteme} stránku příslušnou k slovu $\alpha$ do interní 
paměti. Když tato stránka neobsahuje $x$, pak skončíme. 
Když tato stránka obsahuje $x$, pak odstraníme $x$ z této 
stránky. Když neexistuje kandidát nebo když nová 
stránka a stránka kandidáta dohromady obsahují více než $
b$ 
prvků, pak novou stránku {\bf ulo\-žíme} na její 
původní místo a skončíme. \newline 
3) Když nová stránka a stránka kandidáta mají 
dohromady $b$ prvků, pak {\bf načteme} stránku 
kandidáta do interní paměti. V interní paměti tyto 
stránky spojíme do jedné a tuto stránku pak 
{\bf ulo\-žíme} do externí paměti.\newline 
4) {\bf Načteme} adresář, kde zaktualizujeme adresy 
stránek. Po\-kud jsme sloučili dvě stránky, musíme nalézt 
nové $c(\alpha )$ (je to nejkratší prefix $\alpha'$ slova $
\alpha$ takový, že 
ke každému slovu $\beta$ o délce $d(S)$, které má $\alpha'$ za prefix, 
je přiřazena jedna z těchto adres: adresa stránky 
přiřazená k $\alpha$, adresa stránky kandidáta, $NIL$) a každému 
slovu o délce $d(S)$, které má nové $c(\alpha )$ za prefix, bude 
přiřazena adresa nové (spojené) stránky. Otestujeme, zda 
se adresář nemůže zkrátit (to nastane, když 
adresy stránek přiřazené $(2i+1)$-ímu slovu a $(2i+
2)$-ému 
slovu o délce $d(S)$ jsou stejné pro všechna $i$, 
pak se tato slova spojí a $d(S)$ se zmenší o $1$). Upravený 
adresář {\bf uložíme}. Konec.


Následující věta ukazuje, že jsme náš hlavní cíl splnili. Pro jednoduchost předpokládáme, že 
adresář je také uložen na externí paměti a že v 
interní paměti nemůže být uložen spolu s nějakou jinou stránkou. 

\proclaim{Věta}Operace {\bf MEMBER} vyžaduje nejvýše tři 
operace s externí pamětí. Operace {\bf INSERT} a {\bf DELETE }
vyžadují nejvýše šest operací s externí pamětí.
\endproclaim

V našem příkladu provedeme operaci 
{\bf INSERT$(00001)$}. Po přidání prvku stránka původně 
přiřazená k slovu $00$ vypadá takto $\{00000,00001,0001
0\}$. Tuto 
stránku rozdělíme na  
strán\-ky $\{00000,00001\}$ a $\{00010\}$. Přitom kritické slovo 
první strán\-ky je $0000$ a druhé strán\-ky je $0001$. Takže 
$d(S)=4$ a adresář vypadá 
$$\align&0000\mapsto \{00000,00001\},0001\mapsto \{00010\},\\
&0010\mapsto 0011\mapsto NIL,\\
&0100\mapsto 0101\mapsto 0110\mapsto 0111\mapsto \{0100\},\\
&1000\mapsto 1001\mapsto 1010\mapsto 1011\mapsto \{10000\},\\
&1100\mapsto 1101\mapsto 1110\mapsto 1111\mapsto \{10000\}.\endalign$$
To znamená, že kromě adresy $00$ se ostatní slova rozdělila 
na čtyři slova, ale adresy zůstaly stejné. Jen u 
slova 00 vzniklá slova dostala různé adresy.

V původním příkladu 
provedeme operaci {\bf DELETE$(01000)$}. Pak kandidát je $00$ a po 
odstranění prvku $01000$ nastane spojení těchto dvou 
stránek. Po aktualizaci adres dostane adresář tvar
$$00\mapsto 01\mapsto \{00000,00010\},10\mapsto 11\mapsto \{10000
\},$$
tj. k prvnímu a druhému slovu je přiřazena stejná 
stránka a stejně tak k třetímu a čtvrtému slovu. Takže 
můžeme adresář zmenšit. Pak $d(S)=1$ a adresář má 
podobu  
$$0\mapsto \{00000,00010\},1\mapsto \{10000\}.$$

Vzniká otázka, jak je tato metoda efektivní. 
Hlavně jak efektivně využívá pamě\v t. Platí

\proclaim{Věta}Když velikost repre\-zentované množiny je $
n$, pak 
očekávaný počet použitých stránek je 
$\frac n{b\ln2}$ a očekáva\-ná velikost adresáře je $\frac 
e{b\ln2}n^{1+\frac 1b}$. 
\endproclaim

První tvrzení říká, že očekávaný počet 
prvků na stránce je $b\ln2\approx 0.69b$. Tedy zaplněno 
je asi 69\% míst. Tento výsledek není překvapující a je 
akceptovatelný. Horší je to s adresářem, jak ukazuje 
následující tabulka

$$\vtop{\offinterlineskip\halign {\strut\vrule\ # & \vrule\ # & \vrule\ # & \vrule\ # & \vrule \hfil # \hfil \vrule\cr\noalign{\hrule}velikost $S$ & $10^5$ & $10^6$ & $10^8$ & $10^{10}$ \hfill \cr\noalign{\hrule} 2 & $6.2\cdot10^7$ & $1.96\cdot10^8$ & $1.96\cdot10^{11}$ & $1.96\cdot10^{14}$ \cr\noalign{\hrule} $10$ & $1.2\cdot10^5$ & $1.5\cdot10^6$ & $2.4\cdot10^8$ & $3.9\cdot10^{10}$ \cr\noalign{\hrule} $50$ & $9.8\cdot10^3$ & $1.0\cdot10^6$ & $1.1\cdot10^8$ & $1.2\cdot10^{10}$ \cr\noalign{\hrule} $100$ & $4.4\cdot10^3$ & $4.5\cdot10^4$ & $4.7\cdot10^6$ & $4.9\cdot10^8$ \cr\noalign{\hrule}}}$$

kde jednotlivé řádky odpovídají hodnotám $
b$ 
uvedeným v prv\-ním sloupci. Protože očekávaná velikost 
adresáře se zvětšu\-je rychleji než lineárně (exponent u $
n$ je $1+\frac 1b$), 
tak nelze očekávat, že tuto metodu lze vždy použít. 
Výpočty i expe\-ri\-menty uka\-zu\-jí, že použitelná je do 
velikosti $|S|=10^{10}$, když $b\approx 100$. V tomto rozmezí je 
nárůst adresáře jen kolem 5\%. Pro větší $
n$ je 
třeba, aby $b$ bylo ještě větší.

\end{document}
