\documentclass[a4paper,12pt]{article}
 \usepackage{amsmath}
 \usepackage{amsthm}
 \usepackage{amsfonts}
 
 
 \usepackage[utf8]{inputenc}
 \usepackage[czech]{babel}
 \usepackage{hyperref}
 
 \setlength{\hoffset}{-3cm} 
 \setlength{\voffset}{-3cm}
 \setlength{\textheight}{26.0cm} 
 \setlength{\textwidth}{19cm}
 \setlength{\parindent}{0in}
 \setlength{\parskip}{0.1in}
 
 \def \emph#1{\underbar{#1}}
 
 

 
 \DeclareMathOperator*{\Prob}{Prob}
 \DeclareMathOperator*{\countop}{count}
 \DeclareMathOperator*{\NIL}{NIL}
 \DeclareMathOperator*{\otec}{otec}
 \DeclareMathOperator*{\listop}{list}
 \DeclareMathOperator*{\Prv}{Prv}
 \DeclareMathOperator*{\Nasl}{Nasl}
 \DeclareMathOperator*{\levy}{levy}
 \DeclareMathOperator*{\pravy}{pravy}
 \DeclareMathOperator*{\key}{key}
 \DeclareMathOperator*{\Prst}{Prst}
 \DeclareMathOperator*{\hloubka}{hloubka}
 \DeclareMathOperator*{\bratr}{bratr}
 \DeclareMathOperator*{\npl}{npl}
 \DeclareMathOperator*{\Cont}{Cont}
 
 \input lhead
 
 
 \begin{document}
     

\newtheorem*{dusledek}{Důsledek}
\newtheorem*{lemma}{Lemma}
\newtheorem*{veta}{Věta}
\newtheorem*{tvrzeni}{Tvrzení}

\def \emph#1{\underbar{#1}}
\def \Prob{\operatorname{Prob}}
\def \var{\operatorname{var}}

\title{Datové struktury - haldy a třídící algoritmy}
\date{}
\maketitle

\section{Úvod}

V praxi se často setkáváme s následujícím 
problémem, který vzniká na uspořádaném univerzu, jehož 
uspořádání se však v průběhu času mění. Úloha se 
liší od slovníkového problému v tom, že se nevyžaduje  
efektivní operace {\bf MEMBER}. Dokonce se předpokládá, že ope\-race 
dostane spolu s argumentem informaci o uložení 
zpracovávaného prvku. 
Hlav\-ním požadavkem je rychlost provedední ostatních operací a malé 
paměťové nároky. Přitom v praxi obvykle nestačí znát jen 
asymptotickou složitost, důležitou roli hraje skutečná 
rychlost, kterou však neumíme obecně spočítat, protože je závislá na 
použitém systému a hardwaru. Přesto je při použití 
následujících struktur dobré mít realistickou představu o 
skutečných rychlostech operací a podle toho si vybrat 
vhodnou strukturu. 

Zadání problému: Nechť $U$ je univerzum. Je dána množina 
$S\subseteq U$ a funkce $f:S@>>>\mathbb R$, kde $\mathbb R$ jsou reálná čísla (tato 
funkce realizuje uspořádání na univerzu $U$ -- pro $u,
v\in U$ platí 
$u\le v$, právě když $f(u)\le f(v)$; změna uspořádání se pak realizuje 
změnou funkce $f$).
Máme navrhnout reprezentaci $S$ a $f$, která umožňuje 
operace:\newline 
{\bf INSERT$(s,a)$} -- přidá k množině $S$ prvek $s$ tak, že 
$f(s)=a$,\newline 
{\bf MIN} -- nalezne prvek $s\in S$ s nejmenší hodnotou 
$f(s)$,\newline 
{\bf DELETEMIN} -- odstraní prvek $s\in S$ s nejmenší hodnotou 
$f(s)$,\newline 
{\bf DELETE$(s)$} -- odstraní prvek $s\in S$ z množiny $S$,\newline 
{\bf DECREASE$(s,a)$} -- zmenší hodnotu $f(s)$ o $a$ (tj. 
$f(s):=f(s)-a$),\newline 
{\bf INCREASE$(s,a)$} -- zvětší hodnotu $f(s)$ o $a$ (tj. 
$f(s):=f(s)+a$).\newline 
Při operaci {\bf INSERT$(s,a)$} se předpokládá, že $
s\notin S$, a tento 
předpoklad operace {\bf INSERT} neověřuje. Při operacích {\bf DE\-LE\-TE$
(s)$},
{\bf DECREASE$(s,a)$ a INCREASE$(s,a)$} se před\-pokládá, že $
s\in S$, 
a operace navíc dostává informaci, jak najít  
prvek $s$ v reprezentaci $S$ a $f$. Haldy jsou typ 
struktury, která se používá pro řešení tohoto problému. 

\emph{Halda} je stromová struktura, kde vrcholy 
reprezentují prvky z $S$ a splňují lokální podmínku na 
$f$. Obvykle se používá následující podmínka nebo její 
duální verze:

\begin{enumerate}
\item[(usp)]
Pro každý vrchol $v$ platí: když $v$ reprezentuje prvek 
$s\in S$ a $\otec(v)$ reprezentuje $t\in S$, pak $f(t)\le f(s)$.
\end{enumerate}

Probereme několik verzí hald a budeme 
předpokládat, že vždy splňují tuto podmínku a že požadavek na 
provedení operací {\bf DELETE$(s)$}, {\bf DECREA\-SE$(s,a
)$} a {\bf INCREASE$(s,a)$ }
také zadává ukazatel na vrchol repre\-zentující $s\in 
S$.  Navíc budeme 
uvažovat operace

{\bf MAKEHEAP$(S,f)$} -- operace vytvoří haldu 
reprezentující množinu $S$ a funkci $f$,\newline 
{\bf MERGE$(H_1,H_2)$} -- předpokládá, že halda $H_i$ reprezentuje 
množinu $S_i$ a funkci $f_i$ pro $i=1,2$ a $S_1\cap S_2=\emptyset$. Operace 
vytvoří haldu $H$ reprezentující $S_1\cup S_2$ a $
f_1\cup f_2$, 
přičemž neověřuje disjunktnost $S_1$ a $S_2$.
\newpage

\section{{Regulární haldy}}

První použité haldy byly binární neboli $
2$-regulární haldy. 
Tyto haldy jsou velmi oblíbené pro svou jednoduchost a 
názornost a pro velmi efektivní implementaci.

Předpokládejme, že $d>1$ je přirozené číslo. 
$d$-\emph{regulární} \emph{strom} je kořenový strom 
$(T,r)$, pro který existuje pořadí synů 
jednotlivých vnitřních vrcholů takové, že 
očíslování vrcholů pro\-hle\-dá\-váním do šířky 
(kořen $r$ je číslován $1$) splňuje následující vlastnosti
\begin{enumerate}
\item
každý vrchol má nejvýše $d$ synů,
\item
když vrchol není list, tak všechny vrcholy s menším 
číslem mají právě $d$ synů,
\item
když vrchol má méně než $d$ synů, pak všechny 
vrcholy s většími čísly jsou listy.
\end{enumerate}
Toto očíslování se nazývá \emph{přirozené} 
\emph{očíslování} $d$-regulárního stromu. 

\begin{tvrzeni}Každý $d$-regulární strom má nejvýše jeden 
vrchol, který není list a má méně než $d$ synů. Když 
$d$-regulární strom má $n$ vrcholů, pak jeho 
výška je $\lceil\log_d(n(d-1)+1)\rceil$. Nechť $o$ je přirozené očíslování 
vrcholů $d$-regulárního stromu. Když pro vrchol 
$v$ je $o(v)=k$, pak vrchol $w$ je syn vrcholu $v$, právě 
když $o(w)\in \{(k-1)d+2,(k-1)d+3,\dots,kd+1\}$, a vrchol $u$ je 
otcem vrcholu $v$, právě když $o(u)=1+\lfloor\frac {k-2}d
\rfloor$. 
\end{tvrzeni}

\begin{proof}První část tvrzení plyne přímo z požadavku 2) na 
$d$-regulární strom. Má-li $d$-regulární strom výšku $
k$, 
pak má alespoň $\Sigma_{i=0}^{k-1}d^i+1$ a nejvýše $\Sigma_{
i=0}^kd^i$ 
vrcholů. Proto
$$\frac {d^k-1}{d-1}<n\le\frac {d^{k+1}}{d-1}\quad ,\quad d^k-1<n
(d-1)\le d^{k+1}-1$$
a zlogaritmováním dostaneme
$$k<\log_d(n(d-1)+1)\le k+1.$$
Odtud plyne 
druhá část tvrzení.  Třetí část pro čísla synů dokážeme 
indukcí podle očíslová\-ní.  Synové kořene mají čísla 
$2,3,\dots$,$d+1$,  protože kořen má číslo $1$.  Když tvrzení platí 
pro vrchol s číslem $k$, pak synové vrcholu s číslem $
k+1$ 
mají čísla $kd+2,kd+3,\dots,kd+d+1$, což odpovídá 
číslům $(k+1-1)d+2,(k+1-1)d+3,\dots,(k+1)d+1$, a tedy 
tvrzení platí. Poslední část pak plyne z toho, že když $
i\in \{(k-1)d+2,(k-1)d+3,\dots,kd+1\}$, pak 
$1+\lfloor\frac {i-2}d\rfloor =k$. \qed
\end{proof}

Všimněme si, že speciálně pro $d=2$ mají synové vrcholu s číslem $
k$ 
čísla $2k$ a $2k+1$ a otec vrcholu s číslem $k$ má číslo 
$\lfloor\frac k2\rfloor$. Tedy pro $2$-regulární stromy je předpis pro nalezení 
synů a otce zvláště jednoduchý.  

\v Rekneme, že množina $S$ s funkcí $f$ je reprezentována 
$d$-regulár\-ní haldou $H$, kde $H$ je $d$-regulární strom $
(T,r)$, když 
přiřazení prvků množiny $S$ vrcholům stromu 
$T$ je bijekce splňující podmínku \thetag{usp}. Toto přiřazení 
je realizováno funkcí $\key$, která vrcholu přiřazuje jím 
reprezentovaný prvek.

Defince $d$-regulárního stromu umožňuje velmi efektivní 
implementace $d$-regulárních hald.  Měj\-me množinu $
S$ 
reprezentovanou $d$-regulární haldou $H$ s přirozeným 
očís\-lo\-vá\-ním $o$ $d$-regulární\-ho stromu $
(T,r)$.  Pak haldu $H$ 
můžeme reprezentovat polem $H[1..|S|]$, kde pro vrchol 
stromu $v$, pro který $o(v)=i$, je $H(i)=(\key(v),f(\key(v))$.  Algoritmy 
budeme popisovat pro stromy, protože je to názornější.  
Přeformulovat je pro pole je snadné (viz 
očíslování synů a otce vrcholu $v$).  Pro jednoduchost 
budeme pro vrchol $v$ psát $f(v)$ místo $f(\key(v))$, neboli $
f(v)$ 
bude označovat $f(s)$, kde $s$ je reprezentován vrcholem $v$.  U 
$d$-regulárního stromu předpo\-klá\-dáme, že známe přirozené 
očíslování, a fráze `poslední vrchol', `před\-cházející vrchol' atd.  
se vztahují k tomuto očíslování.  

\subsection{
Algoritmy
}

Pro $d$-regulární haldy není známa efektivní implementace operace 
{\bf MERGE}.  Efektivní implementace 
ostatních operací jsou založeny na pomocných 
operacích {\bf UP$(v)$} a {\bf DOWN$(v)$}.  Ope\-race {\bf UP$
(v)$} posunuje 
prvek $s$ reprezentovaný vrcholem $v$ směrem ke kořeni, 
dokud vrchol reprezentující prvek $s$ nesplňu\-je podmínku 
\thetag{usp}.  Operace {\bf DOWN$(v)$} je symetrická.  

 

{\bf UP$(v)$}:\newline 
{\bf while} $v$ není kořen a $f(v)<f(\otec(v))$ {\bf do\newline 
\phantom{{\rm ---}}}vyměň $\key(v)$ a $\key(\otec(v))$\newline 
\phantom{---}$v:=\otec(v)$\newline 
{\bf enddo

DOWN$(v)$}:\newline 
{\bf if} $v$ není list {\bf then\newline 
\phantom{{{\rm ---}}}$w:=$}syn vrcholu $v$ reprezentující prvek s nejmenší 
hodnotou $f(w)$\newline 
\phantom{---}{\bf while} $f(w)<f(v)$ a $v$ není list {\bf do\newline 
\phantom{{\rm ------}}}vyměň $\key(v)$ a $\key(w)$, $v:=w$\newline 
\phantom{------}$w:=$syn vrcholu $v$ reprezentující prvek s nejmenší 
hodnotou $f(w)$\newline 
\phantom{---}{\bf enddo\newline 
endif

INSERT$(s)$}:\newline 
$v:=$nový poslední list, $\key(v):=s$, {\bf UP$(v)$

MIN}:\newline 
{\bf Výstup} $\key(\text{\rm kořen}(T))$

{\bf DELETEMIN}:\newline 
$v:=$poslední list, $r:=$kořen, $\key(r):=\key(v)$\newline 
odstraň $v$\newline 
{\bf DOWN$(r)$

DELETE$(s)$}:\newline 
$v:=$vrchol reprezentující $s$\newline 
$w:=$poslední list\newline 
$t:=\key(w),$ $\key(v):=t,$ odstraň $w$\newline 
{\bf if} $f(t)<f(s)$ {\bf then UP$(v)$ else DOWN$(v)$ endif

DECREASE$(s,a)$}:\newline 
$v:=$vrchol reprezentující $s$\newline 
$f(s):=f(s)-a$, {\bf UP$(v)$

INCREASE$(s,a)$}:\newline 
$v:=$vrchol reprezentující $s$\newline 
$f(s):=f(s)+a$, {\bf DOWN$(v)$

MAKEHEAP$(S,f)$}:\newline 
$T:=d$-regulární strom s $|S|$ vrcholy\newline 
zvol libovolnou reprezentaci $S$ vrcholy stromu $T$\newline 
$v:=$poslední vrchol, který není list\newline 
{\bf while} $v$ je vrchol $T$ {\bf do\newline 
\phantom{{\rm ---}}DOWN$(v)$\newline 
\phantom{{\rm ---}}$v:=$}vrchol předcházející 
vrcholu $v$\newline 
{\bf enddo

}
Ověříme korektnost algoritmů.  Je zřejmé, že 
pomocné operace jsou korektní -- skončí, když podmínku 
\thetag{usp} splňuje prvek $s$, který byl původně 
reprezentován vrcholem $v$. Korektnost operace {\bf MIN} plyne 
přímo z podmínky \thetag{usp}, protože kořen reprezentuje nejmenší 
prvek množiny $S$. U operace {\bf INSERT} je podmínka 
\thetag{usp} splněna pro všechny vrcholy s výjimkou nově 
vytvořeného listu a operace {\bf UP} zajistí její splnění.  Při 
operaci {\bf DELETEMIN} je pod\-mín\-ka \thetag{usp} splněna pro 
všechny vrcholy s výjimkou kořene a v tomto případě ope\-race {\bf DOWN} zajistí 
její splnění.  Po provedení operací {\bf DE\-LE\-TE$
(s)$}, {\bf DECREASE$(s,a)$ }
a {\bf INCREASE$(s,a)$} je pod\-mín\-ka \thetag{usp} splněna pro 
všechny vrcholy s výjimkou vrcholu $v$ a její splnění 
opět zajistí operace {\bf UP }
resp. {\bf DOWN}.  Pro operaci {\bf MAKEHEAP }
budeme uvažovat duální formulaci podmínky \thetag{usp}:  
\begin{enumerate}
\item"{(d-usp)}"
když $s$ je prvek reprezentovaný vrcholem $v$, pak 
$f(s)\le f(t)$ pro všechny prvky reprezentované syny 
vrcholu $v$. 
\end{enumerate}
Pokud každý vrchol splňuje podmínku \thetag{d-usp}, pak 
splňuje i pod\-mínku \thetag{usp}. Zřejmě každý list splňuje 
podmínku \thetag{d-usp} a když ope\-race {\bf MAKEHEAP }
provede proceduru {\bf DOWN$(v)$}, pak je podmínka 
\thetag{d-usp} splněna pro všechny vrcholy s 
čísly alespoň tak velkými jako je číslo $v$. 
Operace {\bf MAKEHEAP} končí provedením operace {\bf DOWN} na 
kořen a odtud plyne její korektnost.

\subsection{
Složitost operací
}

Vypočteme časovou složitost operací:  Jeden běh cyklu 
v operaci {\bf UP} vyžaduje čas $O(1)$ a v operaci {\bf DOWN }čas $
O(d)$.  
Proto operace {\bf UP} v nejhorším případě vyžaduje čas $
O(\log_d|S|)$ 
a operace {\bf DOWN }čas $O(d\log_d|S|)$.  
Operace {\bf MIN} vyžaduje čas $O(1)$,  {\bf INSERT} a {\bf DECREASE }
vyžadu\-jí čas $O(\log_d|S|)$ a  {\bf DELETEMIN}, {\bf DELETE} a 
{\bf INCREASE }čas $O(d\log_d|S|)$.

Haldu můžeme 
vytvořit iterací operace {\bf INSERT}, což 
vyžaduje čas $O(|S|\log_d(|S|))$.  Ukáže\-me, že složitost operace 
{\bf MAKEHEAP} je menší, ale pro malé haldy je výhodnější 
provádět opakovaně operaci {\bf INSERT}.  Operace {\bf DOWN$
(v)$} na vrchol 
ve výšce $h$ vyžaduje v nej\-horším případě čas $
O(hd)$.  
Vrcholů v hloubce $i$ je nejvýše $d^i$.  
Před\-pok\-lá\-dejme, že strom má výšku $k$, pak vrchol v 
hloubce $i$ má výšku nejvýše $k-i$.  Tedy operace {\bf MAKEHEAP }
vyžaduje čas $O(\sum_{i=0}^{k-1}d^i(k-i)d)=O(\sum_{i=0}^{k-
1}d^{i+1}(k-i))$.  Oz\-nač\-me 
$A=\sum_{i=0}^{k-1}d^{i+1}(k-i)$, pak 
$$\align dA-A=&\sum_{i=0}^{k-1}d^{i+2}(k-i)-\sum_{i=0}^{k-1}d^{i+
1}(k-i)=\sum_{i=2}^{k+1}d^i(k-i+2)-\sum_{i=1}^kd^i(k-i+1)=\\
&d^{k+1}+\sum_{i=2}^kd^i(k-i+2-k+i-1)-dk=d^{k+1}+\sum_{i=2}^kd^i-
dk=\\
&d^{k+1}+d^2\frac {d^{k-1}-1}{d-1}-dk.\endalign$$
Tedy $A=\frac {d^{k+1}}{d-1}+\frac {d^{k+1}-d^2}{(d-1)^2}-\frac {
dk}{d-1}$. Protože 
$k=\lceil\log_d(|S|(d-1)+1)\rceil$, 
dostáváme, že $d^{k+1}\le d^2((d-1)|S|+1)$, a proto $A\le 
2d^2|S|$. Tedy 
{\bf MAKEHEAP} vyžaduje v nejhorším případě jen čas 
$O(d^2|S|)$. 

\subsection{
Aplikace 
}

Třídění: prostou posloupnost 
čísel $x_1,x_2,\dots,x_n$ lze setřídit následujícím 
algoritmem použí\-vajícím haldu ($f$ bude v tomto případě 
identická funkce).

$d${\bf -HEAPSORT$(x_1,x_2,\dots,x_n)$}:\newline 
{\bf MAKEHEAP$(\{x_i\mid i=1,2,\dots,n\},f)$\newline 
$i=1$\newline 
while} $i\le n$ {\bf do\newline 
\phantom{{\rm ---}}$y_i:=$MIN}, {\bf DELETEMIN}, $i:=i+1$\newline 
{\bf enddo\newline 
Výstup}: $y_1,y_2,\dots,y_n$

Teoreticky lze ukázat, že použití $d$-regulárních hald v 
algoritmu {\bf HEAPSORT} pro $d=3$ a $d=4$ je výhodnější 
než $d=2$. Experimenty ukázaly, že optimální 
algoritmus pro posloupnosti délek do 1 000 000 by měl  
používat $d=6$ nebo $d=7$ (v experimentech byl měřen 
skutečně spotřebovaný čas, nikoli počet porovnání a 
výměn prvků). 
Pro delší posloupnosti se optimální 
hodnota $d$ může zmenšit.

Dalším příkladem je nalezení nejkratších cest v grafu z daného 
bodu. \v Rešme následující úlohu: \newline 
Vstup: orientovaný ohodnocený graf $(X,R,c)$, kde $c$ je funkce z $
R$ do množiny kladných 
reálných čísel, a vrchol $z\in X$.\newline 
Úkol: nalézt pro každý bod $x\in X$ délku 
nejkratší cestu ze $z$ do $x$, kde délka cesty je součet 
$c$-ohodnocení hran na cestě.

{\bf Dijkstrův algoritmus}:\newline 
$d(z):=0$, $U:=\{z\}$\newline 
{\bf for every} $x\in X\setminus \{z\}$ {\bf do} $d(x):=+\infty$ {\bf enddo\newline 
while} $U\ne\emptyset$ {\bf do\newline 
\phantom{{\rm ---}}}najdi vrchol $u\in U$ s nejmenší hodnotou $
d(u)$\newline 
\phantom{---}odstraň $u$ z $U$\newline 
\phantom{---}{\bf for every} $(u,v)\in R$ {\bf do \newline 
\phantom{{\rm ------}}if} $d(u)+c(u,v)<d(v)$ {\bf then\newline 
\phantom{{\rm ---------}}if} $d(v)=+\infty$ {\bf then} vlož $v$ do $
U$ {\bf endif\newline 
\phantom{{\rm ---------}}$d(v):=d(u)+c(u,v)$\newline 
\phantom{{\rm ------}}endif\newline 
\phantom{{\rm ---}}enddo\newline 
enddo

}
Korektnost algoritmu je založena na kombinatorickém 
lemmatu, které říká, že když odstra\-ňuje\-me z $
U$ prvek $x$ s 
nejmenší hodnotou $d(x)$, pak vzdálenost ze $z$ do $x$ je právě 
$d(x)$. Proto když $U=\emptyset$, pak $d(x)$ jsou délky nejkratších cest ze 
$z$ do $x$ pro všechna $x\in X$. Tedy práce s množinou $U$ vyžaduje 
nejvýše $|X|$ operací {\bf INSERT}, {\bf MIN} a {\bf DELETEMIN} a $
|R|$ operací 
{\bf DECREASE} a vždy platí $|U|\le |X|$. Vypočteme časovou složitost 
{\bf Dijkstrova algoritmu} za předpokladu, že $U$ reprezentujeme jako $
d$-regulární 
haldu. Když $d=2$, pak dostáváme, že algoritmus vyžaduje čas 
$O(|X|\log(|X|)+|R|\log(|X|))$. Když $d=\max\{2,\lfloor\frac {
|R|}{|X|}\rfloor \}$, pak algoritmus 
vyžaduje čas $O(|R|\log_d|X|)$. V případě, že $
(X,R)$ je hustý graf, 
tj. $|R|>|X|^{1+\varepsilon}$ pro $\varepsilon >0$, pak $\log_d|X
|=O(1)$ a algoritmus 
je lineární (tj. vyžaduje čas $O(|R|)$).

 
\section{{Leftist haldy}}

Dalším typem hald, se kterými se seznámíme, jsou lefist 
haldy (neznáme vhodný český překlad, proto zůstáváme 
u anglického názvu). Je to velmi elegantní a jednoduchý typ 
hald. Všechny operace jsou stejně jako u regulárních hald 
založeny na 
dvou základních operacích, z nichž v tomto případě hlavní je {\bf MERGE} a  
druhou je {\bf DECREASE}. Použití {\bf MERGE }
při návrhu jiných operací je běžné i v dalších haldách. 
Operace {\bf MERGE} využívá speciálních vlastností leftist 
hald a idea operace {\bf DECREASE} je stejná jako ve 
Fibonacciho haldách. Nejprve formálně popíšeme strukturu 
leftist hald. 

Mějme binární kořenový strom $(T,r)$ (to znamená, že $
r$ je kořen, 
každý vrchol má nejvýše dva syny a u každého syna 
víme, zda je to pravý nebo levý syn). Pro vrchol $v$ 
označme $\npl(v)$ délku nejkratší cesty z $v$ do vrcholu, který má 
nejvýše jednoho syna, takže např. pro list $l$ platí $\npl
(l)=0$. 

Mějme $S\subseteq U$ a funkci $f:S@>>>\mathbb R$. Pak binární strom 
$(T,r)$ takový, že
\begin{enumerate}
\item
když vrchol $v$ má jen jednoho syna, pak je to levý syn,
\item
když vrchol $v$ má dva syny, pak 
$$\npl(\text{\rm pravý syn }v)\le\npl(\text{\rm levý syn }v),$$
\item
existuje jednoznačné přiřazení prvků $S$  
vrcholům $T$, které splňuje podmínku \thetag{usp} 
(toto přiřazení 
je reprezentováno funkcí $\key$, která vrcholu $v$ přiřadí prvek 
z množi\-ny $S$ reprezentovaný vrcholem $v$)
\end{enumerate}
je \emph{leftist} \emph{halda} 
reprezentující množinu $S$ a funkci $f$. 

Struktura vrcholu $v$ v leftist haldě:\newline 
S vrcholem $v$ jsou 
spojeny ukazatelé $\otec(v)$, $\levy(v)$ a $\pravy(v)$ na otce a 
na levého a pravého syna vrcholu $v$.  
Když ukazatel není definován, pak píšeme, že jeho hodnota je 
$NIL$.  Dále jsou s vrcholem spojeny funkce\newline 
$\npl(v)$ -- proměnná s hodnotou $\npl(v)$,\newline 
$\key(v)$ -- prvek reprezentovaný vrcholem $v$,\newline 
$f(v)$ -- proměnná obsahující hodnotu $f(\key(v))$.

Uvedeme základní vlastnost leftist haldy, která 
umožňuje efektivní implementace operací. 
Posloupnost vrcholů $v_0,v_1,\dots,v_k$ se nazývá 
\emph{pravá} \emph{cesta} z vrcholu $v$, když $v=v_0$, $v_{i
+1}$ 
je pravý syn $v_i$ pro každé $i=0,1,\dots,k-1$ a $v_k$ nemá 
pravého syna. Pak podstrom vrcholu $v$ do hloubky $k$ je 
úplný binární strom a má tedy  
alespoň $2^{k+1}-1$ vrcholů. Proto platí 

\begin{tvrzeni}V leftist haldě je 
délka pravé cesty z každého vrcholu $v$ nejvýše rovna 
$$\log(\text{\rm velikost podstromu určeného vrcholem }v).$$
\end{tvrzeni}

\subsection{
Algoritmy a složitost operací
}

Základní operací pro leftist haldy je {\bf MERGE}. Tato 
operace je definována rekurzivně a hloubka rekurze je omezena 
právě délkami pravých cest.

{\bf MERGE$(T_1,T_2)$}:\newline 
{\bf if} $T_1=\emptyset$ {\bf then Výstup$=T_2$} konec {\bf endif\newline 
if} $T_2=\emptyset$ {\bf then Výstup$=T_1$} konec {\bf endif\newline 
if} $\key(\text{\rm kořen }T_1)>\key(\text{\rm kořen }T_2)$ {\bf then\newline 
\phantom{{\rm ---}}}zaměň $T_1$ a $T_2$\newline 
{\bf endif\newline 
$T':=$MERGE$(\text{{{\rm podstrom pravého syna kořene }}}T_1
,T_2)$\newline 
$\pravy(\text{\rm{{\rm kořen }}}T_1):=\text{\rm{{\rm kořen }}}
T'$\newline 
$\otec(\text{\rm {\rm kořen }}T'):=\text{\rm {\rm kořen }}T_
1$\newline 
if} $\npl(\pravy(\text{\rm kořen }T_1))>\npl(\levy(\text{\rm kořen }
T_1))$ {\bf then\newline 
\phantom{{\rm ---}}}vyměň levého a pravého syna kořene $
T_1$\newline 
{\bf endif\newline 
$\npl(\text{{\rm {\rm kořen }}}T_1):=\npl(\pravy(\text{{\rm {\rm kořen }}}
T_1)+1$

INSERT$(x)$}:\newline 
Vytvoř haldu $T_1$ reprezentující $\{x\}$\newline 
$\bold M\bold E\bold R\bold G\bold E(T,T_1)$

{\bf MIN}:\newline 
{\bf Výstup}: $\key(\text{\rm kořen }T)$

{\bf DELETEMIN}:\newline 
$T_1:=$podstrom levého syna kořene $T$\newline 
$T_2:=$podstrom pravého syna kořene $T$\newline 
{\bf MERGE$(T_1,T_2)$

MAKEHEAP$(S,f)$}:\newline 
$Q:=$prázdná fronta\newline 
{\bf for every} $s\in S$ {\bf do\newline 
\phantom{{\rm ---}}}vlož leftist haldu $T_s$ reprezentující $
\{s\}$ do $Q$\newline 
{\bf enddo\newline 
while} $|Q|>1$ {\bf do\newline 
\phantom{{\rm ---}}}vezmi haldy $T_1$ a $T_2$ z vrcholu $Q$ 
(odstraň je)\newline 
\phantom{---}{\bf MERGE$(T_1,T_2)$} vlož do $Q$\newline 
{\bf enddo

}
Vypočteme časovou složitost předchozích 
algoritmů. Každý běh 
algoritmu {\bf MERGE} (bez rekurzivního volání) vyžaduje čas 
$O(1)$. Počet rekurzivních volání je součet délek pravých 
cest, proto algoritmus {\bf MERGE} vyžaduje čas $O(\log(|S_
1|+|S_2|))$, 
kde $S_i$ je množina reprezentovaná haldou $T_i$ pro $i=1,2$.
Odtud dále plyne, že čas algoritmů {\bf INSERT} a 
{\bf DELETE\-MIN} je v 
nejhorším případě $O(\log(|S|))$. Operace {\bf MIN} vyžaduje 
čas $O(1)$. Pro odhad složitosti {\bf MA\-KEHEAP} budeme 
uvažovat, že na začátku algoritmu je na vrcholu fronty 
speciální znak, který se jen přenese na konec fronty. 
Odhadneme čas, který spotřebují {\bf while-}cykly mezi dvě\-ma 
přeneseními speciálního znaku. Předpokládejme, že se 
spe\-ciál\-ní znak přenesl po $k$-té. V tomto okamžiku 
mají všechny haldy ve frontě až na jednu velikost $2^{
k-1}$. 
Proto ve frontě $Q$ je $\big\lceil \frac {|S|}{2^{k-1}}\big\rceil $ hald a jelikož jedna operace 
{\bf MERGE} vyžadu\-je $O(k)$ času, tak {\bf while}-cykly vyžadují 
čas $O(k\frac {|S|}{2^{k-1}})$. Můžeme tedy shrnout, že operace 
{\bf MAKEHEAP} potřebuje čas 
$$O(\sum_{k=1}^{\infty}k\frac {|S|}{2^{k-1}})=O(|S|\sum_{k=1}^{\infty}\frac 
k{2^{k-1}})=O(|S|).$$
\v Rada $\sum_{k=1}^{\infty}$$\frac k{2^{k-1}}$ konverguje např. podle podílového d'Alambertova 
kritéria a lze jednoduše spočítat (např. stejnou metodou 
jako pro regulární haldy), že součet je $4$.

Implementace operací {\bf DECREASE} a {\bf INCREASE} pomocí 
operací {\bf UP} a {\bf DOWN} jako v $d$-regulárních haldách není 
efektivní, protože délka cesty z kořene do listu v leftist haldě 
může být až $|S|$.  Proto navrhneme pro tyto operace 
efektivnější algoritmus založený na jiném principu.  Tento princip 
je pak použit i pro Fibonacciho haldy.  

Nejprve popíšeme pomocnou operaci {\bf Oprav$(T,v
)$}, 
která vy\-tvo\-ří lef\-tist haldu z binárního stromu $
T'$ vzniklého z 
leftist haldy $T$ odtržením podstromu s kořenem ve vrcholu $
v$.

{\bf Oprav$(T,v)$}:\newline 
$t:=\otec(v)$, $\npl(t):=0$\newline 
{\bf if} $\pravy(t)\ne v$ {\bf then} $\levy(t):=\pravy(t)$ {\bf endif\newline 
$\pravy(t):=NIL$\newline 
while} se zmenšilo $\npl(t)$ a $t$ není kořen {\bf do\newline 
\phantom{{\rm ---}}$t:=\otec(t)$\newline 
\phantom{{\rm ---}}if} $\npl(\pravy(t))>\npl(\levy(t))$ {\bf then\newline 
\phantom{{\rm ------}}}vyměň $\levy(t)$ a $\pravy(t)$\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}$\npl(t):=\npl(\pravy(t))+1$\newline 
enddo

}
Po provedení operace {\bf Oprav} mají všechny vrcholy 
správné číslo $\npl$ a podmínky kladené na leftist 
haldu jsou splněny. Tedy po provedení {\bf Oprav }
je $T$ opět leftist halda. Když $t$ je poslední vrchol, u 
kterého se zmenšilo $\npl$, pak  všechny vrcholy, kde se zmenšilo 
$\npl$, tvoří pravou cestu z vrcholu $t$. To znamená, že 
{\bf while}-cyklus se prováděl nejvýše $\log(|S|)$-krát a každý 
běh {\bf while}-cyklu vyžadoval čas $O(1)$. Proto algoritmus 
{\bf Oprav} vyžaduje čas $O(\log(|S|))$.

Popíšeme ostatní algoritmy.

{\bf DECREASE$(s,a)$}:\newline 
$v:=$prvek reprezentující $s$\newline 
$T_1$$:=$podstrom $T$ určený vrcholem $v$, $f(v):=f(v)-a$\newline 
$T_2:=${\bf Oprav$(T,v)$}, $T:=${\bf MERGE$(T_1,T_2)$

INCREASE$(s,a)$}:\newline 
$v:=$prvek reprezentující $s$\newline 
$T_1:=$podstrom $T$ určený vrcholem $\levy(v)$\newline 
$T_2:=$podstrom $T$ určený  vrcholem $\pravy(v)$\newline 
$T_3:=$leftist halda reprezentující prvek $s$\newline 
$f(v):=f(v)+a$, $T_4:=${\bf Oprav$(T,v)$}, $T_1:=${\bf MERGE$(T_1
,T_3)$\newline 
$T_2:=$MERGE$(T_2,T_4)$}, $T:=${\bf MERGE$(T_1,T_2)$

DELETE$(s,a)$}:\newline 
$v:=$prvek reprezentující $s$\newline 
$T_1:=$podstrom $T$ určený vrcholem $\levy(v)$\newline 
$T_2:=$podstrom $T$ určený  vrcholem $\pravy(v)$\newline 
$T_3:=${\bf MERGE$(T_1,T_2)$}, $T_4:=${\bf Oprav$(T,v)$\newline 
$T:=$MERGE$(T_3,T_4)$

}
Protože algoritmy {\bf MERGE} a {\bf Oprav} vyžadují čas 
$O(\log(|S|)$ a protože zbylé části algoritmů pro operace 
{\bf DECREASE}, {\bf INCREASE} a {\bf DELETE} vyžadují $O(
1)$ času, 
můžeme shrnout výsledky:  

\begin{veta}V leftist haldách existuje implementace operace 
{\bf MIN}, která v nejhorším případě vyžaduje čas $
O(1)$, 
implementace ope\-rací {\bf INSERT}, {\bf DELETEMIN}, {\bf DELETE}, 
{\bf MER\-GE}, {\bf DECREA\-SE} a {\bf INCREA\-SE}, které vyžadují v nejhorším 
pří\-pa\-dě čas $O(\log(|S|))$, a implementace operace {\bf MAKE\-HEAP},
která vyžaduje čas $O(|S|)$, kde $S$ je reprezentovaná množina.
\end{veta}

\section{{Amortizovaná složitost}}

Popíšeme bankovní paradigma pro počítání s 
amortizovanou složitostí. Předpokládejme, že máme funkci $
h$, 
která ohodnucuje konfigurace a kvantitativně vystihuje 
jejich vhodnost pro provedení operace $o$. 
Když na konfiguraci $D$ aplikujeme operaci $o$ 
a dostaneme konfiguraci $D'$, pak amortizovaná složitost 
$am(o)$ ope\-race $o$ má vystihovat nejen časovou náročnost 
operace, ale i to, jak se změnila vhodnost konfigurace pro 
tuto operaci. Proto ji defi\-nujme jako $am(o)=t(o)+h(D')-h(D)$, kde $
t(o)$ je 
čas potřebný pro provedení operace $o$. Předpokládejme, 
že chceme provést posloupnost operací $o_1,o_2,\dots,o_n$ na 
konfiguraci $D_0$. Znázorníme si to takto:
$$D_0@>{o_1}>>D_1@>{o_2}>>D_2@>{o_3}>>\dots@>{o_n}>>D_n.$$
Předpokládejme, že pro každé $i=1,2,\dots,n$ máme odhad 
$c(o_i)$ amortizované složitos\-ti operace $o_i$, tj. $am(o_
i)\le c(o_i)$ 
pro všechna $i=1,2,\dots,n$. Pak
$$\sum_{i=1}^nam(o_i)=\sum_{i=1}^n\big(t(o_i)+h(D_i)-h(D_{i-1})\big
)=h(D_n)-h(D_0)+\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i).$$
Z toho plyne, že 
$$\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i)-h(D_n)+h(D_0).$$

Obvykle je $h(D)\ge 0$ pro všechny konfigurace $D$ 
nebo naopak $h(D)\le 0$ 
pro všechny konfigurace $D$. Když $h(D)\ge 0$, pak 
$$\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i)+h(D_0),$$
když $h(D)\le 0$, pak 
$$\sum_{i=1}^nt(o_i)\le\sum_{i=1}^nc(o_i)-h(D_n).$$
To znamená, že odhad amortizované složitosti dává také odhad 
na časovou složitost posloupnosti operací, který bývá lepší než odhad složitosti v 
nejhorším případě.  Tato skutečnost vysvětluje řadu 
případů, kdy 
výsledky byly lepší než teoretický výpočet.  Ukazuje se, že 
složitost posloupnosti operací v nejhorším případě je často podstatně 
menší než součet složitostí v nejhorším případě pro 
jednotlivé operace.  

\section{{Binomiální haldy}}

Další typ hald je motivován sčítaním přirozených čísel.  
Binomiální halda reprezentující $n-$prvkovou množinu se 
totiž chová 
podobně jako číslo $n$.  Tento typ hald je také po zobecnění v jistém 
smyslu vzorem pro Fibonacciho haldy.  

Pro $i=0,1,\dots$ definujeme rekurentně binomiální 
stromy $H_i$.  Jsou to kořenové stromy takové, že $H_0$ je 
jednoprvkový strom a  strom $H_{i+1}$ vznikne ze dvou 
disjunktních stromů $H_i$, kde kořen jednoho stromu  
se stane dalším synem (nejlevějším nebo nejpravějším) kořene druhého stromu.  Viz 
Obr.  1. 

\midinsert
\centerline{\input fig10.tex}
\botcaption{Obr. 1}
\endcaption
\endinsert

Nejprve uvedeme základní vlastnosti těchto 
stromů.

\begin{tvrzeni}Pro každé přirozené číslo $
i=0,1,\dots$ 
platí:
\begin{enumerate}
\item
strom $H_i$ má $2^i$ vrcholů,
\item
kořen stromu $H_i$ má $i$ synů,
\item
délka nejdelší cesty z kořene do listu ve stromu $H_i$ je 
$i$ (tj. výška $H_i$ je $i$),
\item
podstromy určené syny kořene stromu $H_i$ jsou izomorf\-ní 
se stromy $H_0,H_1,\dots,H_{i-1}$.
\end{enumerate}
\end{tvrzeni}

\begin{proof}Tvrzení platí pro strom $H_0$ a 
jednoduchou indukcí se dokáže i pro další stromy. 
Skutečně, když $H_i$ má $2^i$ vrcholů, pak $H_{
i+1}$ má 
$2(2^i)=2^{i+1}$ vrcholů. Kořen stromu $H_{i+1}$ má o jednoho 
syna více než kořen stromu $H_i$ a nejdelší cesta do listu je o $
1$ 
delší. Protože podstrom syna, který přibyl kořeni stromu 
$H_{i+1}$, je izomorfní s $H_i$ a jinak se nic neměnilo, je 
důkaz kompletní. \qed
\end{proof}

\emph{Binomiální} \emph{halda} $\Cal H$ reprezentující 
množinu $S$ je soubor (seznam) stromů $\{T_1,T_2,\dots
,T_k\}$ 
takový, že 
\begin{enumerate}
\item"{}"
celkový počet vrcholů v těchto stromech je 
roven velikosti $S$ a 
existuje a je dáno jednoznačné přiřazení prvků 
z $S$ vrcholům stromů takové, že platí 
podmínka \thetag{usp} -- toto přiřazení je realizováno 
funkcí 
$\key,$ která vrcholu stromu přiřazuje prvek jím reprezentovaný;
\item"{}"
každý strom $T_i$ je izomorfní s nějakým stromem $H_
j$;
\item"{}"
$T_i$ není izomorfní s žádným $T_j$ pro $i\ne j$.
\end{enumerate}

Z binárního zápisu přirozených čísel plyne, že 
pro každé přiro\-ze\-né číslo $n>0$ existuje prostá 
posloupnost $i_1,i_2,\dots,i_k$ přiro\-ze\-ných čísel taková, že 
$n=\sum_{j=1}^k2^{i_j}$. Z toho plyne, že pro každou neprázd\-nou 
množinu $S$ existuje binomiální halda repre\-zentující $
S$.
Tato halda obsahuje strom izomorfní s $H_i$, právě když v 
binárním zápise čísla $|S|$ je na $i$-tém místě zprava $
1$.

\subsection{
Algoritmy a složitost operací
}

Operace pro binomiální haldy jsou  
stejně jako pro leftist haldy založeny na ope\-raci {\bf MER\-GE}. Ope\-race 
{\bf MERGE} pro binomiální haldy je analogií sčítání 
přirozených čísel v binár\-ním zápise.

{\bf MERGE$(\Cal H_1,\Cal H_2)$}:\newline 
(komentář: $\Cal H_i$ reprezentuje množinu $S_i$ pro $i=1
,2$ a $S_1\cap S_2=\emptyset$)\newline 
$i:=0$, $T:=$prázdný strom, $\Cal H:=\emptyset$\newline 
{\bf while} $i<\log(|S_1|+|S_2|)$ {\bf do\newline 
\phantom{{\rm ---}}if} existuje $U\in \Cal H_1$ izomorfní s $
H_i$ {\bf then\newline 
\phantom{{\rm ------}}$U_1:=U$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}$U_1:=$}prázdný strom\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}if} existuje $U\in \Cal H_2$ izomorfní s $
H_i$ {\bf then\newline 
\phantom{{\rm ------}}$U_2:=U$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}$U_2:=$}prázdný strom\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}case\newline 
\phantom{{\rm ------}}}(existuje právě jeden neprázdný strom 
$V\in \{T,U_1,U_2\}$) {\bf do}:\newline 
\phantom{---------}vlož $V$ do $\Cal H$, $T:=$prázdný strom\newline 
\phantom{------}(existují právě dva neprázdné stromy 
$V_1,V_2\in \{T,U_1,U_2\})$ {\bf do}:\newline 
\phantom{---------}$T:=${\bf spoj$(V_1,V_2)$\newline 
\phantom{{\rm ------}}}(všechny stromy $T$, $U_1$ a $U_2$ jsou neprázdné) {\bf do}:\newline 
\phantom{---------}vlož $T$ do $\Cal H$, $T:=${\bf spoj$(U_1,U_
2)$\newline 
\phantom{{\rm ---}}endcase\newline 
\phantom{{\rm ---}}$i:=i+1$\newline 
enddo\newline 
if} $T\ne$prázdný strom {\bf then} vlož $T$ do $\Cal H$ {\bf endif\newline 
Výstup}:$\Cal H$

{\bf spoj$(T_1,T_2)$}:\newline 
{\bf if} $f(\text{\rm kořen }T_1)>f(\text{\rm kořen }T_2)$ {\bf then\newline 
\phantom{{\rm ---}}}vyměň stromy $T_1$ a $T_2$\newline 
{\bf endif\newline 
}
vytvoř nového  syna $v$ kořene $T_1$\newline 
$v:=$kořen $T_2$

Je vidět, že když oba stromy $T_1$ a $T_2$ jsou izomorfní 
s $H_i$, pak výsledný strom operace {\bf spoj} je izomorfní 
s $H_{i+1}$. Korektnost ope\-race {\bf MERGE} plyne z tohoto 
pozorování a z faktu, že $\Cal H_j$ obsahuje strom izomorfní s 
$H_i$, právě když v binárním zápise čísla $
|S_j|$ je na $i$-tém 
místě zprava $1$, a že $T$ je neprázdný strom, když se 
provádí posun řádu při sčítání. Protože každý běh 
cyklu vyžaduje čas $O(1)$, algoritmus {\bf MER\-GE} vyžaduje čas 
$O(\log(|S_1|+|S_2|))$. Implementace dalších algoritmů 
je podobná jako pro leftist haldy. 

{\bf INSERT$(x)$}:\newline 
Vytvoř haldu $\Cal H_1$ reprezentující $\{x\}$\newline 
$\bold M\bold E\bold R\bold G\bold E(\Cal H,\Cal H_1)$

{\bf MIN}:\newline 
Prohledej prvky reprezentované kořeny všech stromů 
v $\Cal H$\newline 
{\bf Výstup}: nejmenší z těchto prvků  

{\bf DELETEMIN}:\newline 
Prohledej prvky reprezentované kořeny všech stromů 
v $\Cal H$\newline 
$T:=$ strom, jehož kořen reprezentuje nejmenší prvek\newline 
$\Cal H_1:=\Cal H\setminus \{T\}$\newline 
$\Cal H_2:=$ halda tvořená podstromy $T$ určenými syny kořene $
T$\newline 
{\bf MERGE$(\Cal H_1,\Cal H_2)$

}
Z podmínky \thetag{usp} je zřejmé, že 
nejmenší prvek v $S$ je reprezentován v kořeni nějakého  
stromu haldy. Tím je dána korekt\-nost operace {\bf MIN}.
Z úvodního tvrzení plyne, že $\Cal H_2$ v operaci {\bf DELE\-TE\-MIN} je 
binomiální halda, a odtud plyne korekt\-nost ope\-race 
{\bf DE\-LE\-TEMIN}. Operace {\bf DECREASE} se implementuje pomocí 
ope\-race {\bf UP} a ope\-race {\bf INCREASE} pomocí 
operace {\bf DOWN} stejně jako v regulárních haldách. 
Struktura binomiální haldy nepodporuje přímo operaci 
{\bf DELETE} -- ta se dá realizovat jedině jako posloupnost 
operací {\bf DECREASE$(s,\infty )$} a {\bf DELETEMIN}.  
Operace {\bf MAKEHEAP} se provádí opakováním operace {\bf INSERT}.

Výpočet časové složitosti operací pro binomiální haldy 
využívá několik známých faktů.  Ope\-race {\bf MERGE }
simuluje sčítání přirozených čísel v binárním zápise a má 
tedy stejnou složitost.  Odhad složitosti vytváření haldy využívá 
známého faktu, že amortizovaná složitost přičítání $
1$  
k binárnímu číslu je $O(1)$.  
Odhad složitosti operací {\bf MIN} a {\bf DELETEMIN} je založen na 
pozorování, že binomiální halda reprezentující množinu $
S$ má 
tolik stromů, kolik je jedniček v binárním zápise $
|S|$, a 
to je nejvýše $\log(|S|)$.  

Z tvrzení také plyne, že výška všech stromů v 
binomiální haldě je $\le\log(|S|)$ a počet synů 
kořene každého stromu je 
také $\le\log(|S|)$, přičemž tento odhad se nedá zlepšit. Odtud 
dostáváme složitost operací {\bf DECREASE} a {\bf INCREASE} v nejhorším 
případě. Můžeme tedy shrnout:

\begin{veta}Pro binomiální haldy algoritmy operací 
{\bf IN\-SERT}, {\bf MIN}, {\bf DELETEMIN}, {\bf DECREASE} a {\bf MERGE  }
vy\-ža\-dují čas $O(\log(|S|))$, algoritmus operace {\bf INCRE\-ASE }
vy\-ža\-duje čas $O(\log^2(|S|))$ a algoritmus operace {\bf MAKEHEAP 
}čas $O(|S|)$.
\end{veta}

Z těchto výsledků je vidět, že předchozí 
typy hald mají efektivnější chování než binomiální haldy. 
Význam binomiálních hald tak spo\-čí\-vá především v 
tom, že se dají dále zobecnit (tímto zobecněním jsou Fibonacciho 
haldy) a že na nich lze krásně 
ilustrovat princip, že s řadou úprav je výhodné počkat 
a neprovádět je okamžitě.

\subsection{
Líná implentace operací
}

Následující algoritmy jsou založeny na ideji, že 
`vyvažování' stačí provádět jen při operacích {\bf MIN} a 
{\bf DELETEMIN}, kdy je stejně zapotřebí prohledat všechny 
stromy. Z tohoto důvodu zeslabíme podmínky na 
binomiální haldy.

\emph{Líná} \emph{binomiální} \emph{halda} $\Cal H$ 
reprezentující množinu $S$ je seznam stromů 
$\{T_1,T_2,\dots,T_k\}$ takový, že  
\begin{enumerate}
\item"{}"
celkový počet vrcholů v těchto stromech je 
roven velikosti $S$ a 
existuje jednoznačné přiřazení prvků množiny 
$S$ vrcholům stromů, které splňuje 
podmínku \thetag{usp} -- toto přiřazení je jako obvykle 
realizováno funkcí $\key$;
\item"{}"
každý strom $T_i$ je izomorfní s nějakým stromem $H_
j$.
\end{enumerate}

V líné binomiální haldě je vynechán předpoklad 
neizo\-morf\-nosti stromů tvořících haldu. Tento fakt se 
projeví ve velmi jednoduchém algoritmu pro operaci 
{\bf MERGE}.

{\bf MERGE$(\Cal H_1,\Cal H_2)$}:\newline 
Prove\v d konkatenaci seznamů $\Cal H_1$ a $\Cal H_2$

Samotný algoritmus pro operaci {\bf INSERT} se nezmění, jen 
provede tuto implementaci ope\-race {\bf MER\-GE}.  Ope\-race 
{\bf MIN} a {\bf DELETE\-MIN} použijí následující pomocnou 
proceduru {\bf vyvaz}.  Jejím vstu\-pem je soubor 
seznamů $\{O_i\mid i=0,1,\dots,k\}$, kde seznam $O_i$ 
obsahuje jen stromy izomorfní se stromem $H_i$.  
Procedura {\bf vyvaz} pak z těchto stromů vytvoří 
klasickou binomiální hal\-du. 

{\bf vyvaz$(\{O_i\mid i=0,1,\dots,k\})$}:\newline 
$i:=0$, $\Cal H:=\emptyset$\newline 
{\bf while} existuje $O_i\ne\emptyset$ {\bf do\newline 
\phantom{{\rm ---}}while} $|O_i|>1$ {\bf do\newline 
\phantom{{\rm ------}}}vezmi dva různé stromy $T_1$ a $
T_2$ z 
$O_i$\newline 
\phantom{------}odstraň je z $O_i$\newline 
\phantom{------}{\bf spoj$(T_1,T_2)$} vlož do $O_{i+1}$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}if} $O_i\ne\emptyset$ {\bf then\newline 
\phantom{{\rm ------}}}strom $T\in O_i$ odstraň z $O_i$ a vlož do $
\Cal H$\newline 
\phantom{---}{\bf endif},\newline 
\phantom{---}$i:=i+1$\newline 
{\bf enddo\newline 
Výstup}: $\Cal H$

{\bf MIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů  
v $\Cal H$\newline 
{\bf Výstup}: nejmenší z těchto prvků\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\Cal H$ izomorfní s $H_i\}$\newline 
{\bf vyvaz$(\{O_i\mid i=0,1,\dots,\lfloor\log(|S|)\rfloor \})$

DELETEMIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů v $\Cal H$\newline 
$T:=$ strom, jehož kořen repre\-zentuje nejmenší 
prvek\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\Cal H$ izomorfní s $H_i$ různé od $T\}\cup \{$podstrom $
T$ určený nějakým synem kořene $T$ 
izomorfní s $H_i\}$\newline 
{\bf vyvaz$(\{O_i\mid i=0,1,\dots,\lfloor\log(|S|)\rfloor \})$

}\v Casová složitost operací {\bf INSERT} a {\bf MER\-GE} při líné 
implementaci je $O(1)$, ale časová složitost operací {\bf MIN} a 
{\bf DELETEMIN} je v nejhorším případě $O(|S|)$. Tento odhad je 
velmi špatný, ale ukážeme, že amortizovaná složitost má rozumné 
hodnoty. 
Připomínáme, že amortizovaná složi\-tost je čas operace plus 
ohodnocení výsledné struktury minus ohodnocení 
počáteční struktury. 
Konfiguraci ohodnotíme počtem stromů v 
haldě. 
Protože ope\-race {\bf MERGE} nemění počet stromů a 
protože operace {\bf INSERT} přidá jen jeden strom, je 
amortizovaná složitost operací {\bf MERGE} a {\bf INSERT} stále $
O(1)$.
Ukážeme, že amortizovaná složitost operací {\bf MIN} a {\bf DELETEMIN }
při líné implementaci binomiálních hald je $O(\log
(|S|)$. 
Protože každý běh 
vnitřního {\bf while}-cyklu v operaci {\bf vyvaz} vyžaduje čas $
O(1)$ 
a zmenší počet stromů v seznamech $O_i$ o $1$, 
ope\-ra\-ce {\bf vyvaz} vyžaduje čas $O(k+\sum_{i=0}^k|O_i|
)$. Ope\-ra\-ce {\bf MIN}
bez podprocedury {\bf vyvaz} vyžaduje čas $O(|\Cal H|)$ a operace 
{\bf DELETEMIN} bez podprocedury {\bf vyvaz }čas $O(\Cal H+i)$ pro 
takové $i$, že $T$ je izomorfní s $H_i$. Podle tvrzení je $
i\le\log(|S|)$, a 
tedy ope\-ra\-ce {\bf MIN} vyžaduje čas $O(|\Cal H|)$ a ope\-race 
{\bf DELETEMIN }čas $O(|\Cal H|+\log(|S|))$. Protože  
ohodnocení klasické binomiální haldy je nejvýše $\log
(|S|)$ 
(obsahuje tolik stromů, kolik je $1$ v binárním zápise 
čísla $|S|$), dostáváme, že amortizovaná složitost ope\-race {\bf MIN} je 
$O(|\Cal H|-|\Cal H|+\log(|S|))=O(\log(|S|))$ a amortizovaná složitost 
operace {\bf DELETEMIN} je $O(|\Cal H|+\log(|S|)-|\Cal H|+\log(|S
|))=O(\log(|S|))$.

Protože si funkci ohodnocení volíme, 
můžeme použít takové multiplikativní 
koeficienty, aby jednotka času odpovídala jednotce v 
amortizované složitosti. Proto lze $|\Cal H|$ od sebe odečíst.

\section{{Fibonacciho haldy}}

Význam Fibonacciho hald určuje fakt, že amortizovaná 
složitost operací {\bf INSERT} a {\bf DECREASE} v těchto haldách je 
$O(1)$ a amortizovaná složitost operace {\bf DELETEMIN} je $
O(\log(|S|)$. 
Proto se hodně používají v grafových algoritmech, 
kde umožňují v mnoha případech dosáhnout asymptoticky téměř lineární 
složitosti. Neznáme však žádné  
expe\-rimentální výsledky, které by porovnávaly použití Fibonacciho 
hald a např. $d$-regulárních hald v těchto grafových 
algoritmech v praxi. Takže neznáme podmínky, za 
kterých jsou Fibonacciho 
haldy lepší než třeba $d$-regulární haldy, 
ani nevíme, do jaké míry je to jen teoretický 
výsledek a do jaké míry jsou opravdu prakticky použitelné. 

Neformálně řečeno, je Fibonacciho halda množina 
stromů, jejichž některé vrcholy různé od 
kořenů jsou označeny, a kde existuje 
jednoznačná korepondence mezi prvky $S$ a vrcholy 
stromů (realizována funkcí $\key$), která splňuje 
podmínku \thetag{usp}.  Toto je však jen přibliž\-né 
vyjádření.  Existují totiž struktury, na které se tento 
popis hodí, ale 
nevznikly z prázd\-né Fibonacciho haldy aplikací 
posloupnosti haldových  
operací.  Přitom důkaz efekti\-vity Fibonacciho hald se 
dosti výrazně opírá o fakt, že halda vznikla z prázdné 
haldy aplikací algoritmů pro Fibonacciho 
haldy. Proto nejprve popíšeme algoritmy pro tyto 
ope\-race, a pak budeme
definovat \emph{Fibonacciho} \emph{haldy} jako struktury 
vzniklé z prázdné haldy aplikací posloupnosti 
těchto algoritmů.

\subsection{
Algoritmy
}

V algoritmech předpokládáme, že Fibonacciho halda je 
seznam stromů, kde některé vrcholy různé od 
kořenů jsou označeny.  Vrchol je označen, právě když není 
kořen a když mu byl někdy dříve odtržen některý jeho syn. Toto se 
nezaznamenává pro kořeny stromů. Proto když se 
vrchol stane kořenem (odtržením podstromu určeného 
tímto vrcholem),  
zapomene  se tento údaj a začne se znovu zaznamenávat, 
až když vrchol přestane 
být kořenem. \v Rekneme, že strom má \emph{rank} $i$, když 
jeho kořen 
má $i$ synů. Tento fakt nahrazuje test používaný 
v binomiálních 
haldách, že strom je izomorfní se stromem $H_i$. 

Algoritmy pro operace {\bf MERGE}, {\bf INSERT}, {\bf MIN} a 
{\bf DELE\-TEMIN} jsou založeny na stejných idejích jako algoritmy pro línou implementaci 
v binomiálních haldách, pouze poža\-da\-vek, aby strom byl 
izomorfní s $H_i$, je nahrazen požadavkem, že má rank $
i$. 
Algoritmy pro ope\-race {\bf DECREASE}, {\bf INCREASE} a {\bf DELETE }
vycházejí z algoritmů pro tyto operace v leftist 
haldách. V algoritmech předpokládáme, že $c=\log^{-1}
(\frac 32)$.

{\bf MERGE$(\Cal H_1,\Cal H_2)$}:\newline 
Prove\v d konkatenaci seznamů $\Cal H_1$ a $\Cal H_2$

{\bf INSERT$(x)$}:\newline 
Vytvoř haldu $\Cal H_1$ reprezentující $\{x\}$\newline 
$\bold M\bold E\bold R\bold G\bold E(\Cal H,\Cal H_1)$

{\bf MIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů v $\Cal H$\newline 
{\bf Výstup}: nejmenší z těchto prvků\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\Cal H$ s rankem $i\}$\newline 
{\bf vyvaz1$(\{O_i\mid i=0,1,\dots,\lfloor c\log(\sqrt 5|S|+1)\rfloor 
\})$

DELETEMIN}:\newline 
Prohledej prvky reprezentované kořeny všech 
stromů v $\Cal H$\newline 
$T:=$ strom, jehož kořen reprezentuje nejmenší 
prvek\newline 
stromy rozděl do množin $O_i=\{$všechny stromy v 
$\Cal H$ s rankem $i$ různé od $T\}\cup \{$podstrom $T$ určený 
některým synem kořene $T$ s 
rankem $i$$\}$\newline 
{\bf vyvaz1$(\{O_i\mid i=0,1,\dots,\lfloor c\log(\sqrt 5|S|+1)\rfloor 
\})$

vyvaz1$(\{O_i\mid i=0,1,\dots,k\})$}:\newline 
$i:=0$, $\Cal H:=\emptyset$\newline 
{\bf while} existuje $O_i\ne\emptyset$ {\bf do\newline 
\phantom{{\rm ---}}while} $|O_i|>1$ {\bf do\newline 
\phantom{{\rm ------}}}vezmi dva různé stromy $T_1$ a $
T_2$ z 
$O_i$\newline 
\phantom{------}odstraň je z $O_i$\newline 
\phantom{------}{\bf spoj$(T_1,T_2)$} vlož do $O_{i+1}$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}if} $O_i\ne\emptyset$ {\bf then\newline 
\phantom{{\rm ------}}}strom $T\in O_i$ odstraň z $O_i$ a vlož ho do $
\Cal H$\newline 
\phantom{---}{\bf endif\newline 
\phantom{{\rm ---}}$i:=i+1$\newline 
enddo\newline 
Výstup}: $\Cal H$

{\bf spoj$(T_1,T_2)$}:\newline 
{\bf if} $f(\text{\rm kořen }T_1)>f(\text{\rm kořen }T_2)$ {\bf then\newline 
\phantom{{\rm{\rm ---}}}}vyměň stromy $T_1$ a $T_2$\newline 
{\bf endif\newline 
}
vytvoř nového syna $v$ kořene $T_1$\newline 
$v:=$kořen $T_2$

{\bf DECREASE$(s,a)$}:\newline 
$T:=$strom v $\Cal H$, který obsahuje vrchol reprezentující $
s$\newline 
$v:=$vrchol stromu $T$ reprezentující $s$\newline 
{\bf if} $v$ není kořen {\bf then \newline 
\phantom{{\rm ---}}}odtrhni podstrom $T'$ určený vrcholem $v$\newline 
\phantom{---}{\bf vyvaz2$(T,v)$\newline 
\phantom{{\rm ---}}if} $v$ byl označen {\bf then} zruš označení $
v$ {\bf endif\newline 
\phantom{{\rm ---}}}vlož $T'$ do $\Cal H$\newline 
{\bf endif\newline 
$f(v):=f(v)-a$

INCREASE$(s,a)$}:\newline 
$T:=$strom v $\Cal H$, který obsahuje vrchol reprezentující $
s$\newline 
$v:=$vrchol stromu $T$ reprezentující $s$\newline 
{\bf if} $v$ není list {\bf then \newline 
\phantom{{\rm ---}}}odtrhni podstrom $T'$ určený vrcholem $v$\newline 
\phantom{---}{\bf if} $v$ není kořen {\bf then vyvaz2$(T,v
)$ endif\newline 
\phantom{{\rm ---}}if} $v$ byl označen {\bf then} zruš označení $
v$ {\bf endif\newline 
\phantom{{\rm ---}}}zruš označení všech synů vrcholu $
v$\newline 
\phantom{---}odtrhni podstromy $T'$ určené všemi syny $v$ 
a vlož je do $\Cal H$\newline 
\phantom{{\bf ---}}do $\Cal H$ vlož strom mající jen vrchol $
v$\newline 
{\bf endif\newline 
$f(v):=f(v)+a$

DELETE$(s)$}:\newline 
$T:=$strom v $\Cal H$, který obsahuje vrchol reprezentující $
s$\newline 
$v:=$vrchol stromu $T$ reprezentující $s$\newline 
{\bf if} $v$ není list {\bf then\newline 
\phantom{{\rm ---}}}zruš označení synů vrcholu $
v$\newline 
\phantom{---}odtrhni podstromy určené všemi syny 
vrcholu $v$ a vlož je do $\Cal H$\newline 
{\bf endif\newline 
if} $v$ není kořen {\bf then vyvaz2$(T,v)$ endif\newline 
}
zruš vrchol $v$

{\bf vyvaz2$(T,v)$}:\newline 
$u:=\otec v$\newline 
{\bf while} $u$ je označen {\bf do\newline 
\phantom{{\rm ---}}$u':=\otec(u)$}, zruš označení $u$\newline 
\phantom{---}odtrhni podstrom $T'$ určený vrcholem $u$\newline 
\phantom{---}vlož $T'$ do $\Cal H$, $u:=u'$\newline 
{\bf enddo\newline 
if} $u$ není kořen $T$ {\bf then} označ $u$ {\bf endif

}
Všimněme si, že když stromy $T_1$ a $T_2$ mají rank 
$i$, pak procedura {\bf spoj$(T_1,T_2)$} vytvoří strom s rankem 
$i+1$.  Aby algoritmy pro operace {\bf MIN} a {\bf DELETEMIN} byly 
korektní, musíme ukázat, že všechny stromy ve 
Fibonacciho haldě $\Cal H$ reprezentující množinu $
S$ mají rank 
nejvýše $c\log(\sqrt 5|S|+1)$. Jen tak zajistíme, aby výsledná 
halda reprezentovala $S$, res\-pektive 
$S\setminus \{\text{\rm prvek s nejmenší hodnotou }f\}$.  Operace {\bf vyvaz1 }
zajišťuje, že od každého vrcholu stromu různého 
od kořene byl v tomto stromě odtržen podstrom nejvýše 
jednoho syna -- v tom případě je tento prvek označen a 
když se mu odtrhává podstrom dalšího syna, bude odtržen 
i celý podstrom tohoto vrcholu (tím se tento vrchol stane kořenem 
stromu).  Když se později stane tento vrchol zase 
vrcholem různým od kořene, celý proces se 
opakuje. 

\subsection{
Složitost operací
}

Naším cílem bude odhadnout amortizovanou složitost těchto 
operací, protože složitost v nejhorším případě není 
použitelný výsledek.  Abychom to mohli udělat, spočítáme parametry 
složitosti jednotlivých operací:  

{\bf MERGE} -- časová složitost $O(1)$, nevzniká žádný 
nový strom, 
ozna\-če\-né vrcholy se nemění;\newline 
{\bf INSERT} -- časová složitost $O(1)$, přibyl jeden strom, 
označené vrcholy se nemění;\newline 
{\bf MIN} -- časová složitost $O(|\Cal H|)$, po provedení operace 
různé stro\-my v haldě mají různé 
ranky, označené vrcholy se nemění;\newline 
{\bf DELETEMIN} -- časová složitost $O(|\Cal H|+\text{\rm počet synů }
v)$,
kde $v$ reprezentoval prvek s nej\-menší hodnotou $f$. Po 
provedení ope\-ra\-ce různé stromy v haldě mají 
různé ranky, žádný nový vrchol nebyl 
označen, některé označené vrcholy přestaly být označené;\newline 
{\bf DECREASE} -- časová složitost $O(1+c)$, kde $c$ je počet 
vrcholů, které přestaly být označené. 
Bylo přidáno $1+c$ nových stromů a byl označen 
nejvýše jeden vrchol;\newline 
{\bf INCREASE} -- časová složitost $O(1+c+d)$, kde $c$ je počet 
vrcholů, které přestaly být označené, $d$ je 
počet synů vrcholu $v$ reprezentujícího prvek, 
jehož hodnota se zvyšuje. Bylo přidáno nejvýše $1
+c+d$ 
nových stromů a byl označen nejvýše jeden 
vrchol;\newline 
{\bf DELETE} -- časová složitost $O(1+c+d)$, kde $c$ je počet 
vrcholů, které přestaly být označené, $d$ je 
počet synů vrcholu $v$ reprezentujícího prvek, 
který se má odstranit. Bylo přidáno nejvýše $c+d$ 
nových stromů a byl označen nejvýše jeden 
vrchol.

Pro výpočet amortizované složitosti 
musíme nejprve navrhnout funkci ohodnocující 
konfigurace.  Při vyšetřování líné implementace binomiálních 
hald se ukázalo, že vhodným ohodnocením je počet stromů 
v haldě. Když si ale prohlédneme algoritmus pro operaci 
{\bf DECREASE}, vidíme, že zde je vhodné brát do ohodnocení i 
počet označených vrcholů, a to dokonce tak, aby 
se pokryl 
nejen čas, ale i přírůstek stromů. To vede k 
následujícímu ohodnocení konfigurace: ohodnocení je počet 
stromů v konfiguraci plus dvojnásobek počtu 
označených vrcholů.

Nechť $\rho (n)$ je maximální 
počet synů vrcholu ve Fibonacciho haldě 
reprezentující $n$-prvkovou množinu.  Pak amortizovaná 
složitost operací {\bf MERGE}, {\bf INSERT} a {\bf DECREASE} je $
O(1)$ a 
operací {\bf MIN}, {\bf DELETEMIN}, {\bf INCREASE} a {\bf DELETE} je $
O(\rho (n))$.

Abychom spočítali odhad $\rho (n)$, využijeme toho, že 
Fibonacciho halda vznikla z prázdné haldy pomocí 
popsaných algoritmů. Nejprve uvedeme jedno technické 
lemma.

\begin{lemma}Nechť $v$ je vrchol stromu ve 
Fibonacciho haldě a nechť $u$ je $i$-tý nejstarší syn 
vrcholu $v$. Pak $u$ má aspoň $i-2$ synů.
\end{lemma}

\begin{proof}V momentě, kdy se $u$ stával synem $v$, se 
aplikovala operace {\bf spoj}, $u$ a $v$ byly kořeny 
stromů a měly stejný počet synů. 
Podle předpokladů měl vrchol $v$ alespoň $i-1$ 
synů (jinak by $u$ nebyl $i$-tý nejstarší syn), a 
protože se od $u$ mohl odtrhnout jen jeden syn, 
dostáváme, že $u$ musí mít alespoň $i-2$ synů. \qed
\end{proof}

\begin{tvrzeni}Nechť $v$ je vrchol stromu ve 
Fibonacciho haldě, kte\-rý má právě $i$ synů. Pak 
podstrom určený vrcholem $v$ má aspoň $F_{i+2}$ 
vrcholů.
\end{tvrzeni}

\begin{proof}Tvrzení dokážeme indukcí 
podle maximální délky cesty z vrcholu $v$ do některého 
listu.  Tato délka je $0$, právě když $v$ je list.  V tom 
případě $v$ nemá syna a podstrom určený vrcholem $
v$ má 
jediný vrchol.  Protože $1=F_2=F_{0+2}$, tvrzení platí.  
Mějme nyní vrchol $v$, který má $k$ 
synů, a nechť maximální délka cesty z vrcholu $
v$ do 
listů je $j$. Předpokládej\-me, že tvrzení platí pro 
všechny vrcholy, pro něž tato délka  
je menší než $j$,  tedy platí i pro 
všechny syny vrcholu $v$.  Pak pro $i>1$ má $i$-tý nejstarší 
syn vrcholu $v$ podle předchozího lemmatu alespoň $i-2$ 
synů a podle indukčního předpokladu podstrom určený 
tímto synem má alespoň $F_i$ vrcholů.  Odtud 
dostáváme, že podstrom určený vrcholem $v$ má alespoň 
$$1+F_2+\sum_{i=2}^kF_i=1+\sum_{i=1}^kF_i$$
vrcholů, protože $F_1=F_2$ (na levé straně první $
1$ 
je za vrchol $v$ a 
první $F_2$ je za nejstarší vrchol). Indukcí pak dostaneme, že 
$$1+\sum_{i=1}^nF_i=F_{n+2}$$
pro všechna $n\ge 0$. Skutečně, pro $n=0$ platí 
$$1+\sum_{i=1}^0F_i=1=F_2=F_{0+2},$$
pro $n=1$ máme 
$$1+\sum_{i=1}^1F_i=1+F_1=2=F_3=F_{1+2}$$
a z indukčního předpokladu a z vlastností Fibonacciho 
čísel plyne, že 
$$1+\sum_{i=1}^nF_i=1+\sum_{i=1}^{n-1}F_i+F_n=F_{n+1}+F_n=F_{n+2}
.$$
Když shrneme tato fakta, dostáváme, že podstrom 
určený vrcholem $v$ má alespoň $F_{i+2}$ vrcholů, a 
tvrzení je dokázáno. \qed
\end{proof}

Vezměme nyní nejmenší $i$ takové, že $
n<F_i$. Protože 
posloupnost $\{F_i\}_{i=1}^{\infty}$ je rostoucí, plyne z předchozího 
tvrzení, že každý vrchol ve Fibonacciho haldě 
reprezentující $n-$prvkovou množinu má méně než $
i-2$ 
synů (když vrchol $v$ Fibonacciho haldy má $i-2$ 
synů, pak podstrom vrcholu $v$ reprezentuje 
množinu alespoň s $F_i$ prvky). Proto $\rho (n)<i-2$. K odhadu 
velikosti $i$ použijeme explicitní vzorec 
pro $i$-té Fibonacciho číslo: 
$$F_i=\frac {\big(\frac {1+\sqrt 5}2\big)^i-\big(\frac {1-\sqrt 5}
2\big)^i}{\sqrt 5}=\frac 1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i
-\frac 1{\sqrt 5}\big(\frac {1-\sqrt 5}2\big)^i.$$
Protože $0>\frac {1-\sqrt 5}2>-\frac 34$ a protože $\sqrt 5
>2$, dostáváme, že $|\frac 1{\sqrt 5}\big(\frac {1-\sqrt 5}
2\big)^i|<\frac 38$ pro všechna 
$i=1,2,\dots$, a tedy 
$$\frac 1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i-\frac 38<F_i<\frac 
1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i+\frac 38.$$
Odtud plyne, že když $i$ splňuje 
$$n\le\frac 1{\sqrt 5}\big(\frac {1+\sqrt 5}2\big)^i-\frac 38,$$
pak $n<F_i$. 
Převedením $\frac 38$ na druhou stranu výrazu, jeho 
vynásobením $\sqrt 5$ a zlogaritmováním dostaneme následující 
ekvivalenci: 
$$\log_2(\sqrt 5n+\frac {3\sqrt 5}8)\le i\log_2\big(\frac {1+\sqrt 
5}2\big)\quad\Leftrightarrow\quad n\le\frac 1{\sqrt 5}\big(\frac {
1+\sqrt 5}2\big)^i-\frac 38.$$
Z $\frac {3\sqrt 5}8<1$ a z $\frac 32<\frac {1+\sqrt 5}2$ plyne, že 
$$\frac {\log_2(\sqrt 5n+\frac {3\sqrt 5}8)}{\log_2\frac {1+\sqrt 
5}2}<\frac {\log_2(\sqrt 5n+1)}{\log_2\frac 32}.$$
Tedy platí následující implikace
$$\frac {\log_2(\sqrt 5n+1)}{\log_2\frac 32}<i\quad\implies\frac {\log_
2(\sqrt 5n+\frac {3\sqrt 5}8)}{\log_2\big(\frac {1+\sqrt 5}2\big)}
<i.$$
Proto když $\frac {\log_2(\sqrt 5n+1)}{\log_23-1}<i$, pak $n<F_
i$, a tedy $\rho (n)<i-2$.

Výsledky shrneme do následující věty: 

\begn{veta}Ve Fibonacciho haldě, která   
reprezentuje $n$-prvkovou množinu, má každý vrchol 
stu\-peň menší než 
$$\frac {\log_2(\sqrt 5n+1)}{(\log_23)-1}-2.$$
Amortizovaná složitost operací {\bf INSERT}, {\bf MERGE} a {\bf DECREASE }
je $O(1)$ a amortizovaná složitost operací {\bf MIN}, 
{\bf DE\-LE\-TE\-MIN}, {\bf INCREASE} a {\bf DELETE} je $O(\log n
)$. Operace {\bf MIN }
a {\bf DELETEMIN} jsou korektní.
\end{veta}

Pro úplnost dokážeme, že $F_i=\frac {\big(\frac {
1+\sqrt 5}2\big)^i-\big(\frac {1-\sqrt 5}2\big)^i}{\sqrt 5}$ .\newline 
Pro $i=1$ platí 
$$\frac {\big(\frac {1+\sqrt 5}2\big)^1-\big(\frac {1-\sqrt 5}2\big
)^1}{\sqrt 5}=\frac {1+\sqrt 5-1+\sqrt 5}{2\sqrt 5}=\frac {2\sqrt 
5}{2\sqrt 5}=1=F_1.$$
Pro $i=2$ platí 
$$\frac {\big(\frac {1+\sqrt 5}2\big)^2-\big(\frac {1-\sqrt 5}2\big
)^2}{\sqrt 5}=\frac {1+2\sqrt 5+5-1+2\sqrt 5-5}{4\sqrt 5}=\frac {
4\sqrt 5}{4\sqrt 5}=1=F_2.$$
Indukční krok:
$$\align&\frac {\big(\frac {1+\sqrt 5}2\big)^i-\big(\frac {1-\sqrt 
5}2\big)^i}{\sqrt 5}=\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}\big
(\frac {1+\sqrt 5}2\big)^2-\big(\frac {1-\sqrt 5}2\big)^{i-2}\big
(\frac {1-\sqrt 5}2\big)^2}{\sqrt 5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}\big(\frac {3+\sqrt 5}2\big
)-\big(\frac {1-\sqrt 5}2\big)^{i-2}\big(\frac {3-\sqrt 5}2\big)}{\sqrt 
5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}\big(1+\frac {1+\sqrt 5}
2\big)-\big(\frac {1-\sqrt 5}2\big)^{i-2}\big(1+\frac {1-\sqrt 5}
2\big)}{\sqrt 5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}+\big(\frac {1+\sqrt 5}
2\big)^{i-1}-\big(\frac {1-\sqrt 5}2\big)^{i-2}-\big(\frac {1-\sqrt 
5}2\big)^{i-1}}{\sqrt 5}=\\
&\frac {\big(\frac {1+\sqrt 5}2\big)^{i-2}-\big(\frac {1-\sqrt 5}
2\big)^{i-2}}{\sqrt 5}+\frac {\big(\frac {1+\sqrt 5}2\big)^{i-1}-\big
(\frac {1-\sqrt 5}2\big)^{i-1}}{\sqrt 5}=F_{i-2}+F_{i-1}=F_i.\endalign$$
Tedy indukcí dostáváme požadovaný vztah.

\subsection{
Aplikace 
}

Vrátíme se k Dijkstrově algoritmu.  
Množinu $U$ bude\-me reprezentovat pomocí Fibonacciho haldy.  
Protože ohodnocení je nezáporné a ohodnocení počáteční haldy 
je $0$, dává odhad amortizované složitosti také odhad časové 
složitosti (viz odstavec IV.).  Proto Dijkstrův 
algoritmus s použitím 
Fibonacciho haldy vyžaduje v nejhorším případě čas 
$O(|X|(1+\log|X|)+|R|)=O(|R|+|X|\log|X|)$.  Stejný výsledek 
dostane\-me i pro konstrukci nejmenší napnuté kostry grafu.  

Otázka je, kdy v Dijkstrově algoritmu nebo v 
algoritmu konstruují\-cím nejmenší napnutou kostru použít Fibonacciho haldu a kdy 
např.  $d$-regu\-lár\-ní haldy. Lze 
říci, že Fibonacciho halda by měla být výrazně lepší pro 
větší, ale řídké grafy (tj. grafy s malým počtem hran). 
Dá se předpokládat, že $d$-regulární haldy budou lepší 
(díky svým jednodušším algoritmům) pro husté 
grafy (tj. grafy, kde počet hran je $|X|^{1+\varepsilon}$ pro vhodné 
$\varepsilon >0$). Problém je, pro které hodnoty nastává zlom. 
Nevím o žádných experimentálních ani teoretických 
výsledcích tohoto typu.

\subsection{
Historický přehled
}

Binární neboli $2$-regulární haldy 
zavedl Williams 1964.  Jejich zobecnění na $d$-regulární haldy 
pochází od Johnsona 1975.  Leftist haldy definoval Crane 1972 a 
detailně popsal Knuth 1975.  Binomiální haldy navrhnl Vuillemin 
1978, Brown 1978 je implementoval a prokázal jejich praktickou 
použitelnost.  Fibonacciho haldy byly zavedeny Fredmanem a 
Tarjanem 1987.  
\newpage

\section{{Třídicí algoritmy}}

Jednou z nejčastěji řešených úloh při práci s 
daty je setřídění 
posloupnosti prvků nějakého typu. Proto velká pozornost byla a je věnována 
třídicím algoritmům řešícím tuto úlohu, která 
svým charakterem a svými 
požadavky na algoritmy je řazena do datových 
struktur. Byla navržena řada algoritmů, které se 
stále ještě analyzují a optimalizují. Analýzy jsou velmi detailní a algoritmy se 
studují za různých vstupních předpokladů. 
Kromě toho třídění je jedna z mála úloh, pro kterou 
alespoň za jistých 
předpokladů umíme spočítat dolní odhad složitosti.

Formulace úlohy:\newline 
Nechť $U$ je totálně uspořádané univerzum.\newline 
Vstup: Prostá posloupnost $\{a_1,a_2,\dots,a_n\}$ prvků z 
univerza $U$.\newline 
Výstup: Rostoucí posloupnost $\{b_1,b_2,\dots,b_n\}$ taková, že 
$\{a_i\mid i=1,2,\dots,n\}=\{b_i\mid i=1,2,\dots,n\}$.\newline 
Tento problém se nazývá \emph{třídění}. 
V praxi se setkáváme s řadou jeho modifikací, a nichž 
asi nejběžnější je vynechání předpokladu, že 
vstupem je prostá posloupnost. Pak jsou dvě varianty 
řešení -- bu\v d se ve výstupní posloupnosti odstraní 
duplicity nebo výstupní posloupnost zachová četnost prvků ze 
vstupní posloupnosti.

Základní algoritmy, které  řeší třídicí 
problém, jsou {\bf QUICKSORT}, {\bf MERGESORT} a {\bf HEAP\-SORT}. 

\subsection{
HEAPSORT
}

S algoritmem {\bf HEAPSORT} jsme se seznámili při 
aplikacích hald.  Byl to první algoritmus používající haldy 
(binární regulár\-ní haldy byly definovány právě při návrhu 
{\bf HEAP\-SORTU}).  Podíváme se detailněji na jednu z jeho 
implementací, která třídí takzvaně na místě. 

Třídicí algoritmy se často používají jako 
podprocedura při řešení jiných úloh. V takovém případě je 
obvykle vstupní posloupnost uložena v poli v pracovní 
paměti programu a poža\-dav\-kem  je setřídit ji 
bez použití další 
paměti pouze s výjimkou omezeného (malého) počtu pomocných 
proměnných. Pro řešení tohoto problému se hodí 
{\bf HEAPSORT}. Zvolíme implementaci {\bf HEAPSORTU} pomocí 
$d$-regulárních hald, které jsou reprezentovány  
polem, v němž je uložena vstupní posloupnost (viz odstavec 
Aplikace v kapitole o $d$-regulárních haldách). Použijeme 
algoritmus s jedinou změnou -- budeme požadovat duální 
podmínku na uspořádání (to znamená, že prvek reprezentovaný 
vrcholem bude menší než prvek reprezentovaný jeho 
otcem) a nahradíme operace {\bf MIN} a {\bf DELETEMIN }
operacemi {\bf MAX} a {\bf DELETEMAX}. V algoritmu vždy umístíme 
odebrané maximum na místo prvku v posled\-ním listu 
haldy (tj. prvku, který ho při operaci {\bf DELETEMAX }
nahradil) místo toho, abychom ho vložili 
do výstupní posloupnosti. Musíme si ale 
pamatovat, kde v poli končí reprezentovaná halda. Každá 
aplikace operace {\bf DELETEMAX} zkrátí počáteční úsek pole 
reprezentujícího haldu o jedno místo 
a zároveň o toto místo zvětší druhou část, ve které je uložena již 
setříděná část posloupnosti. 

{\bf HEAPSORTU} je stále věnována velká pozornost a 
bylo navrže\-no několik jeho modifikací, snažících se 
např. minimalizovat počet porovnání prvků apod.

\subsection{
MERGESORT
}

Nejstarší z uvedených algoritmů je 
{\bf MERGESORT}, který je starší než je počítačová éra, 
neboť některé jeho 
verze se používaly už při mecha\-nickém třídění. Popíšeme 
jednu jeho iterační verzi, tzv. přirozený {\bf MERGESORT}. 

{\bf MERGESORT$(a_1,a_2,\dots,a_n)$}:\newline 
$Q$ je prázdná fronta, $i=1$\newline 
{\bf while} $i\le n$ {\bf do\newline 
\phantom{{\rm ---}}$j:=i$\newline 
\phantom{{\rm ---}}while} $i<n$ a $a_{i+1}>a_i$ {\bf do} $i:=i+1$ {\bf enddo\newline 
\phantom{{\rm ---}}}posloupnost $P=(a_j,a_{j+1},\dots,a_i)$ vlož do $
Q$\newline 
\phantom{---}$i:=i+1$\newline 
{\bf enddo\newline 
while} $|Q|>1$ {\bf do\newline 
\phantom{{\rm ---}}$ $}vezmi $P_1$ a $P_2$ dvě posloupnosti z vrcholu $
Q$\newline 
\phantom{---}odstraň $P_1$ a $P_2$ z $Q$\newline 
\phantom{---}{\bf MERGE$(P_1,P_2)$} vlož na konec $Q$\newline 
{\bf enddo\newline 
Výstup}: posloupnost z $Q$

{\bf MERGE$(P_1=(a_1,a_2,\dots,a_n),P_2=(b_1,b_2,\dots,b_m))$}:\newline 
$P:=$ je prázdná posloupnost, $i:=1$, $j:=1$, $k:=1$\newline 
{\bf while} $i\le n$ a $j\le m$ {\bf do\newline 
\phantom{{\rm ---}}if} $a_i<b_j$ {\bf then\newline 
\phantom{{\rm ------}}$c_k:=a_i$}, $i:=i+1$, $k:=k+1$\newline 
\phantom{---}{\bf else\newline 
\phantom{{\rm ------}}$c_k:=b_j$}, $j:=j+1$, $k:=k+1$\newline 
\phantom{---}{\bf endif\newline 
enddo\newline 
while} $i\le n$ {\bf do\newline 
\phantom{{\rm ---}}$c_k:=a_i$}, $i:=i+1$, $k:=k+1$\newline 
{\bf enddo\newline 
while} $j\le m$ {\bf do\newline 
\phantom{{\rm ---}}$c_k:=b_j$}, $j:=j+1$, $k:=k+1$\newline 
{\bf enddo\newline 
Výstup:} $P=(c_1,c_2,\dots,c_{n+m})$

Všimněme si, že všechny posloupnosti v $Q$ jsou 
rostoucí a že sjednocením všech jejich prvků  
je vždy na začátku běhu cyklu {\bf while 
$|Q|>1$ do} množina $\{a_i\mid i=1,2,\dots,n\}$. 
Protože počet 
posloupností ve frontě $Q$ je nejvýše roven délce vstupní 
posloupnosti a každý průběh tohoto 
cyklu zmenší jejich počet o $1$, je algoritmus {\bf MERGE\-SORT} korektní.

Spočítáme časovou složitost {\bf MERGESORTU}. 
Nejprve vyšetříme slo\-ži\-tost podprocedury {\bf MER\-GE}. Protože 
určení prvku $c_k$ vyža\-du\-je čas $O(1)$ (provede se 
nejvýše jedno porovnání) a 
protože maximální hodnota $k$ je $n+m$, dostáváme, že 
podprocedura {\bf MERGE} vyžaduje čas $O(n+m)$ (nejvýše $
n+m$ 
porovnání), kde $n$ a $m$ jsou délky vstupních posloupností.

Nyní vypočteme složitost hlavní procedury. 
Zřejmě první cyklus vyžaduje lineární čas. Vyšetříme 
druhý cyklus probíhající přes frontu $Q$. Předpokládejme, že před prvním během 
tohoto cyklu je na vrcholu $Q$ speciální znak $\natural$, který se vždy 
pouze přenese z vrcholu $Q$ na její konec. Protože mezi dvěma 
přenosy $\natural$ projde každý prvek vstupní posloupnosti 
podprocedurou {\bf MERGE} právě jednou, vyžadují jednotlivé běhy cyklu 
čas $O(n)$, kde 
$n$ je délka vstupní posloupnosti (a zároveň součet všech délek 
posloupností v $Q$). Všech\-ny posloupnosti v $Q$ mají  
na počátku délku $\ge 1$. Odtud jednoduchou indukcí 
dostaneme, že po $i$-tém přenosu znaku $\natural$ mají 
délku $\ge 2^{i-1}$. Proto počet přenosů je 
nejvýše $\lceil\log_2n\rceil$, a tedy algoritmus {\bf MERGESORT }
vyžaduje čas $O(n\log n)$ (provede se nejvýše $n\log n$ 
porovnání).

Vzhledem k 
počtu porovnání je {\bf MERGESORT} optimální třídicí algoritmus. 
Navíc v této verzi je adaptivní na předtříděné 
posloupnosti, které mají jen malý počet dlouhých 
setříděných úseků (běhů). Při 
konstantním počtu běhů má složitost $O(n)$. Jiná 
jeho verze, která začíná slévání vždy od 
jednoprvkových posloupností (tzv. přímý {\bf MERGESORT}) 
tuto vlastnost nemá. 

\subsection{
QUICKSORT
}

Nyní popíšeme patrně vůbec 
nejpoužívanější třídicí algoritmus, kterým je {\bf QUICKSORT}. 
Důvodem je, že pro obecnou posloupnost je 
nejrychlejší, při rovnoměrném rozložení vstupních 
polsoupností má nejmenší očekávaný čas. 

{\bf Quick$(a_i,a_{i+1},\dots,a_j)$}:\newline 
{\bf if} $i=j$ {\bf then\newline 
\phantom{{\rm ---}}Výstup}: $(a_i)$\newline 
{\bf else\newline 
\phantom{{\rm ---}}}zvol $k$ takové, že $i\le k\le j$, $a:=a_k$, 
vyměň $a_i$ a $a_k$, $l:=i+1$, $q:=j$\newline 
\phantom{---}{\bf while} true {\bf do\newline 
\phantom{{\rm ------}}while} $a_l<a$ {\bf do} $l:=l+1$ {\bf enddo\newline 
\phantom{{\rm ------}}while} $a_q>a$ {\bf do} $q:=q-1$ {\bf enddo\newline 
\phantom{{\rm ------}}if} $l\ge q$ {\bf then\newline 
\phantom{{\rm ---------}}}exit\newline 
\phantom{------}{\bf else\newline 
\phantom{{\rm ---------}}}vyměň $a_l$ a $a_q$, $l:=l+1$, $q
:=q-1$\newline 
\phantom{{\rm------}}{\bf endif\newline 
\phantom{{\rm ---}}enddo\newline 
\phantom{{\rm---}}if} $i+1=l$ {\bf then\newline 
\phantom{{\rm ------}}Výstup$(a,$Quick$(a_{q+1},a_{q+2},\dots,a_
j))$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm ------}}if} $j=q$ {\bf then\newline 
\phantom{{\rm ---------}}Výstup$($Quick$(a_{i+1},a_{i+2},\dots,
a_{l-1}),a)$\newline 
\phantom{{\rm ------}}else\newline 
\phantom{{\rm ---------}}Výstup$($Quick$(a_{i+1},a_{i+2},\dots,
a_{l-1}),a,$Quick$(a_{q+1},\dots,a_j))$\newline 
\phantom{{\rm ------}}endif\newline 
\phantom{{\rm ---}}endif\newline 
endif

QUICKSORT$(a_1,a_2,\dots,a_n)$}:\newline 
{\bf Výstup$($Quick$(a_1,a_2,\dots,a_n))$

}
Algoritmus {\bf Quick} setřídí posloupnost 
$(a_i,a_{i+1},\dots,a_j)$ tak, že pro prvek $a=a_k$ vytvoří posloupnost 
$(a_i,a_{i+1},\dots,a_{l-1})$ všech prvků menších než $
a$ 
a posloupnost
$(a_{q+1},\dots,a_j)$ všech prvků 
větších než $a$. Na tyto posloupnosti pak 
zavolá sám sebe a do výsledné posloupnosti uloží 
nejprve setříděnou první posloupnost, pak prvek $a$ a nakonec 
setříděnou druhou posloupnost. Korektnost procedury 
{\bf Quick}  i algoritmu {\bf QUICKSORT} je tedy zřejmá, protože 
$l\le j$ a $i\le q$. 

Procedura {\bf Quick} bez rekurzivního volání 
vyžaduje čas $O(j-i)$. Tedy kdyby $a_k$ byl medián (tj. 
prostřední prvek) posloupnosti $(a_i,a_{i+1},\dots,a_j)$, pak 
by algoritmus {\bf QUICKSORT} v nejhorším případě vy\-žadoval čas $
O(n\log n)$. Jak 
uvidíme později, medián lze sice nalézt v lineár\-ním čase, ale 
použití jakékoli procedury pro jeho nalezení má za 
následek, že algoritmy {\bf MERGESORT} a {\bf HEAPSORT }
budou rychlejší (nikoliv asymptoticky, ale 
multiplikativní konstanta bude v tomto případě vysoká). Proto je třeba 
vybrat prvek $a_k$ (tzv. pivot) co 
nejrychleji. Původně se bral první nebo 
poslední prvek posloupnosti. Při této volbě a při 
rovnoměrném rozdělení vstupů je 
očekávaný čas {\bf QUICKSORTU} $O(n\log n)$ a algoritmus je 
obvykle rychlejší než {\bf MERGESORT} a 
{\bf HEAPSORT}. Avšak čas v nejhorším případě je 
kvadratický a dokonce pro určitá rozdělení vstupních dat 
je i očekávaný čas kvadratický. 
Proto tuto volbu pivota není vhodné používat pro úlohy, kdy 
neznáme rozdělení vstupních dat (mohlo by se stát, že je 
nevhodné). Jednoduše to lze napravit tak, že budeme volit $
k$ náhodně. Bohužel 
použití pseudonáhodného generátoru také vyžaduje jistý čas, a pak 
už by algoritmus zase nemusel být rychlejší než algoritmy 
{\bf MERGESORT} a {\bf HEAPSORT} (navíc takto náhodně zvolený 
prvek není skutečně náhodný, ale to v tomto případě 
nevadí). Důsledkem je návrh vybírat pivota jako 
medián ze tří nebo pěti pevně zvolených prvků 
posloupnosti. Praxe ukázala, že tento výběr pivota je 
nej\-praktičtější, dá se provést rychle a zajišťuje 
dostatečnou ná\-hod\-nost.

Protože při každém volání má {\bf Quick} jako 
argument kratší 
vstupní posloupnost, lze ukázat, že:
\begin{enumerate}
\item{}při každé volbě 
pivota je nejhorší čas algoritmu {\bf QUICKSORT} $O(n^2
)$,
\item{}pokud je pivot vybrán jedno\-du\-chým a rychlým 
způsobem (to platí, i když se volí náhodně), pak 
exi\-stují vstupní posloupnosti, které vyžadují čas $
O(n^2)$,
\item{}očekávaný čas je $O(n\log n)$.
\end{enumerate}

Následná analý\-za očekávaného případu  
je pro ná\-hod\-ně zvoleného pivota (bez dalšího před\-pokladu na 
vstupní data) nebo pro případ, kdy pivot je pevně zvolen a data jsou 
rovno\-měrně rozdě\-lena.

Ukážeme dva způsoby výpočty očekávaného času.  Jeden 
je založen na několika jednoduchých pozorováních a není v 
něm mnoho počítání, druhý na rekurzivním výpočtu. Ten 
je početně náročnější, ale postup je standardní. Hlavní idea v obou 
případech spočívá v tom, že  
očekávaný čas algoritmu {\bf QUICKSORT} je úměrný 
očekávanému počtu porovnání v algoritmu {\bf QUICKSORT}.
Tento fakt plyne přímo z popisu algoritmu.  Budeme 
tedy počítat  
očeká\-vaný počet porovnání pro algoritmus {\bf QUICKSORT}.  

První způsob výpočtu:\newline 
Každé dva prvky $a_i$ a $a_j$ algoritmus {\bf QUICKSORT} porovná 
při třídění posloupnosti $(a_1,a_2,\dots,a_n)$ nejvýše jednou, 
přičemž když porovnává $a_i$ a $a_j$, 
pak pro nějaký běh podprocedury {\bf Quick} je $a_i$ nebo $
a_j$ 
pivot, ale v předchozích bězích {\bf Quick} $a_i$ ani $
a_j$ 
nebyl pivotem (protože pivot je vždy vyřazen z následujících 
volání této podprocedury).

Nechť $(b_1,b_2,\dots,b_n)$ je výsledná posloupnost.  
Označme $X_{i,j}$ boolskou proměnou, která má hodnotu $
1$, 
když {\bf QUICKSORT} provedl porovnání mezi prvky $b_i$ a $
b_j$, a 
jinak má hodnotu $0$.  Předpokládejme, že je to náhodná 
veličina. Když $p_{i,j}$ je prav\-dě\-podobnost, že $
X_{i,j}=1$, 
pak očekávaná hodnota $X_{i,j}$ je 
$$\bold E(X_{i,j})=0(1-p_{i,j})+1p_{i,j}=p_{i,j}.$$
Protože počet porovnání  při běhu algoritmu {\bf QUICKSORT} je
$$\sum_{i=1}^n\sum_{j=i+1}^nX_{i,j}$$
a protože očekávaná hodnota součtu náhodných 
proměnných je součtem očekávaných hodnot, dostáváme, že 
očekávaný počet porovnání v algoritmu {\bf QUICKSORT} je
$$\sum_{i=1}^n\sum_{j=i+1}^n\bold E(X_{i,j})=\sum_{i=1}^n\sum_{j=
i+1}^np_{i,j}.$$

Abychom spočítali $p_{i,j}$, popíšeme chování algoritmu 
{\bf QUICKSORT} pomocí modifikace stromu výpočtu. Bude to binární 
strom, v němž každý vrchol odpovídá jednomu 
běhu podprocedury {\bf Quick}. Vrchol $v$ bude vnitřním 
vrcholem, 
když odpovída\-jí\-cí podprocedura volila pivota, a tento 
pivot bude ohodnocením $v$. V podstromu levého syna vrcholu $
v$
budou právě všechna následující rekurzivní volání podprocedury 
{\bf Quick} nad částí posloupnosti, která předchází pivotu. 
Analogicky v podstromu 
pravého syna vrcholu $v$ budou právě všechna následující 
rekurzivní volání procedury {\bf Quick} nad částí 
posloupnosti, která následuje po pivotu. 
Listy stromu odpovídají volání procedury {\bf Quick} nad 
jednoprvkovými posloupnost\-mi a každý takový jednotlivý 
prvek ohodnocuje příslušný  
list. Když vrchol $v$ odpovídá volání {\bf Quick} nad posloupností 
$(a_i,a_{i+1},\dots,a_j)$, pak vrcholy v podstromu levého syna $
v$ jsou 
ohodnoceny prvky z posloupnosti $(a_i,a_{i+1},\dots,a_{l-1})$ a vrcholy v 
podstromu pravého syna vrcholu $v$ jsou ohodnoceny prvky z posloupnosti 
$(a_{q+1},\dots,a_j)$ (po přerovnání).
Dále platí $\{a_l\mid i\le l\le j\}=\{b_l\mid i\le l\le j\}$.

Očíslujeme vrcholy tohoto stromu prohledáváním do 
šířky za předpokladu, že levý syn vrcholu předchází 
pravému synu. Nechť $(c_1,c_2,\dots,c_n)$ je posloupnost 
prvků $\{a_i\mid 1\le i\le n\}$ v pořadí daném tímto 
očíslováním. Pak platí, že $X_{i,j}=1$, právě když první 
prvek v posloupnosti $(c_1,c_2,\dots,c_n)$ z množi\-ny 
$\{b_l\mid i\le l\le j\}$ je bu\v d $b_i$ nebo $b_j$. Pravděpodobnost tohoto 
jevu je $\frac 2{j-i+1}$, tedy $p_{i,j}=\frac 2{j-i+1}$ pro $1\le 
i<j\le n$. Odtud 
očekávaný počet porovnání v algoritmu {\bf QUICKSORT} je
$$\sum_{i=1}^n\sum_{j=i+1}^np_{i,j}=\sum_{i=1}^n\sum_{j=i+1}^n\frac 
2{j-i+1}=\sum_{i=1}^n\sum_{k=2}^{n-i+1}\frac 2k\le 2n(\sum_{k=2}^
n\frac 1k)\le 2n\int_1^n\frac 1xdx=2n\ln n.$$

Druhý způsob výpočtu:\newline 
Označme $QS(n)$ očekávaný počet 
porovnání provedených algoritmem {\bf QUICKSORT} při 
třídění $n$-členné posloupnosti. Pak platí
$$\gather QS(0)=QS(1)=0\text{\rm\ a }\\
QS(n)=\frac 1n\big(\sum_{k=0}^{n-1}n-1+QS(k)+QS(n-k-1)\big)=n-1+\frac 
2n(\sum_{k=0}^{n-1}QS(k)).\endgather$$
Z toho dostáváme, že 
$$nQS(n)=n(n-1)+2\sum_{k=0}^{n-1}QS(k).$$
Přepíšeme ještě jednou tuto rovnici s $n+1$ místo $
n$:
$$(n+1)QS(n+1)=(n+1)n+2\sum_{k=0}^nQS(k).$$
Od této rovnice odečteme rovnici předchozí a po 
jednoduché úpravě získáme rekurentní vztah
$$QS(n+1)=\frac {2n}{n+1}+\frac {n+2}{n+1}QS(n).$$
Postupným dosazováním dostaneme řešení 
$$\align QS(n)=&\sum_{i=2}^n\frac {n+1}{i+1}\frac {2(i-1)}i\le 2(
n+1)\big(\sum_{i=2}^n\frac 1{i+1}\big)=2(n+1)\big(\sum_{i=3}^{n+1}\frac 
1i\big)=\\
&2(n+1)\big(\sum_{i=2}^{n+1}\frac 1i-\frac 12\big)\le 2(n+1)\big(
(\int_{i=1}^{n+1}\frac 1xdx)-\frac 12\big)=\\
&2n\ln(n+1)+2\ln(n+1)-n-1.\endalign$$
Pro dostatečně velká $n$ tedy platí 
$$2n\ln(n+1)+2\ln(n+1)-n\le 2n\ln n.$$

\subsection{
Porovnání třídicích algoritmů
}

Nyní porovnáme složitost algoritmů 
{\bf HEAPSORT}, {\bf MERGE\-SORT}, {\bf QUICKSORT}, {\bf A-sort} (byl popsán 
v kapitole o $(a,b)-$stromech), 
{\bf SELECTIONSORT} a {\bf INSERTIONSORT}.  Připomeňme si, že 
{\bf SELECTIONSORT} tří\-dí posloupnost tak, že jedním
průcho\-dem nalezne její nej\-menší prvek, 
který vyřadí a vloží do výsledné 
posloupnosti (ve verzi, která třídí na místě, ho vymění 
s levým krajním prvkem pole). 
Tento proces pak opakuje se zbytkem 
původní posloupnosti. Tato idea byla 
zákla\-dem algoritmu {\bf HEAPSORT}.  {\bf INSERTIONSORT} třídí 
tak, že do již setříděného začátku  
posloupnosti vkládá další prvek, který pomocí výměn 
zařadí na správné místo, a tento proces (začíná druhým 
prvkem zleva) opakuje.  

{\bf QUICKSORT} v nejhorším případě vyžaduje čas 
$\Theta (n^2)$, oče\-kávaný čas je $9n\log n$, v 
nej\-horším případě provádí $\frac {n^2}2$ porov\-nání,  
očekávaný počet porov\-nání je $1.44n\log n$. 
Potřebuje $n+\log n+konst$ paměti, používá přímý 
přístup k paměti a není adaptivní na předtříděné 
posloupnosti.\newline 
{\bf HEAPSORT} v nejhorším případě vyžaduje čas $
20n\log n$, 
oče\-kávaný čas je $\le 20n\log n$, v nejhorším i v 
očekávaném případě provádí $2n\log n$ porovnání. 
Potřebuje $n+konst$ paměti, používá přímý přístup k paměti a 
není adaptivní na předtříděné posloupnosti.\newline 
{\bf MERGESORT} v nejhorším případě vyžaduje čas 
$12n\log n$, očekávaný čas je $\le 12n\log n$, v nejhorším 
i v očekáva\-ném případě provádí $n\log n$ 
porovnání (nejmenší možný počet). Potřebuje $
2n+konst$ 
paměti, používá 
sekvenční přístup k paměti a má verzi, která je 
adaptivní na předtříděné posloupnosti s malým počtem 
běhů.\newline 
{\bf A-sort} v nejhorším případě i v očekáném případě vyžaduje čas 
$O(n\log\frac Fn)$, kde $F$ je počet inverzí ve vstupní 
posloupnosti,  v nejhorším i v očekávaném 
případě provádí $O(n\log\frac Fn)$ porovnání. Potřebuje  
$5n+konst$ paměti, používá přímý přístup k paměti 
a je adaptivní na předtříděné posloupnosti s malým 
počtem inverzí.\newline 
{\bf SELECTIONSORT} v nejhorším i v očekávaném případě 
vyžaduje čas $2n^2$, počet porov\-nání v nejhorším 
i v očekávaném případě je $\frac {n^2}2$. Potřebuje 
$n+konst$ paměti, používá přímý přístup k paměti a 
není adaptivní na předtříděné posloupnosti.\newline 
{\bf INSERTIONSORT} v nejhorším i v očekávaném případě  
vy\-žaduje čas $O(n^2)$, počet porov\-nání v nejhorším 
případě je $\frac {n^2}2$, v oče\-ká\-vaném případě 
$\frac {n^2}4$. Potřebuje $n+konst$ paměti, použí\-vá 
sekvenční přístup k paměti a má verzi, která je 
adaptivní na předtříděné posloupnosti s malým počtem 
inverzí.

Prezentované  výsledky byly spočítány 
pro model RAM (viz Mehlhorn 1984).

Očekávaný čas pro {\bf HEAPSORT} je prakticky stejný jako 
jeho nej\-horší čas.  Byly navrženy verze, které optimalizují 
počet porov\-nání, ale většinou mají větší nároky na 
čas, a proto až na výjimky ne\-jsou pro praktické 
použití vhodné.  
Situace pro {\bf MERGESORT} je komplikovanější, hod\-ně závisí 
na konkrétní verzi algoritmu.  Algoritmus 
{\bf MER\-GE\-SORT} je nejvhodnější pro externí paměti se  
sekvenčním přístupem k datům, pro interní 
paměť kvůli velké prostorové náročnosti 
není doporučován (je např. dvojnásobná proti {\bf HEAPSORTU }
a téměř dvojnásobná proti {\bf QUICKSORTU}). Také se hodí pro 
návrh pa\-ra\-lelních algoritmů. Pro třídění 
krátkých posloupností je doporučováno místo {\bf QUICKSORTU }
pro posloupnosti délky $\le 22$ použít {\bf SELECTIONSORT} a pro 
posloupnosti délky $\,\le 15$  {\bf INSERTIONSORT.}
To vede k návrhu optimalizovanéh {\bf QUICKSORTU}, 
který{\bf ,}  když 
volá rekurzivně sám sebe na krátkou posloupnost, pak 
použije {\bf SELECTIONSORT} ne\-bo {\bf INSERTIONSORT}. V algoritmu {\bf A-sort }
se doporu\-ču\-je použít $(2,3)$-strom.  
Poměr časů spotřebovaných  
algoritmy {\bf QUICKSORT},  {\bf MERGESORT} a {\bf HEAPSORT} na 
klasických počítačích uvádí Mehlhorn (1984) jako  
$1$ : $1.33$ : $2.22$. To 
však nemusí  být pravda pro současné procesory, 
paměti a operační systémy. 

\subsection{
Slévání nestejně dlouhých posloupností
}

V algoritmu {\bf MERGESORT} jsme použili frontu, která 
řídila proces slučování rostoucích posloupností.  Tato metoda je uspokojující a 
dává optimální výsledek (ve smyslu časové náročnosti){\bf ,} pokud posloupnosti ve frontě jsou 
stejně dlouhé.  Pokud se ale jejich délky hodně liší, 
nedosáhneme tímto způsobem  
optimálního výsledku.  Přitom různé verze tohoto 
problému se vyskytují v mnoha úlohách. Jednou z prvních úloh, 
kde jsme se s ním setkali, je konstrukce 
Huffmanova k\'odu -- to je minimální redundantní k\'od, který byl 
nalezen v roce 1952. K optimálnímu řešení vede např. 
postup, který je kombinací `mergeování' a 
optimalizace a používá metody dynamického programování.  
Nejprve formálně popíšeme abstraktní verzi tohoto problému.  

Vstup: Množina rostoucích navzájem 
disjunktních posloupností.\newline 
Úkol:  Pomocí operace {\bf MERGE} co nejrychleji spojit 
všechny tyto posloupnosti do jediné rostoucí posloupnosti.  

Předpokládejme, že máme postup, který z 
daných rostoucích posloupností vytvoří 
jedinou rostoucí po\-sloupnost. Tento postup určuje úplný 
binární strom $T$, jehož listy jsou ohodnoceny vstupními 
posloupnostmi a každý vnitřní vr\-chol je ohodnocen 
posloupností, která je sloučením vstupních posloupností 
ohodnocujících listy v podstromu určeném tímto 
vr\-cholem. Tedy kořen je ohodnocen výstupní posloupností. 
Formálně pro každý vnitřní vr\-chol  $v$ platí:
\begin{enumerate}
\item"{}"
když  $v_1$ a $v_2$ jsou synové $v$ a $P(v)$ je posloupnost 
ohodnocující vrchol $v$,  pak\newline 
$P(v)=${\bf MERGE$(P(v_1),P(v_2))$}.
\end{enumerate}
Označme $l(P)$ délku posloupnosti $P$. Pak součet 
časů, které v tomto procesu vyžaduje 
podprocedura {\bf MERGE},
je $O(\sum \{l(P(v))\mid v\text{\rm \ je vnitřní vrchol stromu }
T\})$. Indukcí 
lehce dostaneme, že 
$$\sum \{l(P(v))\mid v\text{\rm \ vnitřní vrchol stromu }T
\}=\sum_{\{t\text{\rm \ je list }T\}}d(t)l(P(t)),$$
kde $d(t)$ je hloubka listu $t$.

Když tedy $T$ je úplný binární strom, jehož listy
jsou ohodnoceny navzájem disjunktními rostoucími  
posloupnostmi, pak následující algoritmus {\bf Slevani} spojí tyto  
posloupnosti do jediné rostoucí posloupnosti a procedury 
{\bf MERGE} budou vyžadovat celkový čas 
$$O(\sum_{\{t\text{\rm \ je list }T\}}d(t)l(P(t))).$$

{\bf Slevani$(T,\{P(l)\mid l\text{\rm \ je list }T\})$\newline 
while} $P(\text{\rm kořen }T)$ není definováno {\bf do\newline 
\phantom{{\rm---}}}$v:=$ vrchol $T$ takový, že $P(v)$ není 
definováno a\newline 
\phantom{---}pro oba syny $v_1$ a $v_2$ vrcholu $v$ jsou $P(v_1)$ a $
P(v_2)$ definovány\newline 
\phantom{---}$P(v):=${\bf MERGE$(P(v_1),P(v_2))$\newline 
enddo

}
Nyní můžeme přeformulovat původní 
problém:\newline 
Vstup: $n$ čísel $x_1,x_2,\dots,x_n$\newline 
Výstup: úplný binární strom $T$ s $n$ listy a bijekce $
\phi$ z 
množiny $\{1,2,\dots,n\}$ do listů $T$ taková, že 
$\sum_{i=1}^nd(\phi (i))x_i$ je minimální (kde $d(\phi (i))$ je hloubka 
listu $\phi (i)$).\newline 
\v Rekneme, že dvojice $(T,\phi )$ je \emph{optimální} 
\emph{strom} vzhledem k $x_1,x_2,\dots,x_n$. 

V přeformulováné úloze už nepracujeme s 
posloupnostmi, ale jen s jejich délkami. 
To znamená, že když pro původní úlohu 
byly vstupem posloupnosti $P_1,P_2,\dots,
P_n$, pak pro 
přeformulovanou úlohu jsou vstupem jen délky  
$l(P_1),l(P_2),\dots,l(P_n)$. Strom vytvořený pro 
přeformulovanou úlohu  
je použit v algoritmu {\bf Slevani}  
tak, že  posloupnost $P_i$ ohodnocuje list, který byl v 
přeformulované úloze ohodnocen délkou $l(P_i)$, a hledaná posloupnost 
v původní úloze ohodnocuje kořen stromu. 

Mějme množinu $\{x_i\mid i=1,2,\dots,n\}$.  Pro úplný binární 
strom $T$ s $n$ listy a bijekci $\phi$ z množiny $\{1,2,\dots,
n\}$ do 
listů stromu $T$ definujme 
$$\Cont(T,\phi )=\sum_{i=1}^nd(\phi (i))x_i,$$
kde $d(\phi (i))$ je hloubka listu $\phi (i)$, tj.  délka cesty z 
kořene do listu $\phi (i)$  pro $i=1,2,\dots,n$.  
Chceme zkonstruovat úplný binární strom s $n$ listy, 
který minimalizuje hodnotu $\Cont$. K řešení 
použijeme následující algoritmus, který je upravenou verzí 
hladového algoritmu pro náš problém.

{\bf Optim$(x_1,x_2,\dots x_n)$}:\newline 
$V$ je množina $n$ jednoprvkových stromů\newline 
$\phi$ je bijekce mezi $\{1,2,\dots,n\}$ a množinou $V$\newline 
{\bf for every} $v\in V$ {\bf do} $c(v):=x_{\phi^{-1}(v)}$ {\bf enddo\newline 
while} $|V|>1$ {\bf do\newline 
\phantom{{\rm---}}}vezmi z $V$ dva stromy $v_1$ a $v_2$ s nejmenším ohodnocením\newline 
\phantom{---}odstraň je z $V$\newline 
\phantom{---}vytvoř nový strom $v$ spojením stromů $
v_1$ a $v_2$\newline 
\phantom{---}$c(v):=c(v_1)+c(v_2)$, strom $v$ vlož do $V$\newline 
{\bf enddo\newline 
Výstup}: $(T,\phi )$, kde $T$ je strom v množině $V$

Vytvoření nového stromu $v$ spojením stromů 
$v_1$ a $v_2$ znamená vytvoření nového vrcholu, který bude 
kořenem stromu $v$ a jehož synové budou kořeny stromů 
$v_1$ a $v_2$. To je analogické proceduře {\bf spoj}.

\begin{veta}Pro danou posloupnost čísel 
$(x_1,x_2,\dots,x_n)$ algoritmus {\bf Optim} nalezne optimální strom 
pro množinu $x_1,x_2,\dots,x_n$ a pokud je posloupnost 
$(x_1,x_2,\dots,x_n)$ neklesající, pak vyža\-du\-je čase 
$O(n)$.  
\end{veta}

\begin{proof}Důkaz má dvě části. V 
první dokážeme korektnost algoritmu a ve druhé popíšeme 
reprezentaci množiny $V$ a vypočteme časovou složitost.

Nejprve připomeňme, že $\phi (i)$ je list $T$ 
pro každé $i\in \{1,2,\dots,n\}$.  Protože na začátku $
V$ 
obsahuje jen 
jednoprvko\-vé stromy, tak tvrzení platí.  Každý běh cyklu 
{\bf while do} zmenší počet stromů $V$ o jeden, ale nezmění 
množinu listů.  Proto $T$ je strom s $n$ listy, $\phi$ je 
bijekce z $\{1,2,\dots,n\}$ do množiny listů $T$ a algoritmus 
vždy končí.  Dokážeme indukcí podle $n$, že zkonstruovaná 
dvojice $(T,\phi )$ je optimální strom vzhledem k $(x_1,x_2
,\dots,x_n)$.  
Když $n=2$, tvrzení zřejmě platí.  Předpokládejme, že 
platí pro každou posloupnost čísel $(y_1,y_2,\dots,$$
y_{n-1})$, a 
nechť $x_1\le x_2\le\dots\le x_n$ je neklesající posloupnost čísel.  Bez újmy na 
obecnosti můžeme předpokládat, že v prvním kroku 
algoritmus {\bf Optim} zvolil stromy $\phi (1)$ a $\phi (2)$.  Uvažujme množinu 
$(y_1,y_2,\dots,y_{n-1})$, kde $y_i=x_{i+2}$ pro $i=1,2,\dots,n-2$, 
$y_{n-1}=x_1+x_2$.  Nechť $T'$ je strom získaný ze stromu $
T$  
odstraněním listů $\phi (1)$ a $\phi (2)$ a nechť $
\psi$ je bijekce z 
množiny $\{1,2,\dots,n-1\}$ taková, že $\psi (i)=\phi (i+
2)$ pro 
$i=1,2,\dots,n-2$ a $\psi (n-1)$ je otec listu $\phi (1)$.  Pak 
můžeme předpokládat, že algoritmus 
{\bf Optim$(y_1,y_2,\dots,y_{n-1})$} zkonstruoval strom $(T',\psi 
)$, a podle indukčního 
předpokladu je to optimální strom pro $(y_1,y_2,\dots,y_{
n-1})$.  Nechť 
$(U,\theta )$ je optimální strom vzhledem k $(x_1,x_2,\dots
,x_n)$.  Zvolme 
vnitřní vrchol $u$ stromu $U$ takový, že délka cesty z kořene 
do vrcholu $u$ je nej\-větší mezi všemi vnitřními vrcholy 
stromu $U$.  Nechť $u_1$ a $u_2$ jsou synové $u$, pak nutně $
u_1$ 
a $u_2$ jsou listy stromu $U$.  Nechť $i,j\in \{1,2,\dots,n\}$ takové, že 
$\theta (i)=u_1$, $\theta (j)=u_2$.  Po eventuálním přejmenování můžeme 
předpokládat, že když $i,j\in \{1,2\}$, pak $i=1$ a 
$j=2$.  Definujme $\eta$ z $\{1,2,\dots,n\}$ do listů $U$ tak, že 
$\eta (1)=u_1$, $\eta (2)=u_2$, $\eta (i)=\theta (1)$, $\eta (j)=
\theta (2)$ a $\eta (k)=\theta (k)$ pro 
všechna $k\in \{3,4,\dots,n\}\setminus \{i,j\}$.  Pak $\eta$ je bijekce a 
$$\Cont(U,\eta )-\Cont(U,\theta )=(d(u_1)-d(\theta (1))(x_1-x_i)+
(d(u_2)-d(\theta (2))(x_2-x_j).$$
Z volby $u$ plyne, že $d(u_1)\ge d(\theta (1))$, $d(u_2)\ge d(
\theta (2))$, 
$x_1\le x_i$ a $x_2\le x_j$. Odtud  
$$(d(u_1)-d(\theta (1))(x_1-x_i)+(d(u_2)-d(\theta (2))(x_2-x_j)\le 
0$$
a protože $(U,\theta )$ je optimální strom pro $(x_1,x_2
,\dots,x_n)$, 
dostá\-vá\-me, že $(U,\eta )$ je také optimální strom pro 
$(x_1,x_2,\dots,x_n)$.  Od\-straněním listů $u_1$ a $
u_2$ ze stromu 
$U$ dostaneme strom $U'$.  Definujme $\tau$ z $\{1,2,\dots,n-1\}$ 
předpisem $\tau (i)=\eta (i+2)$ pro $i=1,2,\dots,n-2$ a $\tau 
(n-1)=u$.  Pak 
$\tau$ je bijekce z $\{1,2,\dots,n-1\}$ do množiny listů $
U'$ a 
protože $(T',\psi )$ je optimální strom pro $(y_1,y_2,\dots
,y_{n-1})$, 
platí, že 
$$\Cont(T',\psi )\le\Cont(U',\tau ).$$
Protože  
$$\gather\Cont(T,\phi )=\Cont(T,\psi )+x_1+x_2\text{\rm \ , }\\
\Cont(U,\eta )=\Cont(U',\tau )+x_1+x_2\endgather$$
pak závěr je, že $(T,\phi )$ je optimální strom pro 
$(x_1,x_2,\dots,x_n)$.

Předpokládejme opět, že $x_1\le x_2\le\dots\le 
x_n$ a že v daném 
okamžiku jsou $v_1,v_2,\dots,v_k$ postupně vytvořené víceprvkové stromy
(tj. strom $v_i$ byl vytvořen před stromem $v_j$, když $
i<j$). V 
tomto okamžiku je množina $V$ sjednocením množiny $\{
v_1,v_2,\dots,v_k\}$ 
a množiny jednoprvkových stromů, které nebyly ještě 
zpracovány. Nyní vytvoříme strom $w$ spojením 
stromů $t_1$ a $t_2$ s nejmenším ohodnocením. Z popisu algoritmu plyne, že když 
strom $v_i$ pro $i=1,2,\dots,k$ vznikl spojením stromů $
u_1$ 
a $u_2$, pak $\max\{c(u_1),c(u_2)\}\le\min\{c(t_1),c(t_2)\}$, a proto $
c(w)\ge c(v_i)$ 
pro každé $i=1,2,\dots,k$. Pak indukcí 
okamžitě dostáváme, že $c(v_1)\le c(v_2)\le\dots\le 
c(v_k)$.  Tedy stačí, 
abychom měli rostoucí posloupnost listů a v ní 
ukazatel na nej\-menší list, který je ještě 
nezpracovaným jednoprvkovým stro\-mem (tj. před ukazatelem jsou 
listy, které už nejsou stromy v množině $V$, 
za ukazatelem jsou listy, které jsou ještě jednoprvkové 
stro\-my v množině $V$) a frontu víceprvkových 
stromů (z níž stromy ke zpracování odebíráme 
zpředu a nově vytvořené  
ukládáme na konec).  Udržovat tyto struktury vyža\-duje čas 
$O(1)$ stejně jako nalezení dvou stromů s nej\-menším 
ohodnocením. Můžeme tedy shrnout, že algoritmus 
{\bf Optim} konstruuje optimální stromy v čase $O(n)$, kde $
n$ je počet 
zadaných čísel $x_i$. \qed
\end{proof}

Pro aplikaci na naši původní úlohu je 
třeba  
ještě setřídit vstupní posloupnost délek pro přeformu\-lo\-vanou úlohu.
Tato posloupnost je tvořena přirozenými čísly a 
k jejímu setřídění  
můžeme použít algoritmus {\bf BUCKETSORT} (bude 
popsán dále v textu), který 
vyžaduje čas $O(n+m)$, kde $n$ je počet posloupností a $
m$ je 
maximální délka posloupnosti.

\begin{veta}Uvedený algoritmus množinu 
disjunktních rostoucích 
posloupností $P_1,P_2,\dots,P_n$ o délkách $l(P_1),l(P_2)
,\dots,l(P_n)$ spojí 
do jediné rostoucí posloupnosti v čase 
$O(\sum_{i=1}^nl(P_i))$.
\end{veta}

\section{{Rozhodovací stromy}}

Většina obecných třídicích algoritmů 
používá jedinou primitivní operaci mezi prvky vstupní 
posloupnosti, a to jejich vzá\-jemné porov\-nání.  
To znamená, že práci 
takového algoritmu lze po\-psat 
binárním stro\-mem, jehož vnitřní vrcholy jsou ohodnoceny 
porovnáními dvojic prvků vstupní posloupnosti 
(např. $a_i<a_j$). Bez újmy na obecnosti předpokládejme, že 
vstupní posloupnost je permutace $\pi$
množiny $\{1,2,\dots,n\}$. Tato permutace prochází 
stromem takto:
\begin{enumerate}
\item"{}"
Začíná v kořeni stromu. Když je ve vnitřním vrcholu $
v$ 
ohodnoceném porovnáním $a_i\le a_j$, pak když $\pi (i)
<\pi (j)$, 
pokračuje v levém synu vrcholu $v$, a když $\pi (j)<\pi (
i)$, 
pokračuje v pravém synu vrcholu $v$. Proces 
třídění končí, když se dostane do listu.
\end{enumerate}
Aby byl algoritmus korektní, musí platit, že dvě 
různé permutace skončí v různých 
listech.  Tedy strom popisující korektní algoritmus 
pro setřídění $n$-prvkovývh posloupností musí mít 
alespoň $n!$ listů.  Délka cesty z kořene do listu, 
kde skončila permutace $\pi$, reprezentuje počet porovnání, které potřebuje 
daný algoritmus k setřídění dané posloupnosti $
\pi$. Protože porovnání 
vyžaduje alespoň jednotku času, dostáváme tím i dolní odhad na 
čas potřebný k setřídění této posloupnosti  algoritmem 
odpovídajícím danému stromu. Dolní odhad  počtu 
porovnání i času pro daný algoritmus a všechny  
$n$-prvkové posloupnosti je pak délka nejdelší cesty z kořene 
do listu v odpovídajícím stromu. To nám umožňuje 
získat obecně platný dolní odhad času potřebného k setřídění 
$n-$prvkové posloupnosti, kterým je  
minimum přes všechny binární stromy s alespoň $n!$ 
listy z jejich maximálních délek cest z kořene do listu. 
Korekt\-nost těchto úvah plyne z pozorování, 
že když porovnání je jediná primi\-tivní operace, pak 
algoritmus není závislý na konkrétních prvcích vstup\-ní 
posloupnosti, ale jen na jejich vzájemném vzta\-hu. 
Proto stačí uvažovat pouze permutace $n$-prvkové množiny, 
protože za\-chycují všechny možné vztahy v $n$-prvkové 
posloupnosti. Dá\-le je třeba si uvědomit, že vztah mezi 
stromem pro $n$-prvkové posloupnosti a stromem pro 
$(n+1)$-prvkové posloupnosti je dán konkrétním algoritmem a 
nedá se popsat obecně. 

V nevhodném algoritmu se může stát, že 
v některém listu neskončí žádná permutace. To  
nastane, když strom pro $n$-prvkové posloupnosti má více 
než $n!$ listů, nebo, jinak řečeno, když 
porovnání dvou stejných prvků se na nějaké cestě 
vyskytne alespoň dvakrát. 

Následující obrázek ilustruje naše úvahy na 
{\bf SELECTIONSORTU} pro $3$-prvkové posloupnosti. Listy jsou 
ohodnoceny permutacemi vstupní množiny 
$\{a_1,a_2,a_3\}$, které v nich 
skončí, nebo jsou prázdné. 
\midinsert
\centerline{\input fig11.tex}
\botcaption{Obr. 1}
\endcaption
\endinsert

\definition{Definice}Mějme třídicí algoritmus {\bf A}, který 
jako jedinou pri\-mitivní operaci s prvky vstupní 
posloupnosti používá jejich porov\-nání. \v Rekneme, že binární 
strom $T$, jehož vnitřní vrcholy jsou ohodnoceny 
porovnáními  $a_i\le a_j$ pro $i,j=1,2,\dots,n$, $i\ne j$, je 
\emph{rozhodovacím} \emph{stromem} algoritmu {\bf A} pro 
$n$-prvkové posloupnosti, když pro každou permutaci $\pi$
$n$-prvkové množiny platí 
\begin{enumerate}
\item"{}"
posloupnost porovnání při třídění permutace $
\pi$ 
algoritmem {\bf A} je stejná jako po\-sloupnost porovnání při 
průchodu permutace $\pi$ stromem $T$.
\end{enumerate}
\enddefinition

Pak korektnost algoritmu zajišťuje, že dvě různé 
permutace množiny $\{1,2,\dots,n\}$ skončí v 
různých listech stromu $T$ a dol\-ním odhadem pro 
čas algoritmu {\bf A} v nej\-horším případě je délka nejdelší 
cesty z kořene do listu.  
Při rovnoměrném 
rozdělení vstupních po\-sloupností je očekávaný čas 
algoritmu {\bf A} roven průměrné délce cesty z kořene do 
listu.  

Definujme\newline 
$S(n)$ jako minimum přes všechny stromy $T$ s alespoň $n
!$ listy z 
délek nejdelších cest z kořene 
do listu v $T$, \newline 
$A(n)$ jako minimum přes všechny stromy $T$ s alespoň $n
!$ listy z
průměrných délek cest z kořene do listu v $T$.\newline 
Naším cílem je spočítat dolní odhady těchto veličin.

Když nejdelší cesta z kořene do listu v 
binárním stromě $T$ má délku $k$, pak $T$ má nejvýše $
2^k$ 
listů. Proto $n!\le 2^{S(n)}$. Odtud plyne, že $S(n)\ge\log_
2n!$.
Připomeňme si Stirlingův vzorec pro faktoriál: 
$$n!=\sqrt {2\pi n}\big(\frac ne\big)^n(1+\frac 1{12n}+O(\frac 1{
n^2})).$$
Protože pro $n\ge 1$ je $\frac 1{12n},\frac 1{n^2}\ge 0$, můžeme 
předpokládat, že $(1+\frac 1{12n}+O(\frac 1{n^2}))\ge 1$ pro všechna $
n\ge 1$. Po 
zlogaritmování vzorce dostáváme 
$$\log_2n!\ge\frac 12\log_2n+n(\log_2n-\log_2e)+\log_2\sqrt {2\pi}
\ge (n+\frac 12)\log_2n-n\log_2e.$$
Protože  
$$e^1=e=2^{\log_2e}=(e^{\ln2})^{\log_2e}=e^{\ln2\log_2e},$$
platí, že $\frac 1{\ln2}=\log_2e$, a tedy  
$$S(n)\ge\log_2n!\ge (n+\frac 12)\log_2n-\frac n{\ln2}.$$

Dále pro binární strom $T$ označme $B(T)$ součet všech 
délek cest z kořene do listů a položme 
$$B(k)=\min\{B(T)\mid T\text{\rm\ je binární strom s $k$ listy}
\}.$$
Když ukážeme, že $B(k)\ge k\log_2k$, pak bude 
$$A(n)\ge\frac {B(n!)}{n!}\ge\frac {n!\log_2n!}{n!}=\log_2n!\ge (
n+\frac 12)\log_2n-\frac n{\ln2}.$$
Dokažme tedy, že $B(T)\ge k\log_2k$ pro každý binární 
strom $T$ s $k$ listy. Když ve stromě $T$ vynecháme každý 
vrchol, který má jen jednoho syna, a tohoto syna spojíme 
s jeho předchůdcem, dostaneme úplný binární 
strom $T'$ s $k$ listy tako\-vý, že $B(T')\le B(T)$. Proto se stačí  
omezit na úplné binární stromy. Když $T$ je úplný 
binární strom s jedním listem, pak $B(T)=0=1\log_21$, 
když $T$ je úplný binární strom se dvěma listy, pak 
$B(T)=2=2\log_22$. Tedy platí $B(1)\ge 1\log_21$ a $B(2)\ge 2\log_
22$. 
Předpokládejme, že $B(i)\ge i\log_2i$ pro $i<k$, a nechť $
T$ je 
úplný binární strom s $k$ listy. Nechť $T_1$ a $T_2$ jsou 
podstromy určené syny kořene a nechť $T_i$ má $k_i$ 
listů, kde $i=1,2$. Pak $1\le k_1,k_2$ a $k_1+k_2=k$, tedy 
$k_1,k_2<k$ a podle indukčního předpokladu $B(k_i)\ge k_
i\log_2k_i$. 
Odtud 
$$B(T)=k_1+B(T_1)+k_2+B(T_2)\ge k+B(k_1)+B(k_2)\ge k+k_1\log_2k_1
+k_2\log_2k_2.$$

Tedy stačí ukázat, že 
$$k+k_1\log_2k_1+k_2\log_2k_2\ge k\log_2k$$
pro všechna $k_1,k_2>0$ taková, že $k=k_1+k_2$. To je 
ekvivalentní s tvrzením, že pro $k>0$ platí 
$$f(x)=x\log_2x+(k-x)\log_2(k-x)+k-k\log_2k\ge 0,$$
kde $x\in (0,k)$. 
Abychom to dokázali, všimněme si, že $f(\frac k2)=0$ a  
počí\-tejme derivaci $f$.
$$f'(x)=\log_2x+\log_2e-\log_2(k-x)-\log_2e=\log_2\frac x{k-x}.$$
Nyní když $x\in (0,\frac k2)$, pak $f'(x)<0$ a $f$ je na tomto intervalu 
klesající, když $x\in (\frac k2,k)$, pak $f'(x)>0$ a $
f$ je na tomto 
intervalu rostoucí. Odtud plyne, že $f(x)\ge 0$ pro $x\in 
(0,k)$.
Tím jsme dokázali, že $A(n)\ge (n+\frac 12)\log_2n-\frac 
n{\ln2}$. Shrneme 
naše výsledky.

\begin{veta}Každý třídicí algoritmus, jehož jedinou 
primitivní ope\-rací s prvky vstupní posloupnosti je 
porovnání, vyžaduje v nejhorším i v očekávaném případě 
alespoň $cn\log n$ času pro nějakou konstantu $c>0$.  V 
nejhorším případě použije alespoň $\lceil 
(n+\frac 12)\log_2n-\frac n{\ln2}\rceil$ 
porovnání a očekávaný počet porovnání při rovnoměrném 
rozdělení vstupních posloupností je alespoň 
$(n+\frac 12)\log_2n-\frac n{\ln2}$.  
\end{veta}

Tato věta 
platí i pro širší třídu primitivních operací, proto v ní 
lze oslabit předpklady. 
Dolní odhad (v nejhorším i průměrném případě) 
bude platit i za 
před\-pokladu, že třídicí algoritmus nepoužívá nepřímé 
adreso\-vání a celo\-číselné dělení. 
(Na druhé straně následující klasický algoritmus 
{\bf BUCKETSORT} ukazuje, že před\-poklady
ve větě nelze zcela vynechat.) 
Tato metoda pro 
nalezení dolního odhadu se používá i pro vyčíslování 
algebraických funkcí a při algoritmickém řešení 
geometrických úloh.

\section{{Přihrádkové třídění}}

V následujících algoritmech 
před\-po\-klá\-dáme, že $Q_i$ jsou spojové seznamy, nový 
prvek se vkládá na konec seznamu a konkatenace 
seznamů závisí na jejich pořadí. V 
seznamech máme okamžitý přístup k prvnímu a poslednímu 
prvku (pomocí ukazatelů na tyto prvky). 
Algoritmus {\bf BUCKETSORT} třídí posloupnost přirozených 
čísel $a_1,a_2,\dots,a_n$ z intervalu $<0,m>$.

{\bf BUCKETSORT$(a_1,a_2,\dots,a_n,m)$}:\newline 
{\bf for every} $i=0,1,\dots,m$ {\bf do} $Q_i=\emptyset$ {\bf enddo\newline 
for every} $i=1,2,\dots,n$ {\bf do\newline 
\phantom{{\rm ---}}$a_i$} vlož na konec seznamu $Q_{a_i}$\newline 
{\bf enddo\newline 
$i:=0$}, $P:=\emptyset$\newline 
{\bf while} $i\le m$ {\bf do\newline 
\phantom{{\rm ---}}$P:=$}konkatenace $P$ a $Q_i$, $i:=i+1$\newline 
{\bf enddo\newline 
Výstup: $P$} je neklesající posloupnost prvků 
$a_1,a_2,\dots,a_n$

Algoritmus nevyžaduje, aby prvky ve 
vstupní posloupnosti by\-ly různé. Ve výstupní 
posloupnosti se daný prvek opakuje tolikrát, kolikrát se 
opakoval ve vstupní posloupnosti, se zachováním pořadí 
(tj. třídění je stabilní). 
Konkatenace dvou seznamů a vložení prvku do seznamu 
vyžadují čas $O(1)$. Proto první a třetí cyklus vyžadují 
čas $O(m)$ a druhý cyklus čas $O(n)$. Celkem 
algoritmus vyžaduje $O(n+m)$ času a paměti. Zřejmě když  
$m=O(n)$, tak pro tento algoritmus neplatí tvrzení věty z 
předchozího odstavce. 
Důvodem je, 
že nejsou splněny předpoklady, protože druhý cyklus 
používá nepřímé adresování.

Nyní uvedeme dvě sofistikovanější verze tohoto 
algoritmu. V první předpokládáme, že 
$a_1,a_2,\dots,a_n$ je posloupnost navzájem různých reálných 
čísel z intervalu $<0,1>$ a $\alpha$ je pevně zvolené kladné 
reálné číslo.

{\bf HYBRIDSORT$(a_1,a_2,\dots,a_n)$}:\newline 
$k:=\alpha n$\newline 
{\bf for every} $i=0,1,\dots,k$ {\bf do} $Q_i=\emptyset$ {\bf enddo\newline 
for every} $i=1,2,\dots,n$ {\bf do\newline 
\phantom{{\rm ---}}$a_i$} vlož na konec seznamu $Q_{\lceil ka_
i\rceil}$\newline 
{\bf enddo\newline 
$i:=0$}, $P:=\emptyset$\newline 
{\bf while} $i\le k$ {\bf do\newline 
\phantom{{\rm ---}}HEAPSORT$(Q_i)$
$P:=$}konkatenace $P$ a $Q_i$, $i:=i+1$\newline 
{\bf enddo\newline 
Výstup: $P$} je rostoucí posloupnost prvků 
$a_1,a_2,\dots,a_n$

\begin{veta}Algoritmus {\bf HYBRIDSORT} setřídí 
posloupnost reál\-ných čísel z intervalu $<0,1>$ v 
nejhorším případě v čase $O(n\log n)$. Když prvky $
a_i$ 
mají rovnoměrné rozložení a jsou na sobě nezá\-vislé, 
pak očekávaný čas je $O(n)$.
\end{veta}

\begin{proof}První dva cykly v algoritmu 
vyžadují čas $O(n)$, $i$-tý běh třetího cyklu vyžaduje 
nejvýše čas $O(1+|Q_i|\log|Q_i|)$. Proto čas celého třetího cyklu je 
$$O(\sum_{i=0}^k(1+|Q_i|\log|Q_i|)=O(\sum_{i=0}^k(1+|Q_i|\log n)=
O(k+(\sum_{i=0}^k|Q_i|)\log n)=O(n\log n)$$
a celkový čas {\bf HYBRIDSORTU} v nejhorším případě je nejvýše $
O(n\log n)$.

Nyní odhadneme očekávaný čas. Položme 
$X_i=|Q_i|$. Pak 
$X_i$ je ná\-hodná proměnná a 
protože pravděpodobnost, že $x\in Q_i$, je $\frac 1k$, dostá\-váme, že 
$$\Prob(X_i=q)=\binom nq(\frac 1k)^q(1-\frac 1k)^{n-q}.$$
Očekávaný čas vyžadovaný třetím cyklem se pak rovná 
$$E(\sum_{i=0}^k1+X_i\log X_i)\le k+k\sum_{q=2}^nq^2\binom nq(\frac 
1k)^q(1-\frac 1k)^{n-q}=k+k(\frac {n(n-1)}{k^2}+\frac nk)=O(n),$$
protože $k=\alpha n$ a 
$$q^2\binom nq=(q(q-1)+q)\binom nq=n(n-1)\binom {n-2}{q-2}+n\binom {
n-1}{q-1}.$$
(Jedná se vlastně o známý výpočet 2. momentu 
binomického rozdělení). \qed
\end{proof}

Poznámka: V důkazu jsme použili odhad 
$q\log q\le q^2$ a důsledkem toho je, že jsme 
dokázali, že očekávaná složitost {\bf HYBRIDSORTU }
zůstane lineární, i kdybychom v něm místo 
{\bf HEAPSORTU} použili nějaký třídicí algoritmus s 
kvadratickou složitostí, např. {\bf INSERTIONSORT}.

Nyní použijeme modifikaci {\bf BUCKETSORTU} pro 
třídění slov.  Máme totálně 
uspořádanou abecedu a chceme lexikograficky setřídit slova 
$a_1,a_2,\dots,a_n$ nad touto abecedou. Připo\-meň\-me, že když 
$a=x_1x_2\dots x_n$ a $b=y_1y_2\dots y_m$ jsou dvě slova nad totálně 
uspořá\-danou abecedou $\Sigma$, pak $a<b$ v lexikografickém 
uspořádání, právě když existuje $i=0,1,\dots,\min
\{n,m\}$ takové, že 
$x_j=y_j$  pro každé $j=1,2,\dots,i$ a bu\v d $n=i<m$ nebo $
i<\min\{n,m\}$ 
a $x_{i+1}<y_{i+1}$. Předpokládejme, že $a_i=a_i^1a_i^2\dots 
a_i^{l(i)}$, kde 
$a_i^j\in\Sigma$ a $l(i)$ je délka $i$-tého slova $a_i$.

{\bf WORDSORT$(a_1,a_2,\dots,a_n)$}:\newline 
{\bf for every} $i=1,2,\dots,n$ {\bf do} $l(i):=$délka slova $a_
i$ {\bf enddo\newline 
$l=\max\{l(i)\mid i=1,2,\dots,n\}$\newline 
for every} $i=1,2,\dots,l$ {\bf do} $L_i=\emptyset$ {\bf enddo\newline 
for every} $i=1,2,\dots,n$ {\bf do\newline 
\phantom{{\rm---}}$a_i$} vlož do $L_{l(i)}$\newline 
{\bf enddo\newline}
Komentář: Pro každé $i$ obsahuje $L_i$ všechna slova z množiny 
$\{a_1,a_2,\dots,a_n\}$ délky $i$.\newline 
$P_{}:=\{(j,a_i^j)\mid 1\le i\le n,\,1\le j\le l(i)\}$\newline 
$P_1:=${\bf BUCKETSORT$(P)$} podle druhé komponenty\newline 
$P_2:=${\bf BUCKETSORT$(P_1)$} podle první komponenty\newline 
{\bf for every} $i=1,2,\dots,l$ {\bf do} $S_i=\emptyset$ {\bf enddo\newline 
$(i,x):=$}první prvek $P_2$\newline 
{\bf while} $(i,x)\ne NIL$ {\bf do\newline 
\phantom{{\rm---}}$(i,x)$} vlož do $S_i$\newline 
\phantom{---}{\bf while}$(i,x)=$následník $(i,x)$ v $P_2$ {\bf do}\newline
\phantom{{\rm------}}$(i,x):=$následník $(i,x)$ v $P_2$\newline 
\phantom{{\rm---}}{\bf enddo}\newline
\phantom{---}$(i,x):=$následník $(i,x)$ v $P_2$\newline 
{\bf enddo}\newline
Komentář: V $S_i$ jsou všechny dvojice $(i,x)$ takové, že $
x$ 
je $i$-tým písmenem některého vstupního slova a když $
x<y$, pak 
$(i,x)$ je před $(i,y)$.\newline 
{\bf for every} $s\in\Sigma$ {\bf do} $T_s:=\emptyset$ {\bf enddo\newline 
$T:=\emptyset$}, $i:=l$\newline 
{\bf while} $i>0$ {\bf do\newline 
\phantom{{\rm---}}$T:=$} konkatenace $L_i$ a $T$, $a:=$první slovo v $
T$\newline 
\phantom{---}{\bf while} $a\ne NIL$ {\bf do\newline 
\phantom{{\rm------}}$s:=i$}-té písmeno $a$, vlož $a$ do $
T_s$\newline 
\phantom{------}$a:=$následník $a$ v $T$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}$(i,x):=$}první prvek v $S_i$, $T:=\emptyset$\newline 
\phantom{---}{\bf while} $(i,x)\ne NIL$ {\bf do\newline 
\phantom{{\rm------}}$T:=$} konkatenace $T$ a $T_x$, $T_x:=\emptyset$\newline 
\phantom{------}$(i,x):=$následník $(i,x)$ v $S_i$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}$i:=i-1$\newline 
enddo\newline 
Výstup: $T$} je setříděná posloupnost slov $a_1,a_2
,\dots,a_n$

Uvažujme jeden běh posledního cyklu algortimu 
pro určité $i$. Po 
jeho skončení jsou v $T$ všechna slova z množiny 
$a_1,a_2,\dots,a_n$, která mají délku alespoň $i$, a když slovo 
$a_r$ je před $a_q$ v seznamu $T$, pak existuje $j=i-1,i,\dots
,l$
takové, že $a^k_r=a^k_q$ pro každé $k=i,i+1,\dots,j$ a bu\v d 
$l(r)=j\le l(q)$ nebo $j<\min\{l(r),l(q)\}$ a $a_r^{j+1}<a_q^{j+1}$. To plyne z 
vlastností algoritmu {\bf BUCKETSORT} indukcí podle $i$. Jediný a 
hlavní rozdíl proti {\bf BUCKETSORTU} je, že neprocházíme 
všechny přihrádky $T_x$, ale pouze neprázdné. 
To nám zajišťuje množina $S_i$ (viz Komentář). 

Označme $L=\sum_{i=1}^nl(i)$ a připomeňme, že 
$l=\max\{l(i)\mid i=1,2,\dots,n\}$. Pak první cyklus (výpočet  
délek slov) vy\-žaduje čas $O(L)$. Druhý cyklus (inicializace 
seznamů $L_i$) vyžaduje 
čas $O(l)=O(L)$ a třetí cyklus (zařazení slov do $
L_i$ podle 
délek) čas $O(n)=O(L)$. Vytvoření 
seznamu $P_{}$ vyžaduje čas $O(L)$ a jeho setřídění podle obou 
komponent  
čas $O(L+l)=O(L)$, protože $P_{}$ i $P_1$ mají nejvýše $
L$ 
prvků. Další cyklus (založení seznamů 
$S_i$) vyžaduje čas $O(l)$ a následující cyklus vytvářející 
seznamy $S_i$ čas $O(L)$. Cyklus zakládající 
seznamy $T_x$ vyžaduje čas $O(|\Sigma |)$. Běhy dalšího cyklu jsou 
indexovány $i=1,2,\dots,l$. Pro každé $i$ označme $m_i$ počet slov z 
množiny $\{a_1,a_2,\dots,a_n\}$, která mají délku alespoň $
i$. Pak 
$L=\sum_{i=1}^lm_i$ a první vnitřní cyklus v $i$-tém běhu vnějšího 
cyklu vyžaduje čas $O(m_i)$ a druhý vnitřní cyklus 
čas $O(|S_i|)=O(m_i)$. Tedy 
celkový čas algoritmu je $O(L+m)$, kde $m=|\Sigma |$ a $L$ 
je součet délek všech slov z množiny $a_1,a_2,\dots,a_
n$.

\section{{Pořádkové statistiky}}

Na závěr popíšeme dva algoritmy pro hledání $
k$-tého 
nejmenší\-ho prvku v dané podmnožině totálně 
uspořádané\-ho univerza. Prv\-ní z nich využívá  
stejný princip jako {\bf QUICKSORT}. Nejprve zadáme 
přesné zně\-ní naší úlohy (úloha i algoritmy se dají 
snadno přeformulovat pro případ, kdy hledáme $k-$tý 
největší prvek).

Pracujeme s totálně uspořádaným univerzem $
U$.\newline 
Vstup: množina prvků $M=\{a_1,a_2,\dots,a_n\}\subseteq 
U$ a číslo $i$ takové, 
že $1\le i\le n$.\newline 
Výstup: prvek $a_k$ takový, že 
$|\{j\mid 1\le j\le n,\,a_j\le a_k\}|=i$.\newline 
Když $i=\frac n2$, pak $a_k$ se nazývá \emph{medián}.

{\bf FIND$(M=(a_1,a_2,\dots,a_n),i)$}:\newline 
zvol $a\in M$\newline
$M_1:=\{b\in M\mid b<a\}$, 
$M_2:=\{b\in M\mid b>a\}$\newline 
{\bf if} $|M_1|>i-1$ {\bf then\newline 
\phantom{{\rm ---}}FIND$(M_1,i)$\newline 
else\newline 
\phantom{{\rm ---}}if} $|M_1|<i-1$ {\bf then\newline 
\phantom{{\rm ------}}FIND$(M_2,i-|M_1|-1)$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm------}}Výstup: $a$} je hledaný prvek\newline 
\phantom{---}{\bf endif\newline 
endif}

Důkaz korektnosti algoritmu je založen na následujícím 
jednoduchém pozorování: mějme množinu $M$ a prvek $
x$ a 
položme $M_1=\{m\in M\mid m<x\}$. Když $k\le |M_1|$, pak $k$-tý 
nejmenší 
prvek v $M_1$ je stejný jako $k$-tý nejmenší prvek v $
M$. Když 
$k>|M_1|$, pak $(k-|M_1|)$-tý nejmenší prvek v $M\setminus 
M_1$ je $k$-tý 
nejmenší prvek v $M$.  
Zbývá vyšetřit složitost.

V nejhorším případě 
voláme {\bf FIND} $n$-krát a jedno volání vyžaduje čas $
O(|M|)$.  
Tedy časová složitost algoritmu 
{\bf FIND} v nejhorším případě je $O(n^2)$.  Dobré volby 
prvku $a$ mohou algoritmus značně zrychlit.  V tomto 
případě platí stejná 
diskuse jako pro {\bf QUICKSORT}.  Spočítáme očekávaný čas 
za předpokladu, že  
pr\-vek $a$ byl vybrán náhodně.  Pak pravděpodobnost, že je 
$k$-tým nejmenším prvkem, je $\frac 1n$, kde $n=|M|$.  Označme $
T(n,i)$ 
očekávaný čas algoritmu {\bf FIND} pro nalezení $i$-tého nejmenšího 
prvku v $n$-prvkové množině $M$.  Platí 
$$T(n,i)=n+\frac 1n(\sum_{k=1}^{i-1}T(n-k,i-k)+\sum_{k=i+1}^nT(k,
i)),$$
protože procedura {\bf FIND} bez rekurzivního volání sebe sama 
vyžaduje čas $O(n)$. Předpoklá\-dej\-me, že $T(m,i)
\le 4m$ 
pro každé $m<n$ a každé $i$ takové, že $1\le i\le 
m$. Pak 
$$\align T(n,i)=&n+\frac 1n(\sum_{k=1}^{i-1}T(n-k,i-k)+\sum_{k=i+
1}^nT(k,i))\le n+\frac 1n(\sum_{k=1}^{i-1}4(n-k)+\sum_{k=i+1}^n4k
)=\\
&n+\frac 4n(\frac {(2n-i)(i-1)}2+\frac {(n+i+1)(n-i)}2)=n+\frac 4
n(\frac {n^2+2ni-n-2i^2}2).\endalign$$
Výraz v čitateli zlomku nabývá svého maxima pro 
$i=\frac n2$ a jeho maximalní hodnota je 
$\frac 32n^2-n=\frac {3n^2-2n}2$. Tedy
$$T(n,i)\le n+\frac 4n(\frac {3n^2-2n}4)=n+3n-2=4n-2<4n.$$
Protože tento odhad platí také pro $n=1$ a $n=2$, dokázali 
jsme indukcí, že $T(n,i)\le 4n$ pro všechna $n$ a všechna $
i$ 
taková, že $1\le i\le n$. Platí tedy 

\begin{veta}Algoritmus {\bf FIND} nalezne $i$-tý nejmenší 
prvek v $n$ prv\-kové totálně uspořádané mno\-ži\-ně a v nejhorším 
případě vyža\-du\-je čas $O(n^2)$. Když se pivot volí 
náhodně nebo když všechny vstupní množiny mají stejnou 
pravděpodobnost, pak očekávaný čas je $O(n)$.
\end{veta}

Pro velmi malá $i$ nebo pro $i$ velmi blízká $n$ 
pracuje rychleji přímý přirozený algoritmus (udržuje si 
posloupnost $i$ nejmen\-ších nebo $n-i$ největších prvků 
a k ní přidává další tak, že ten prvek, který pře\-kročil 
danou hranici, je 
zapomenut). Tento algoritmus však není 
efektivní pro obecná $i$. 

Následující algoritmus nalezne $i$-tý nejmenší 
prvek v lineárním čase i v nejhorším případě.  Vstupem 
je opět podmnožina $M$ totálně 
uspořádaného univerza $U$ a přirozené číslo $i$ takové, že 
$1\le i\le |M|$.  

{\bf SELECT$(M,i)$}:\newline 
$n:=|M|$\newline 
{\bf if} $n\le 100$ {\bf then\newline 
\phantom{{\rm---}}}setři\v d množinu $M$, $m:=$ $i$-tý nejmenší 
prvek $M$\newline 
{\bf else\newline 
\phantom{{\rm---}}}rozděl $M$ do navzájem disjunktních 
pětiprvkových podmnožin $A_1,A_2,\dots,A_{\lceil\frac n5\rceil}$\newline 
\phantom{---}(poslední z podmnožin může mít méně než 5 prvků).\newline 
\phantom{---}{\bf for every} $j=1,2,\dots,\lceil\frac n5\rceil$ {\bf do\newline 
\phantom{{\rm------}}}najdi medián $m_j$ množiny $A_j$\newline 
\phantom{---}{\bf enddo\newline 
\phantom{{\rm ---}}$\bar {m}:=$SELECT$(\{m_j\mid j=1,2,\dots,\lceil\frac 
n5\rceil \},\lceil\frac n{10}\rceil )$\newline 
\phantom{{\rm ---}}$M_1:=\{m\in M\mid m<\bar {m}\}$}, $M_2:=\{m\in 
M\mid\bar {m}<m\}$\newline 
\phantom{---}{\bf if} $|M_1|>i-1$ {\bf then\newline 
\phantom{{\rm ------}}$m:=$SELECT$(M_1,i)$\newline 
\phantom{{\rm ---}}else\newline 
\phantom{{\rm------}}if} $|M_1|<i-1$ {\bf then\newline 
\phantom{{\rm ---------}}$m:=$SELECT$(M_2,i-|M_1|-1)$\newline 
\phantom{{\rm ------}}else\newline 
\phantom{{\rm ---------}}$m:=\bar {m}$\newline 
\phantom{{\rm ------}}endif\newline 
\phantom{{\rm ---}}endif\newline 
\phantom{{\rm ---}}Výstup}: $m$\newline 
{\bf endif

}
Důkaz korektnosti algoritmu je stejný 
jako u algoritmu {\bf FIND}. 
Zbývá vyšetřit složitost. Nej\-prve dokážeme následující 
lemma.

\begin{lemma}Když $n\ge 100$, pak $|M_1|,|M_2|\le\frac {8n}{
11}$.
\end{lemma}

\begin{proof} Pro $j\le\lfloor\frac n5\rfloor$ platí, že když $
m_j<\bar {m}$, pak 
$|A_j\cap M_1|\ge 3$, když $m_j>\bar {m}$, pak $|A_j\cap M_2|\ge 
3$, když $m_j=\bar {m}$, 
pak $|A_j\cap M_1|=|A_j\cap M_2|=2$.  Protože 
$|\{j=0,1,\dots,\lfloor\frac n5\rfloor\mid m_j<\bar {m}\}|,|\{j=0
,1,\dots,\lfloor\frac n5\rfloor\mid m_j>\bar {m}\}|\ge\lfloor\frac 
n{10}\rfloor$, 
dostáváme, že $|M_1|,|M_2|\ge\lfloor\frac {3n}{10}\rfloor 
-1$.  Dále platí $M_1\cap M_2=\emptyset$, 
$M_1\cup M_2=M\setminus \{\bar {m}\}$ a protože $\frac {8n}{11}
+\lfloor\frac {3n}{10}\rfloor -1\ge\frac {113n}{110}-2\ge n$ 
když $n>100$, dostáváme požadovaný odhad. \qed
\end{proof}

Maximální čas vyžadovaný algoritmem  
{\bf SELECT$(M,i)$} pro $|M|=n$ označme $T(n)$.  Když $n\le 
100$, pak zřejmě 
exis\-tuje konstanta $a$ taková, že $T(n)\le an$.  Když $
n>100$, 
pak $\lceil\frac n5\rceil\le\frac {21n}{100}$, a protože {\bf SELECT$
(M,i)$} pro $|M|>100$ bez 
rekurentních volání vyžaduje čas $O(|M|)$, platí, že $
T(n)\le T(\frac {21n}{100})+T(\frac {8n}{11})+bn$ pro nějakou konstantu 
$b$.  Zvolme $c\ge\max\{a,\frac {1100b}{69}\}$. Ukážeme, že $
T(n)\le cn$ pro 
všechna $n$.  
Když $n\le 100$, tak tvrzení zřejmě platí, protože $
a\le c$.  Když 
$n>100$, pak $\lceil\frac {21n}{100}\rceil ,\lceil\frac {8n}{11}\rceil 
<n$, a protože z volby $c$ plyne 
$b\le\frac {69}{1100}c$, 
dostáváme 
$$T(n)\le c\frac {21n}{100}+c\frac {8n}{11}+bn=(\frac {1031c}{110
0}+b)n\le cn.$$
Tedy

\begin{veta}Algoritmus {\bf SELECT} nalezne $i$-tý nejmenší 
prvek v lineárním čase.
\end{veta}

Algoritmus {\bf FIND} je ve velké většině 
případů 
rychlejší než algoritmus {\bf SELECT}, proto je v praxi 
doporučován, i když existují 
případy (velmi řídké), kdy potřebuje kvadratický čas.
Je známo, že medián $n$-prvkové množiny lze nalézt s 
méně než $3n$ porovnáními a že každý algoritmus hledající 
medián a používající porovnání jako jedinou primitivní 
operaci mezi prvky množiny vyžaduje více než $2n$ 
porovnání.

\subsection{
Historický přehled
}

Algoritmus {\bf HEAPSORT }
navrhl v roce 1964 Williams a vylepšil Floyd (rovněž 1964).  Návrh 
na použití $d$-regulár\-ních hald je folklor stejně tak jako  
algoritmus {\bf MER\-GESORT}.  Algoritmy {\bf QUICKSORT} a {\bf FIND }
zavedl Hoare (1962).  Analýza ope\-race {\bf MERGE} a 
hledání optimálního stro\-mu pochází od Huffmana 
(1952) a lineární implementaci algoritmu navrhl van 
Leeuwen (1976).  Analýza rozhodovacích stromů je 
folklor. Algoritmus {\bf HYBRIDSORT} navrhli Meijer a Akl (1980), 
vylepše\-ná verze {\bf BUCKETSORTU} (nazvaná {\bf WORDSORT}) 
pochází od Aho, Hopcrofta a Ullmana (1974). Algoritmus {\bf SELECT} byl 
navržen Blumem, Floydem, Prattem, Rivestem a 
Tarjanem (1972).  

\end{document}
